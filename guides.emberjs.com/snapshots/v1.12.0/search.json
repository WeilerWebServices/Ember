{"documents": [{"external_id":"b08ba4accecf68e2f43acec372677712","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/application/","type":"enum"},{"name":"body","value":"Creating an Application\nEvery Ember.js application has one instance of Ember.Application.\nThis object is located at ./app/app.js inside your project.\n\nWhat does creating an Ember.Application instance get you?\n\n\nIt adds event listeners to the document and is responsible for\ndelegating events to your views. (See The View\nLayer\nfor a detailed description.)\nIt automatically renders the application\ntemplate.\nIt automatically creates a router and begins routing, choosing which\ntemplate and model to display based on the current URL.\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"47913aec12ee9dbd0749f8ee0c891428","fields":[{"name":"title","value":"Customizing a Component's Element","type":"string"},{"name":"url","value":"/components/customizing-a-components-element/","type":"enum"},{"name":"body","value":"By default, each component is backed by a \u003cdiv\u003e element. If you were\nto look at a rendered component in your developer tools, you would see\na DOM representation that looked something like:\n\n  1\n2\n3\n\n  \u003cdiv id=\"ember180\" class=\"ember-view\"\u003e\n  \u003ch1\u003eMy Component\u003c/h1\u003e\n\u003c/div\u003e\n\n\n\nYou can customize what type of element Ember generates for your\ncomponent, including its attributes and class names, by creating a\nsubclass of Ember.Component in your JavaScript.\nCustomizing the Element\nTo use a tag other than div, subclass Ember.Component and assign it\na tagName property. This property can be any valid HTML5 tag name as a\nstring.\n\n  \n    \n      app/components/navigation-bar.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Component.extend({\n  tagName: 'nav'\n});\n\n\n\n  \n    \n      app/templates/components/navigation-bar.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  \u003cul\u003e\n  \u003cli\u003e{{#link-to 'home'}}Home{{/link-to}}\u003c/li\u003e\n  \u003cli\u003e{{#link-to 'about'}}About{{/link-to}}\u003c/li\u003e\n\u003c/ul\u003e\n\n\nCustomizing Class Names\nYou can also specify which class names are applied to the component's\nelement by setting its classNames property to an array of strings:\n\n  \n    \n      app/components/navigation-bar.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Component.extend({\n  classNames: ['primary']\n});\n\n\n\nIf you want class names to be determined by properties of the component,\nyou can use class name bindings. If you bind to a Boolean property, the\nclass name will be added or removed depending on the value:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isUrgent'],\n  isUrgent: true\n});\n\n\n\nThis component would render the following:\n\n  1\n\n  \u003cdiv class=\"ember-view is-urgent\"\u003e\u003c/div\u003e\n\n\n\nIf isUrgent is changed to false, then the is-urgent class name will be removed.\n\nBy default, the name of the Boolean property is dasherized. You can customize the class name\napplied by delimiting it with a colon:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isUrgent:urgent'],\n  isUrgent: true\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view urgent\"\u003e\n\n\n\nBesides the custom class name for the value being true, you can also specify a class name which is used when the value is false:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isEnabled:enabled:disabled'],\n  isEnabled: false\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view disabled\"\u003e\n\n\n\nYou can also specify a class which should only be added when the property is\nfalse by declaring classNameBindings like this:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['isEnabled::disabled'],\n  isEnabled: false\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view disabled\"\u003e\n\n\n\nIf the isEnabled property is set to true, no class name is added:\n\n  1\n\n  \u003cdiv class=\"ember-view\"\u003e\n\n\n\nIf the bound property's value is a string, that value will be added as a class name without\nmodification:\n\n  \n    \n      app/components/todo-item.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Component.extend({\n  classNameBindings: ['priority'],\n  priority: 'highestPriority'\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view highestPriority\"\u003e\n\n\nCustomizing Attributes\nYou can bind attributes to the DOM element that represents a component\nby using attributeBindings:\n\n  \n    \n      app/components/link-item.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Component.extend({\n  tagName: 'a',\n  attributeBindings: ['href'],\n  href: \"http://emberjs.com\"\n});\n\n\n\nYou can also bind these attributes to differently named properties:\n\n  \n    \n      app/components/link-item.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Component.extend({\n  tagName: 'a',\n  attributeBindings: ['customHref:href'],\n  customHref: \"http://emberjs.com\"\n});\n\n\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6faa3aaa66dd8ba5f798d307f0136e3c","fields":[{"name":"title","value":"Defining a Component","type":"string"},{"name":"url","value":"/components/defining-a-component/","type":"enum"},{"name":"body","value":"To define a component, create a template whose name starts with\ncomponents/. To define a new component, {{blog-post}} for example,\ncreate a components/blog-post template.\n\nNote: Components must have a dash in their name. So blog-post is an acceptable name,\nbut post is not. This prevents clashes with current or future HTML element names, and\nensures Ember picks up the components automatically.\n\nA sample component template would look like this:\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n\n  \u003ch1\u003eBlog Post\u003c/h1\u003e\n\u003cp\u003eLorem ipsum dolor sit amet.\u003c/p\u003e\n\n\n\nHaving a template whose name starts with components/ creates a\ncomponent of the same name. Given the above template, you can now use the\n{{blog-post}} custom element:\n\n\n\n\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  {{#each model as |post|}}\n  {{#blog-post title=post.title}}\n    {{post.body}}\n  {{/blog-post}}\n{{/each}}\n\n\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003carticle class=\"blog-post\"\u003e\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n  \u003cp\u003e{{yield}}\u003c/p\u003e\n  \u003cp\u003eEdit title: {{input type=\"text\" value=title}}\u003c/p\u003e\n\u003c/article\u003e\n\n\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  var posts = [{\n    title: \"Rails is omakase\",\n    body: \"There are lots of Ã  la carte software environments in this world.\"\n  }, {\n    title: \"Broken Promises\",\n    body: \"James Coglan wrote a lengthy article about Promises in node.js.\"\n}];\n\nexport default Ember.Route.extend({\n  model: function() {\n    return posts;\n  }\n});\n\n\n\n  \n    \n      app/components/blog-post.js\n    \n  \n\n  1\n2\n\n  export default Ember.Component.extend({\n});\n\n\n\nEach component, under the hood, is backed by an element. By default\nEmber will use a \u003cdiv\u003e element to contain your component's template.\nTo learn how to change the element Ember uses for your component, see\nCustomizing a Component's\nElement.\nDefining a Component Subclass\nOften times, your components will just encapsulate certain snippets of\nHandlebars templates that you find yourself using over and over. In\nthose cases, you do not need to write any JavaScript at all. Just define\nthe Handlebars template as described above and use the component that is\ncreated.\n\nIf you need to customize the behavior of the component you'll\nneed to define a subclass of Ember.Component. For example, you would\nneed a custom subclass if you wanted to change a component's element,\nrespond to actions from the component's template, or manually make\nchanges to the component's element using JavaScript.\n\nEmber knows which subclass powers a component based on its name. For\nexample, if you have a component called blog-post, you would create a\nfile at app/components/blog-post.js. If your component was called\naudio-player-controls, the file name would be at\napp/components/audio-player-controls.js\n\nIn other words, Ember will look for a class with the camelized name of\nthe component, followed by Component.\n\n\n  \n  \n    Component Name\n    Component Class\n  \n  \n  \n    blog-post\n    App.BlogPostComponent\n  \n  \n    audio-player-controls\n    App.AudioPlayerControlsComponent\n  \n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"89cbe21cbd7181ade5de9485d9bd1da7","fields":[{"name":"title","value":"Handling User Interaction with Actions","type":"string"},{"name":"url","value":"/components/handling-user-interaction-with-actions/","type":"enum"},{"name":"body","value":"Components allow you to define controls that you can reuse throughout\nyour application. If they're generic enough, they can also be shared\nwith others and used in multiple applications.\n\nTo make a reusable control useful, however, you first need to allow\nusers of your application to interact with it.\n\nYou can make elements in your component interactive by using the\n{{action}} helper. This is the same {{action}} helper you use in\napplication templates, but it has an\nimportant difference when used inside a component.\n\nInstead of sending an action to the template's controller, then bubbling\nup the route hierarchy, actions sent from inside a component are sent\ndirectly to the component's Ember.Component instance, and do not\nbubble.\n\nFor example, imagine the following component that shows a post's title.\nWhen the title is clicked, the entire post body is shown:\n\n  \n    \n      app/templates/components/post-summary.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  \u003ch3 {{action \"toggleBody\"}}\u003e{{title}}\u003c/h3\u003e\n{{#if isShowingBody}}\n  \u003cp\u003e{{{body}}}\u003c/p\u003e\n{{/if}}\n\n\n\n  \n    \n      app/components/post-summary.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Component.extend({\n  actions: {\n    toggleBody: function() {\n      this.toggleProperty('isShowingBody');\n    }\n  }\n});\n\n\n\n\n\nThe {{action}} helper can accept arguments, listen for different event\ntypes, control how action bubbling occurs, and more.\n\nFor details about using the {{action}} helper, see the Actions\nsection of the Templates chapter.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a7fac78db6b283e0bea80138768d18ef","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/components/","type":"enum"},{"name":"body","value":"HTML was designed in a time when the browser was a simple document\nviewer. Developers building great web apps need something more.\n\nInstead of trying to replace HTML, however, Ember.js embraces it, then adds\npowerful new features that modernize it for building web apps.\n\nCurrently, you are limited to the tags that are created for you by the\nW3C. Wouldn't it be great if you could define your own,\napplication-specific HTML tags, then implement their behavior using\nJavaScript?\n\nThat's exactly what components let you do. In fact, it's such a good\nidea that the W3C is currently working on the Custom\nElements\nspec.\n\nEmber's implementation of components hews as closely to the Web\nComponents specification as possible.\nOnce Custom Elements are widely available in browsers, you should be able to\neasily migrate your Ember components to the W3C standard and have them be\nusable by other frameworks.\n\nThis is so important to us that we are working closely with the\nstandards bodies to ensure our implementation of components matches the\nroadmap of the web platform.\n\nTo highlight the power of components, here is a short example of turning a blog post into a reusable\nblog-post custom element that you could use again and again in your\napplication. Keep reading this section for more details on building\ncomponents.\n\n\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  {{#each model as |post|}}\n   {{#blog-post title=post.title}}\n     {{post.body}}\n   {{/blog-post}}\n{{/each}}\n\n\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003carticle class=\"blog-post\"\u003e\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n  \u003cp\u003e{{yield}}\u003c/p\u003e\n  \u003cp\u003eEdit title: {{input type=\"text\" value=title}}\u003c/p\u003e\n\u003c/article\u003e\n\n\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  var posts = [{\n    title: \"Rails is omakase\",\n    body: \"There are lots of Ã  la carte software environments in this world.\"\n  }, {\n    title: \"Broken Promises\",\n    body: \"James Coglan wrote a lengthy article about Promises in node.js.\"\n}];\n\nexport default Ember.Route.extend({\n  model: function() {\n    return posts;\n  }\n});\n\n\n\n  \n    \n      app/components/blog-post.js\n    \n  \n\n  1\n2\n\n  export default Ember.Component.extend({\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8d2797c18261ac73c76de693da7cae13","fields":[{"name":"title","value":"Passing Properties to a Component","type":"string"},{"name":"url","value":"/components/passing-properties-to-a-component/","type":"enum"},{"name":"body","value":"By default a component does not have access to properties in the\ntemplate scope in which it is used.\n\nFor example, imagine you have a blog-post component that is used to\ndisplay a blog post:\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n\n  \u003ch1\u003eComponent: {{title}}\u003c/h1\u003e\n\u003cp\u003eLorem ipsum dolor sit amet.\u003c/p\u003e\n\n\n\nYou can see that it has a {{title}} Handlebars expression to print the\nvalue of the title property inside the \u003ch1\u003e.\n\nNow imagine we have the following template and route:\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  model: function() {\n    return {\n      title: \"Rails is omakase\"\n    };\n  }\n});\n\n\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n\n  \n\u003ch1\u003eTemplate: {{title}}\u003c/h1\u003e\n{{blog-post}}\n\n\n\nRunning this code, you will see that the first \u003ch1\u003e (from the outer\ntemplate) displays the title property, but the second \u003ch1\u003e (from\ninside the component) is empty.\n\n\n\nWe can fix this by making the title property available to the\ncomponent:\n\n  1\n\n  {{blog-post title=title}}\n\n\n\nThis will make the title property in the outer template scope\navailable inside the component's template using the same name, title.\n\n\n\nIf, in the above example, the model's title property was instead\ncalled name, we would change the component usage to:\n\n  1\n\n  {{blog-post title=name}}\n\n\n\n\n\nIn other words, you are binding a named property from the outer scope to\na named property in the component scope, with the syntax\ncomponentProperty=outerProperty.\n\nIt is important to note that the value of these properties is bound.\nWhether you change the value on the model or inside the component, the\nvalues stay in sync. In the following example, type some text in the\ntext field either in the outer template or inside the component and note\nhow they stay in sync.\n\n\n\nYou can also bind properties from inside an {{#each}} loop. This will\ncreate a component for each item and bind it to each model in the loop.\n\n  1\n2\n3\n\n  {{#each model as |post|}}\n  {{blog-post title=post.title}}\n{{/each}}\n\n\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6a770b7ecc3a463d75a45227c9b80486","fields":[{"name":"title","value":"Sending Actions from Components to Your Application","type":"string"},{"name":"url","value":"/components/sending-actions-from-components-to-your-application/","type":"enum"},{"name":"body","value":"When a component is used inside a template, it has the ability to send\nactions to that template's controller and routes. These allow the\ncomponent to inform the application when important events, such as the\nuser clicking a particular element in a component, occur.\n\nLike the {{action}} Handlebars helper, actions sent from components\nfirst go to the template's controller. If the controller does not\nimplement a handler for that action, it will bubble to the template's\nroute, and then up the route hierarchy. For more information about this\nbubbling behavior, see Action\nBubbling.\n\nComponents are designed to be reusable across different parts of your\napplication. In order to achieve this reusability, it's important that\nthe actions that your components send can be specified when the component\nis used in a template.\n\nIn other words, if you were writing a button component, you would not\nwant to send a click action, because it is ambiguous and likely to\nconflict with other components on the page. Instead, you would want to\nallow the person using the component to specify which action to send\nwhen the button was clicked.\n\nLuckily, components have a sendAction() method that allows them to\nsend actions specified when the component is used in a template.\nSending a Primary Action\nMany components only send one kind of action. For example, a button\ncomponent might send an action when it is clicked on; this is the\nprimary action.\n\nTo set a component's primary action, set its action attribute in\nHandlebars:\n\n  1\n\n  {{my-button action=\"showUser\"}}\n\n\n\nThis tells the my-button component that it should send the showUser\naction when it triggers its primary action.\n\nSo how do you trigger sending a component's primary action? After\nthe relevant event occurs, you can call the sendAction() method\nwithout arguments:\n\n  \n    \n      app/components/my-button.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Component.extend({\n  click: function() {\n    this.sendAction();\n  }\n});\n\n\n\nIn the above example, the my-button component will send the showUser\naction when the component is clicked.\nSending Parameters with an Action\nYou may want to provide additional context to the route or controller\nhandling an action. For example, a button component may want to tell a\ncontroller not only that an item was deleted, but also which item.\n\nTo send parameters with the primary action, call sendAction() with the\nstring 'action' as the first argument and any additional parameters\nfollowing it:\n\n  1\n\n  this.sendAction('action', param1, param2);\n\n\n\nFor example, imagine we're building a todo list that allows the user to\ndelete a todo:\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  export default Ember.Route.extend({\n  model: function() {\n    return {\n      todos: [{\n        title: \"Learn Ember.js\"\n      }, {\n        title: \"Walk the dog\"\n      }]\n    };\n  },\n\n  actions: {\n    deleteTodo: function(todo) {\n      var todos = this.modelFor('index').todos;\n      todos.removeObject(todo);\n    }\n  }\n});\n\n\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#each todos as |todo|}}\n  \u003cp\u003e{{todo.title}} \u003cbutton {{action \"deleteTodo\" todo}}\u003eDelete\u003c/button\u003e\u003c/p\u003e\n{{/each}}\n\n\n\nWe want to update this app so that, before actually deleting a todo, the\nuser must confirm that this is what they intended. We'll implement a\ncomponent that first double-checks with the user before completing the\naction.\n\nIn the component, when triggering the primary action, we'll pass an\nadditional argument that the component user can specify:\n\n  \n    \n      app/components/confirm-button.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Component.extend({\n  actions: {\n    showConfirmation: function() {\n      this.toggleProperty('isShowingConfirmation');\n    },\n\n    confirm: function() {\n      this.toggleProperty('isShowingConfirmation');\n      this.sendAction('action', this.get('param'));\n    }\n  }\n});\n\n\n\n  \n    \n      app/templates/components/confirm-button.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  {{#if isShowingConfirmation}}\n  \u003cbutton {{action \"confirm\"}}\u003eClick again to confirm\u003c/button\u003e\n{{else}}\n  \u003cbutton {{action \"showConfirmation\"}}\u003e{{title}}\u003c/button\u003e\n{{/if}}\n\n\n\nNow we can update our initial template and replace the {{action}}\nhelper with our new component:\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#each todos as |todo|}}\n  \u003cp\u003e{{todo.title}} {{confirm-button title=\"Delete\" action=\"deleteTodo\" param=todo}}\u003c/p\u003e\n{{/each}}\n\n\n\nNote that we've specified the action to send by setting the component's\naction attribute, and we've specified which argument should be sent as\na parameter by setting the component's param attribute.\n\n\nSending Multiple Actions\nDepending on the complexity of your component, you may need to let users\nspecify multiple different actions for different events that your\ncomponent can generate.\n\nFor example, imagine that you're writing a form component that the user\ncan either submit or cancel. Depending on which button the user clicks,\nyou want to send a different action to your controller or route.\n\nYou can specify which action to send by passing the name of the event\nas the first argument to sendAction(). For example, you can specify two\nactions when using the form component:\n\n  1\n\n  {{user-form submit=\"createUser\" cancel=\"cancelUserCreation\"}}\n\n\n\nIn this case, you can send the createUser action by calling\nthis.sendAction('submit'), or send the cancelUserCreation action by\ncalling this.sendAction('cancel').\n\n\nActions That Aren't Specified\nIf someone using your component does not specify an action for a\nparticular event, calling sendAction() has no effect.\n\nFor example, if you define a component that triggers the primary action\non click:\n\n  \n    \n      app/components/my-button.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Component.extend({\n  click: function() {\n    this.sendAction();\n  }\n});\n\n\n\nUsing this component without assigning a primary action will have no\neffect if the user clicks it:\n\n  1\n\n  {{my-button}}\n\n\nThinking About Component Actions\nIn general, you should think of component actions as translating a\nprimitive event (like a mouse click or an \u003caudio\u003e element's pause\nevent) into actions that have meaning within your application.\n\nThis allows your routes and controllers to implement action handlers\nwith names like deleteTodo or songDidPause instead of vague names\nlike click or pause that may be ambiguous to other developers when\nread out of context.\n\nAnother way to think of component actions is as the public API of your\ncomponent. Thinking about which events in your component can trigger\nactions in their application is the primary way other developers will\nuse your component. In general, keeping these events as generic as\npossible will lead to components that are more flexible and reusable.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e9763ebaa18b58c8fafed5531d19eb14","fields":[{"name":"title","value":"Wrapping Content in a Component","type":"string"},{"name":"url","value":"/components/wrapping-content-in-a-component/","type":"enum"},{"name":"body","value":"Sometimes, you may want to define a component that wraps content\nprovided by other templates.\n\nFor example, imagine we are building a blog-post component that we can\nuse in our application to display a blog post:\n\n  \n    \n      app/components/blog-post.hbs\n    \n  \n\n  1\n2\n\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n\u003cdiv class=\"body\"\u003e{{body}}\u003c/div\u003e\n\n\n\nNow, we can use the {{blog-post}} component and pass it properties\nin another template:\n\n  1\n\n  {{blog-post title=title body=body}}\n\n\n\n\n\n(See Passing Properties to a\nComponent for\nmore.)\n\nIn this case, the content we wanted to display came from the model. But\nwhat if we want the developer using our component to be able to provide custom\nHTML content?\n\nIn addition to the simple form you've learned so far, components also\nsupport being used in block form. In block form, components can be\npassed a Handlebars template that is rendered inside the component's\ntemplate wherever the {{yield}} expression appears.\n\nTo use the block form, add a # character to the\nbeginning of the component name, then make sure to add a closing tag.\n(See the Handlebars documentation on block expressions for more.)\n\nIn that case, we can use the {{blog-post}} component in block form\nand tell Ember where the block content should be rendered using the\n{{yield}} helper. To update the example above, we'll first change the component's\ntemplate:\n\n  \n    \n      app/templates/components/blog-post.hbs\n    \n  \n\n  1\n2\n\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n\u003cdiv class=\"body\"\u003e{{yield}}\u003c/div\u003e\n\n\n\nYou can see that we've replaced {{body}} with {{yield}}. This tells\nEmber that this content will be provided when the component is used.\n\nNext, we'll update the template using the component to use the block\nform:\n\n  \n    \n      app/templates/index.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  {{#blog-post title=title}}\n  \u003cp class=\"author\"\u003eby {{author}}\u003c/p\u003e\n  {{body}}\n{{/blog-post}}\n\n\n\n\n\nIt's important to note that the template scope inside the component\nblock is the same as outside. If a property is available in the template\noutside the component, it is also available inside the component block.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2ae1d52f685486a7d60a04e02e241913","fields":[{"name":"title","value":"Core Concepts","type":"string"},{"name":"url","value":"/concepts/core-concepts/","type":"enum"},{"name":"body","value":"To get started with Ember.js, there are a few core concepts you\nshould understand.\n\nEmber.js is designed to help developers build ambitiously large web\napplications that are competitive with native apps. Doing so requires\nboth new tools and a new vocabulary of concepts. We've spent a lot of\ntime borrowing ideas pioneered by native application frameworks like\nCocoa and Smalltalk.\n\nHowever, it's important to remember what makes the web special. Many\npeople think that something is a web application because it uses\ntechnologies like HTML, CSS and JavaScript. In reality, these are just\nimplementation details.\n\nInstead, the web derives its power from the ability to bookmark and\nshare URLs. URLs are the key feature that give web applications\nsuperior shareability and collaboration. Today, most JavaScript\nframeworks treat the URL as an afterthought, instead of the primary\nreason for the web's success.\n\nEmber.js, therefore, marries the tools and concepts of native\nGUI frameworks with support for the feature that makes the web so\npowerful: the URL.\nConceptsTemplates\nA template, written in the Handlebars templating language, describes\nthe user interface of your application. Each template is backed by a\nmodel, and the template automatically updates itself if the model changes.\n\nIn addition to plain HTML, templates can contain:\n\n\nExpressions, like {{firstName}}, which take information from\nthe template's model and put it into HTML.\nOutlets, which are placeholders for other templates. As users\nmove around your app, different templates can be plugged into the\noutlet by the router. You can put outlets into your template using the\n{{outlet}} helper.\nComponents, custom HTML elements that you can use to clean up\nrepetitive templates or create reusable controls.\n\nRouter\nThe router translates a URL into a series of nested templates, each\nbacked by a model. As the templates or models being shown to the user\nchange, Ember automatically keeps the URL in the browser's address bar\nup-to-date.\n\nThis means that, at any point, users are able to share the URL of your\napp. When someone clicks the link, they reliably see the same content as\nthe original user.\nComponents\nA component is a custom HTML tag whose behavior you implement using\nJavaScript and whose appearance you describe using Handlebars templates.\nThey allow you to create reusable controls that can simplify your\napplication's templates.\nModels\nA model is an object that stores persistent state. Templates are\nresponsible for displaying the model to the user by turning it into\nHTML. In many applications, models are loaded via an HTTP JSON API,\nalthough Ember is agnostic to the backend that you choose.\nRoute\nA route is an object that tells the template which model it should\ndisplay.\n\nThese are the core concepts you'll need to understand as you develop\nyour Ember.js app. They are designed to scale up in complexity, so that\nadding new functionality doesn't force you to go back and refactor major\nparts of your app.\n\nNow that you understand the roles of these objects, you're equipped to\ndive deep into Ember.js and learn the details of how each of these\nindividual pieces work.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"c8116f59e37526b373ebee360ffadc30","fields":[{"name":"title","value":"Naming Conventions","type":"string"},{"name":"url","value":"/concepts/naming-conventions/","type":"enum"},{"name":"body","value":"Ember.js uses a runtime resolver to wire up your objects without a\nlot of boilerplate. As a developer, this resolver will work automatically\nif you place code in conventional locations within your project.\n\nYou can usually guess the names and locations, but this guide outlines, in one place,\nall of the naming conventions.\nThe Application\nWhen your application boots, Ember will look for the objects exported\nby these modules in your project:\n\n\napp/app.js\napp/controllers/application.js\napp/templates/application.hbs\n\n\nEmber.js will render the application template as the main template.\nIf controller:application is provided, Ember.js will set an\ninstance of controller:application as the controller for the\ntemplate. This means that the template will get its properties from\nthe controller.\n\nIf your app provides a route at app/routes/application.js Ember.js will invoke\nthe router's hooks first, before rendering the\napplication template. Hooks are implemented as methods and provide\nyou access points within an Ember object's lifecycle to intercept and\nexecute code to modify the default behavior at these points to meet\nyour needs. Ember provides several hooks for you to utilize for various\npurposes (e.g. model, setupController, etc). In the example below\nroute:application Route, which is an Ember.Route object, implements\nthe setupController hook.\n\nHere's a simple example that uses a route, controller, and template:\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Route.extend({\n  setupController: function(controller) {\n    // `controller` is the instance of ApplicationController\n    controller.set('title', \"Hello world!\");\n  }\n});\n\n\n\n  \n    \n      app/controllers/application.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Controller.extend({\n  appName: 'My First Example'\n});\n\n\n\n  \n    \n      app/templates/application.hbs\n    \n  \n\n  1\n2\n\n  \u003ch1\u003e{{appName}}\u003c/h1\u003e\n\u003ch2\u003e{{title}}\u003c/h2\u003e\n\n\n\nIn Ember.js applications, you will always provide your objects\nas classes, and the framework is responsible for instantiating\nthem and providing them to your templates at runtime through the resolver.\nSimple Routes\nEach of your routes will have a controller, and a template with the\nsame name as the route.\n\nLet's start with a simple router:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Router.extend().map(function(){\n  this.route('favorites');\n});\n\n\n\nIf your user navigates to /favorites, Ember.js will look for these\nclasses in your project:\n\n\napp/routes/favorites.js\napp/controllers/favorites.js\napp/templates/favorites.hbs\n\n\nEmber.js will render the favorites template into the {{outlet}}\nin the application template. It will set an instance of the\ncontroller:favorites as the controller for the template.\n\nIf your app provides a route:favorites, the framework will\ninvoke it before rendering the template. Yes, this is a bit\nrepetitive.\n\nFor a route like route:favorites, you will probably implement\nthe model hook to specify what model your controller will present\nto the template.\n\nHere's an example:\n\n  \n    \n      app/routes/favorites.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  model: function() {\n    // the model is an Array of all of the posts\n    // fetched from this url\n    return $.ajax('/a/service/url/where/posts/live');\n  }\n});\n\n\n\nIn this example, we didn't provide a controller:favorites. Because\nthe model is an Array, Ember.js will automatically supply an instance\nof Ember.ArrayController, which will present the backing Array as\nits model.\n\nYou can treat the Ember.ArrayController as if it was the model itself.\nThis has two major benefits:\n\n\nYou can replace the controller's model at any time without having\nto directly notify the view of the change.\nThe controller can provide additional computed properties or\nview-specific state that do not belong in the model layer. This\nallows a clean separation of concerns between the view, the\ncontroller and the model.\n\n\nThe template can iterate over the elements of the controller:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n{{#each controller as |item|}}\n  \u003cli\u003e{{item.title}}\u003c/li\u003e\n{{/each}}\n\u003c/ul\u003e\n\n\nDynamic Segments\nIf a route uses a dynamic segment (a URL that includes a parameter), the route's model will be based\non the value of that segment provided by the user.\n\nConsider this router definition:\n\n  1\n2\n3\n\n  export default Ember.Router.extend().map(function(){\n  this.route('post', { path: '/posts/:post_id' });\n});\n\n\n\nIn this case, the route's name is post, so Ember.js will look for\nthese objects:\n\n\napp/routes/post.js\napp/controllers/post.js\napp/templates/post.hbs\n\n\nYour route handler's model hook converts the dynamic :post_id\nparameter into a model. The serialize hook converts a model object\nback into the URL parameters for this route (for example, when\ngenerating a link for a model object).\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Route.extend({\n  model: function(params) {\n    return $.ajax('/my-service/posts/' + params.post_id);\n  },\n\n  serialize: function(post) {\n    return { post_id: Ember.get(post, 'id') };\n  }\n});\n\n\n\nBecause this pattern is so common, it is the default for route\nhandlers.\n\n\nIf your dynamic segment ends in _id, the default model\nhook will convert the first part into a model class on the\napplication's namespace (post looks for app/models/post.js). It will\nthen call find on that class with the value of the dynamic\nsegment.\nThe default behaviour of the serialize hook is to replace\nthe route's dynamic segment with the value of the model\nobject's id property.\n\nRoute, Controller and Template Defaults\nIf you don't specify a route handler for the post route\n(app/routes/post.js), Ember.js  will still render the app/templates/post.hbs\ntemplate with the app's instance of app/controllers/post.js.\n\nIf you don't specify the controller (app/controllers/post.js),\nEmber will automatically make one for you based on the return value\nof the route's model hook. If the model is an Array, you get an\nArrayController. Otherwise, you get an ObjectController. As of 1.11,\nObjectControllers are deprecated and if you try to use its proxy feature you\nwill get a warning. Please, take a look at the deprecations guide for more\ndetailed information.\n\nIf you don't specify a post template, Ember.js won't render\nanything!\nNesting\nYou can nest routes:\n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Router.extend().map(function(){\n  this.route('posts', function() {    // the `posts` route\n    this.route('favorites');          // the `posts.favorites` route\n    this.route('post');               // the `posts.post` route\n  });\n});\n\n\n\nHere are the naming conventions for each of the routes defined in\nthis router:\n\n\n  \n  \n    Route Name\n    Controller\n    Route\n    Template\n  \n  \n  \n    posts\n    app/controllers/posts.js\n    app/routes/posts.js\n    app/templates/posts.hbs\n  \n  \n    posts.favorites\n    app/controllers/posts/favorites.js\n    app/routes/posts/favorites.js\n    app/templates/posts/favorites.hbs\n  \n  \n    posts.post\n    app/controllers/posts/post.js\n    app/routes/posts/post.js\n    app/templates/posts/post.hbs\n  \n\nThe Index Route\nAt every level of nesting (including the top level), Ember.js\nautomatically provides a route for the / path named index.\n\nFor example, if you write a simple router like this:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Router.extend().map(function(){\n  this.route('favorites');\n});\n\n\n\nIt is the equivalent of:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Router.extend().map(function(){\n  this.route('index', { path: '/' });\n  this.route('favorites');\n});\n\n\n\nIf the user visits /, Ember.js will look for these objects:\n\n\napp/routes/index.js\napp/controllers/index.js\napp/templates/index.hbs\n\n\nThe index template will be rendered into the {{outlet}} in the\napplication template. If the user navigates to /favorites,\nEmber.js will replace the index template with the favorites\ntemplate.\n\nA nested router like this:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Router.extend().map(function(){\n  this.route('posts', function() {\n    this.route('favorites');\n  });\n});\n\n\n\nIs the equivalent of:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Router.extend().map(function(){\n  this.route('index', { path: '/' });\n  this.route('posts', function() {\n    this.route('index', { path: '/' });\n    this.route('favorites');\n  });\n});\n\n\n\nIf the user navigates to /posts, the current route will be\nposts.index. Ember.js will look for objects named:\n\n\napp/routes/posts/index.js\napp/controllers/posts/index.js\napp/templates/posts/index.hbs\n\n\nFirst, the posts template will be rendered into the {{outlet}}\nin the application template. Then, the posts/index template\nwill be rendered into the {{outlet}} in the posts template.\n\nIf the user then navigates to /posts/favorites, Ember.js will\nreplace the {{outlet}} in the posts template with the\nposts/favorites template.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"62986c9e6cbee2077f1bd848372a19dc","fields":[{"name":"title","value":"Disabling Prototype Extensions","type":"string"},{"name":"url","value":"/configuring-ember/disabling-prototype-extensions/","type":"enum"},{"name":"body","value":"By default, Ember.js will extend the prototypes of native JavaScript\nobjects in the following ways:\n\n\nArray is extended to implement the Ember.Enumerable,\nEmber.MutableEnumerable, Ember.MutableArray and Ember.Array\ninterfaces. This polyfills ECMAScript 5 array methods in browsers that\ndo not implement them, adds convenience methods and properties to\nbuilt-in arrays, and makes array mutations observable.\nString is extended to add convenience methods, such as\ncamelize() and fmt().\nFunction is extended with methods to annotate functions as\ncomputed properties, via the property() method, and as observers,\nvia the observes() or observesBefore() methods.\n\n\nThis is the extent to which Ember.js enhances native prototypes. We have\ncarefully weighed the tradeoffs involved with changing these prototypes,\nand recommend that most Ember.js developers use them. These extensions\nsignificantly reduce the amount of boilerplate code that must be typed.\n\nHowever, we understand that there are cases where your Ember.js\napplication may be embedded in an environment beyond your control. The\nmost common scenarios are when authoring third-party JavaScript that is\nembedded directly in other pages, or when transitioning an application\npiecemeal to a more modern Ember.js architecture.\n\nIn those cases, where you can't or don't want to modify native\nprototypes, Ember.js allows you to completely disable the extensions\ndescribed above.\n\nTo do so, simply set the EmberENV.EXTEND_PROTOTYPES flag to false:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  ENV = {\n  EmberENV: {\n    EXTEND_PROTOTYPES: false\n  }\n}\n\n\n\nOr you can choose class which you want to disable prototype extension\nby added a property to your application's configuration:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  ENV = {\n  EmberENV: {\n    EXTEND_PROTOTYPES: {\n      String: false,\n      Array: true\n    }\n  }\n}\n\n\nLife Without Prototype Extension\nIn order for your application to behave correctly, you will need to\nmanually extend or create the objects that the native objects were\ncreating before.\nArrays\nNative arrays will no longer implement the functionality needed to\nobserve them. If you disable prototype extension and attempt to use\nnative arrays with things like a template's {{#each}} helper, Ember.js\nwill have no way to detect changes to the array and the template will\nnot update as the underlying array changes.\n\nAdditionally, if you try to set the model of an\nEmber.ArrayController to a plain native array, it will raise an\nexception since it no longer implements the Ember.Array interface.\n\nYou can manually coerce a native array into an array that implements the\nrequired interfaces using the convenience method Ember.A:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  var islands = ['Oahu', 'Kauai'];\nislands.contains('Oahu');\n//=\u003e TypeError: Object Oahu,Kauai has no method 'contains'\n\n// Convert `islands` to an array that implements the\n// Ember enumerable and array interfaces\nEmber.A(islands);\n\nislands.contains('Oahu');\n//=\u003e true\n\n\nStrings\nStrings will no longer have the convenience methods described in the\nEmber.String API reference.. Instead,\nyou can use the similarly-named methods of the Ember.String object and\npass the string to use as the first parameter:\n\n  1\n2\n3\n4\n5\n\n  \"my_cool_class\".camelize();\n//=\u003e TypeError: Object my_cool_class has no method 'camelize'\n\nEmber.String.camelize(\"my_cool_class\");\n//=\u003e \"myCoolClass\"\n\n\nFunctions\nTo annotate computed properties, use the Ember.computed() method to\nwrap the function:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  // This won't work:\nfullName: function() {\n  return this.get('firstName') + ' ' + this.get('lastName');\n}.property('firstName', 'lastName')\n\n\n// Instead, do this:\nfullName: Ember.computed('firstName', 'lastName', function() {\n  return this.get('firstName') + ' ' + this.get('lastName');\n})\n\n\n\nObservers are annotated using Ember.observer():\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  // This won't work:\nfullNameDidChange: function() {\n  console.log(\"Full name changed\");\n}.observes('fullName')\n\n\n// Instead, do this:\nfullNameDidChange: Ember.observer('fullName', function() {\n  console.log(\"Full name changed\");\n})\n\n\n\nEvented functions are annotated using Ember.on():\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  // This won't work:\ndoStuffWhenInserted: function() {\n  /* awesome sauce */\n}.on('didInsertElement');\n\n// Instead, do this:\ndoStuffWhenInserted: Ember.on('didInsertElement', function() {\n  /* awesome sauce */\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"479923146262192b72f2b6cd4e92d83b","fields":[{"name":"title","value":"Embedding Applications","type":"string"},{"name":"url","value":"/configuring-ember/embedding-applications/","type":"enum"},{"name":"body","value":"In most cases, your application's entire UI will be created by templates\nthat are managed by the router.\n\nBut what if you have an Ember.js app that you need to embed into an\nexisting page, or run alongside other JavaScript frameworks?\nChanging the Root Element\nBy default, your application will render the application template\nand attach it to the document's body element.\n\nYou can tell the application to append the application template to a\ndifferent element by specifying its rootElement property:\n\n  \n    \n      app/app.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Application.extend({\n  rootElement: '#app'\n});\n\n\n\nThis property can be specified as either an element or a\njQuery-compatible selector\nstring.\nDisabling URL Management\nYou can prevent Ember from making changes to the URL by changing the\nrouter's location to\nnone:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n\n  var ENV = {\n  locationType: 'none'\n};\nexport default ENV;\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"32ec1a30c836c88e234758571f01a21e","fields":[{"name":"title","value":"Feature Flags","type":"string"},{"name":"url","value":"/configuring-ember/feature-flags/","type":"enum"},{"name":"body","value":"New features are added to Ember.js within conditional statements.\n\nCode behind these flags can be conditionally enabled\n(or completely removed) based on your project's configuration. This\nallows newly developed features to be selectively released when the\nEmber.js community considers them ready for production use.\nFeature Life-Cycle\nA newly-flagged feature is only available in canary builds and can be enabled\nat runtime through your project's configuration file.\n\nAt the start of a beta cycle the Ember core team evaluates each new feature.\nFeatures deemed stable are made available in the next beta and enabled by default.\n\nBeta features that receive negative feedback from the community are disabled in the next beta point\nrelease, and are not included in the next stable release. They may still be included\nin the next beta cycle if the issues/concerns are resolved.\n\nOnce the beta cycle has completed the next stable release will include any features that\nwere enabled during the beta cycle. At this point the feature flags will be removed from\nthe canary and future beta branches and the feature becomes of the framework.\nFlagging Details\nThe flag status in the generated build is controlled by the features.json\nfile in the root of the Ember.js project. This file lists all new features and their current status.\n\nA feature can have one of a three flags:\n\n\ntrue - The feature is present and enabled: the code behind the flag is always enabled in\nthe generated build.\nnull - The feature is present but disabled in the build output. It must be enabled at\nruntime.\nfalse - The feature is entirely disabled: the code behind the flag is not present in\nthe generated build.\n\n\nThe process of removing the feature flags from the resulting build output is\nhandled by defeatureify.\nFeature Listing (FEATURES.md)\nWhen a developer adds a new feature canary channel (i.e. the master branch on github), they\nalso add an entry to FEATURES.md\nexplaining what the feature does and linking to their originating pull request.\nThis list is kept current, and reflects what is available in each channel\n(stable, beta, and master).\nEnabling At Runtime\nWhen using the Ember.js canary or beta builds you can enable any \"present but disabled\"\nby setting its flag value to true before your application boots:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var ENV = {\n  EmberENV: {\n    FEATURES: {\n      'link-to': true\n    }\n  }\n};\n\nexport default ENV;\n\n\n\nFor the truly ambitious developer, setting ENV.EmberENV.ENABLE_ALL_FEATURES to true will enable all\nexperimental features.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"3cddcc7a01c23b72f74ea3eceaaada93","fields":[{"name":"title","value":"Adding New Features","type":"string"},{"name":"url","value":"/contributing/adding-new-features/","type":"enum"},{"name":"body","value":"In general, new feature development should be done on master.\n\nBugfixes should not introduce new APIs or break existing APIs, and do\nnot need feature flags.\n\nFeatures can introduce new APIs, and need feature flags. They should not\nbe applied to the release or beta branches, since SemVer requires\nbumping the minor version to introduce new features.\n\nSecurity fixes should not introduce new APIs, but may, if strictly\nnecessary, break existing APIs. Such breakages should be as limited as\npossible.\nBug FixesUrgent Bug Fixes\nUrgent bugfixes are bugfixes that need to be applied to the existing\nrelease branch. If possible, they should be made on master and prefixed\nwith [BUGFIX release].\nBeta Bug Fixes\nBeta bugfixes are bugfixes that need to be applied to the beta branch.\nIf possible, they should be made on master and tagged with [BUGFIX\nbeta].\nSecurity Fixes\nSecurity fixes need to be applied to the beta branch, the current\nrelease branch, and the previous tag. If possible, they should be made\non master and tagged with [SECURITY].\nFeatures\nFeatures must always be wrapped in a feature flag. Tests for the feature\nmust also be wrapped in a feature flag.\n\nBecause the build-tools will process feature-flags, flags must use\nprecisely this format. We are choosing conditionals rather than a block\nform because functions change the surrounding scope and may introduce\nproblems with early return.\n\n  1\n2\n3\n\n  if (Ember.FEATURES.isEnabled(\"feature\")) {\n  // implementation\n}\n\n\n\nTests will always run with all features on, so make sure that any tests\nfor the feature are passing against the current state of the feature.\nCommits\nCommits related to a specific feature should include  a prefix like\n[FEATURE htmlbars]. This will allow us to quickly identify all commits\nfor a specific feature in the future. Features will never be applied to\nbeta or release branches. Once a beta or release branch has been cut, it\ncontains all of the new features it will ever have.\n\nIf a feature has made it into beta or release, and you make a commit to\nmaster that fixes a bug in the feature, treat it like a bugfix as\ndescribed above.\nFeature Naming Conventions\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n\n  Ember.FEATURES[\"\u003cpackageName\u003e-\u003cfeature\u003e\"] // if package specific\nEmber.FEATURES[\"container-factory-injections\"]\nEmber.FEATURES[\"htmlbars\"]\n\n\nBuilds\nThe Canary build, which is based off master, will include all features,\nguarded by the conditionals in the original source. This means that\nusers of the canary build can enable whatever features they want by\nenabling them before creating their Ember.Application.\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  module.exports = function(environment) {\n  var ENV = {\n    EmberENV: {\n      FEATURES: {\n        htmlbars: true\n      }\n    },\n  }\n}\n\n\nfeatures.json\nThe root of the repository will contain a features.json file, which will\ncontain a list of features that should be enabled for beta or release\nbuilds.\n\nThis file is populated when branching, and may not gain additional\nfeatures after the original branch. It may remove features.\n\n  1\n2\n3\n\n  {\n  \"htmlbars\": true\n}\n\n\n\nThe build process will remove any features not included in the list, and\nremove the conditionals for features in the list.\nTravis Testing\nFor a new PR:\n\n\nTravis will test against master with all feature flags on.\nIf a commit is tagged with [BUGFIX beta], Travis will also\ncherry-pick the commit into beta, and run the tests on that\nbranch. If the commit doesn't apply cleanly or the tests fail, the\ntests will fail.\nIf a commit is tagged with [BUGFIX release], Travis will also cherry-pick\nthe commit into release, and run the test on that branch. If the commit\ndoesn't apply cleanly or the tests fail, the tests will fail.\n\n\nFor a new commit to master:\n\n\nTravis will run the tests as described above.\nIf the build passes, Travis will cherry-pick the commits into the\nappropriate branches.\n\n\nThe idea is that new commits should be submitted as PRs to ensure they\napply cleanly, and once the merge button is pressed, Travis will apply\nthem to the right branches.\nGo/No-Go Process\nEvery six weeks, the core team goes through the following process.\nBeta Branch\nAll remaining features on the beta branch are vetted for readiness. If\nany feature isn't ready, it is removed from features.json.\n\nOnce this is done, the beta branch is tagged and merged into release.\nMaster Branch\nAll features on the master branch are vetted for readiness. In order for\na feature to be considered \"ready\" at this stage, it must be ready as-is\nwith no blockers. Features are a no-go even if they are close and\nadditional work on the beta branch would make it ready.\n\nBecause this process happens every six weeks, there will be another\nopportunity for a feature to make it soon enough.\n\nOnce this is done, the master branch is merged into beta. A\nfeatures.json file is added with the features that are ready.\nBeta Releases\nEvery week, we repeat the Go/No-Go process for the features that remain\non the beta branch. Any feature that has become unready is removed from\nthe features.json.\n\nOnce this is done, a Beta release is tagged and pushed.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"26d81f9d1949f3951aa7d9505e7280dd","fields":[{"name":"title","value":"Repositories","type":"string"},{"name":"url","value":"/contributing/repositories/","type":"enum"},{"name":"body","value":"Ember is made up of several libraries. If you wish to add a feature or fix a bug please file a pull request against the appropriate repository. Be sure to check the libraries listed below before making changes in the Ember.js repository.\nMain Repositories\nEmber.js - The main repository for Ember.\n\n\nhttps://github.com/emberjs/ember.js\n\n\nEmber Data - A data persistence library for Ember.js.\n\n\nhttps://github.com/emberjs/data\n\n\nEmber Website - Source for http://emberjs.com\n\n\nhttps://github.com/emberjs/website\n\n\nEmber Guides - Source for http://guides.emberjs.com which you are currently reading.\n\n\nhttps://github.com/emberjs/guides\n\nLibraries Used By Ember\nThese libraries are part of the Ember.js source, but development of them takes place in a separate repository.\npackages/ember-metal/lib/vendor/backburner.js\n\nbackburner.js - Implements the Ember run loop.\nhttps://github.com/ebryn/backburner.js\n\npackages/ember-routing/lib/vendor/route-recognizer.js\n\nroute-recognizer.js - A lightweight JavaScript library that matches paths against registered routes.\nhttps://github.com/tildeio/route-recognizer\n\npackages/ember-routing/lib/vendor/router.js\n\nrouter.js - A lightweight JavaScript library that builds on route-recognizer and rsvp to provide an API for handling routes.\nhttps://github.com/tildeio/router.js\n\npackages/metamorph\n\nMetamorph.js - Used by Ember for databinding handlebars templates\nhttps://github.com/tomhuda/metamorph.js\n\npackages/rsvp\n\nRSVP.js - Implementation of the of Promises/A+ spec used by Ember.\nhttps://github.com/tildeio/rsvp.js\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"c34d88bfea40594c8c5d1478666d47a7","fields":[{"name":"title","value":"Managing Dependencies Between Controllers","type":"string"},{"name":"url","value":"/controllers/dependencies-between-controllers/","type":"enum"},{"name":"body","value":"Sometimes, especially when nesting resources, we find ourselves needing\nto have some kind of connection between two controllers. Let's take this\nrouter as an example:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var Router = Ember.Router.extend({});\n\nRouter.map(function() {\n  this.route(\"post\", { path: \"/posts/:post_id\" }, function() {\n    this.route(\"comments\", { path: \"/comments\" });\n  });\n});\n\nexport default Router;\n\n\n\nIf we visit a /posts/1/comments URL, our Post model will get\nloaded into a PostController's model, which means it is not directly\naccessible in the CommentsController. We might however want to display\nsome information about it in the comments template.\n\nTo be able to do this we define our CommentsController to need the PostController\nwhich has our desired Post model.\n\n  \n    \n      app/controllers/comments.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.ArrayController.extend({\n  needs: \"post\"\n});\n\n\n\nThis tells Ember that our CommentsController should be able to access\nits parent PostController, which can be done via controllers.post\n(either in the template or in the controller itself). In order to get the\nactual Post model, we need to refer to controllers.post.model:\n\n  \n    \n      app/controllers/comments.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.ArrayController.extend({\n  needs: \"post\",\n  post: Ember.computed.alias(\"controllers.post.model\")\n});\n\n\n\n  \n    \n      app/templates/comments.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003ch1\u003eComments for {{post.title}}\u003c/h1\u003e\n\n\u003cul\u003e\n  {{#each comments as |comment|}}\n    \u003cli\u003e{{comment.text}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nIf you want to connect multiple controllers together, you can specify an\narray of controller names:\n\n  \n    \n      app/controllers/overview.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Controller.extend({\n  needs: ['post', 'comments']\n});\n\n\n\nFor more information about dependency injection and needs in Ember.js,\nsee the dependency injection guide.\nFor more information about aliases, see the API docs for\naliased properties.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f72002399f11df302a9dac49684ae8dc","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/controllers/","type":"enum"},{"name":"body","value":"Controllers\nIn Ember.js, controllers allow you to decorate your models with\ndisplay logic. In general, your models will have properties that\nare saved to the server, while controllers will have properties\nthat your app does not need to save to the server.\n\nFor example, if you were building a blog, you would have a\nBlogPost model that you would present in a blog_post template.\n\nYour BlogPost model would have properties like:\n\n\ntitle\nintro\nbody\nauthor\n\n\nYour template would bind to these properties in the blog-post \ntemplate:\n\n  \n    \n      app/templates/blog-post.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  \u003ch1\u003e{{model.title}}\u003c/h1\u003e\n\u003ch2\u003eby {{model.author}}\u003c/h2\u003e\n\n\u003cdiv class='intro'\u003e\n  {{model.intro}}\n\u003c/div\u003e\n\u003chr\u003e\n\u003cdiv class='body'\u003e\n  {{model.body}}\n\u003c/div\u003e\n\n\n\nIn this simple example, we don't have any display-specific properties\nor actions just yet. For now, our controller's model property just acts as a\npass-through (or \"proxy\") for the model properties. (Remember that\na controller gets the model it represents from its route handler.)\n\nLet's say we wanted to add a feature that would allow the user to\ntoggle the display of the body section. To implement this, we would\nfirst modify our template to show the body only if the value of a\nnew isExpanded property is true.\n\n  \n    \n      app/templates/blog-post.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  \u003ch1\u003e{{model.title}}\u003c/h1\u003e\n\u003ch2\u003eby {{model.author}}\u003c/h2\u003e\n\n\u003cdiv class='intro'\u003e\n  {{model.intro}}\n\u003c/div\u003e\n\u003chr\u003e\n\n{{#if isExpanded}}\n  \u003cbutton {{action 'toggleProperty' 'isExpanded'}}\u003eHide Body\u003c/button\u003e\n  \u003cdiv class='body'\u003e\n    {{model.body}}\n  \u003c/div\u003e\n{{else}}\n  \u003cbutton {{action 'toggleProperty' 'isExpanded'}}\u003eShow Body\u003c/button\u003e\n{{/if}}\n\n\n\nYou might think you should put this property on the model, but\nwhether the  body is expanded or not is strictly a display concern.\n\nPutting this property on the controller cleanly separates logic\nrelated to your data model from logic related to what you display\non the screen. This makes it easy to unit-test your model without\nhaving to worry about logic related to your display creeping into\nyour test setup.\nA Note on Coupling\nIn Ember.js, templates get their properties from controllers, which\ndecorate a model.\n\nThis means that templates know about controllers and controllers\nknow about models, but the reverse is not true. A model knows\nnothing about which (if any) controllers are decorating it, and\ncontroller does not know which views are presenting its properties.\n\n\n\n\n\nThis also means that as far as a template is concerned, all of its\nproperties come from its controller, and it doesn't need to know\nabout the model directly.\n\nIn practice, Ember.js will create a template's controller once for\nthe entire application, but the controller's model may change\nthroughout the lifetime of the application without requiring that\nthe view knows anything about those mechanics.\n\nFor example, if the user navigates from /posts/1 to /posts/2,\nthe PostController will change its model from Post.find(1) to\nPost.find(2). The template will update its representations of any\nproperties on the model, as well as any computed properties on the\ncontroller that depend on the model.\n\nThis makes it easy to test a template in isolation by rendering it\nwith a controller object that contains the properties the template\nexpects. From the template's perspective, a controller is simply\nan object that provides its data.\nRepresenting Models\nTemplates are always connected to controllers, not models. This\nmakes it easy to separate display-specific properties from model\nspecific properties, and to swap out the controller's model as the\nuser navigates around the page.\n\nFor convenience, Ember.js provides an Ember.ArrayController that proxies\nproperties from an Array. If your controller is an ArrayController, you can\niterate over the model using {{#each model as |item|}}. This\nkeeps the template from having to know about how the controller is implemented\nand makes isolation testing and refactoring easier.\nStoring Application Properties\nNot all properties in your application need to be saved to the\nserver. Any time you need to store information only for the lifetime\nof this application run, you should store it on a controller.\n\nFor example, imagine your application has a search field that\nis always present. You could store a search property on your\nApplicationController, and bind the search field in the \napplication template to that property, like this:\n\n  \n    \n      app/templates/application.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003cheader\u003e\n  {{input type=\"text\" value=search action=\"query\"}}\n\u003c/header\u003e\n\n{{outlet}}\n\n\n\n  \n    \n      app/controllers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Controller.extend({\n  // the initial value of the `search` property\n  search: '',\n\n  actions: {\n    query: function() {\n      // the current value of the text field\n      var query = this.get('search');\n      this.transitionToRoute('search', { query: query });\n    }\n  }\n});\n\n\n\nThe application template stores its properties and sends its\nactions to the ApplicationController. In this case, when the user\nhits enter, the application will transition to the search route,\npassing the query as a parameter.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"eccf6ac44cf97c8ce01bedff4e10d4c1","fields":[{"name":"title","value":"Representing Multiple Models with ArrayController","type":"string"},{"name":"url","value":"/controllers/representing-multiple-models-with-arraycontroller/","type":"enum"},{"name":"body","value":"You can use Ember.ArrayController to represent an array of models. To tell an\nArrayController which models to represent, set its model property\nin your route's setupController method.\n\nYou can treat an ArrayController just like its underlying array. For\nexample, imagine we want to display the current playlist. In our route,\nwe setup our SongsController to represent the songs in the playlist:\n\n  \n    \n      app/routes/songs.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  setupController: function(controller, playlist) {\n    controller.set('model', playlist.get('songs'));\n  }\n});\n\n\n\nIn the songs template, we can use the {{#each}} helper to display\neach song:\n\n  \n    \n      app/templates/songs.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003ch1\u003ePlaylist\u003c/h1\u003e\n\n\u003cul\u003e\n  {{#each model as |song|}}\n    \u003cli\u003e{{song.name}} by {{song.artist}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nYou can use the ArrayController to collect aggregate information about\nthe models it represents. For example, imagine we want to display the\nnumber of songs that are over 30 seconds long. We can add a new computed\nproperty called longSongCount to the controller:\n\n  \n    \n      app/controllers/songs.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.ArrayController.extend({\n  longSongCount: function() {\n    var longSongs = this.filter(function(song) {\n      return song.get('duration') \u003e 30;\n    });\n    return longSongs.get('length');\n  }.property('@each.duration')\n});\n\n\n\nNow we can use this property in our template:\n\n  \n    \n      app/templates/songs.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003cul\u003e\n  {{#each model as |song|}}\n    \u003cli\u003e{{song.name}} by {{song.artist}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n{{longSongCount}} songs over 30 seconds.\n\n\nSorting\nThe Ember.ArrayController uses the Ember.SortableMixin to allow sorting\nof content. There are two properties that can be set in order to set up sorting:\n\n  \n    \n      app/controllers/songs.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.ArrayController.extend({\n  sortProperties: ['name', 'artist'],\n  sortAscending: true // false for descending\n});\n\n\nItem Controller\nIt is often useful to specify a controller to decorate individual items in\nthe ArrayController while iterating over them. This can be done by\ncreating a Controller:\n\n  \n    \n      app/controllers/song.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Controller.extend({\n\n  name: Ember.computed.alias('model.name'),\n  artist: Ember.computed.alias('model.artist'),\n\n  fullName: function() {\n    return this.get('name') + ' by ' + this.get('artist');\n  }.property('name', 'artist')\n});\n\n\n\nThen, the ArrayController itemController property must be set to\nthe decorating controller.\n\n  \n    \n      app/controllers/songs.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.ArrayController.extend({\n  itemController: 'song'\n});\n\n\n\n  \n    \n      app/templates/songs.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#each controller as |item|}}\n  \u003cli\u003e{{item.fullName}}\u003c/li\u003e\n{{/each}}\n\n\n\nor you could setup the itemController directly in the template:\n\n  \n    \n      app/controllers/songs.js\n    \n  \n\n  1\n2\n\n  export default Ember.ArrayController.extend({\n});\n\n\n\n  \n    \n      app/templates/songs.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#each controller itemController=\"song\" as |item|}}\n  \u003cli\u003e{{item.fullName}}\u003c/li\u003e\n{{/each}}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"5840c472a2618d3d0cd89bc93f69a264","fields":[{"name":"title","value":"Deciding If A Recipe is a Good Fit","type":"string"},{"name":"url","value":"/cookbook/contributing/deciding_if_a_recipe_is_a_good_fit/","type":"enum"},{"name":"body","value":"Problem\nYou have an idea for a recipe, but aren't sure it is a good fit for the Cookbook.\nSolution\nRead existing cookbook solutions and compare them to yours. You may also want to borrow or buy a cookbook-style\nbook for another technology to better understand the format.\n\nCookbook recipes are usually quick answers to focused questions. Your recipe should be narrowly tailored to\nsolve a single problem.\nDiscussion\nThe Cookbook format best serves beginners who have a basic knowledge of Ember.js and have ideally completed a\nsmall application of their own. Recipes in the Cookbook should teach intermediate and advanced topics, or present\nskills an Ember.js developer should know. Popular topics on StackOverflow are great examples of what a Cookbook\nrecipe should cover.\n\nA good recipe solves a single problem. Topics like \"Syncing data with one-way bindings\" or \"Integrating Ember with\nmoment.js\" make great recipes. Broader topics like \"Building an Ember application with Node.js\" or \"Creating a GridView\nwith sortable fields and search\" are not. If your topic is too big, consider breaking it into multiple recipes (e.g.\n\"Organizing an Ember application,\" \"Responding to user events,\" \"Connecting to remote data\").\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8f9eab53d10285d9b1f3b28238a34c45","fields":[{"name":"title","value":"Contributing","type":"string"},{"name":"url","value":"/cookbook/contributing/","type":"enum"},{"name":"body","value":"The Ember Cookbook provides answers and solutions to common Ember questions and problems. Anyone is welcome to\ncontribute.\n\nIf you are new to Ember, we recommend that you spend some time reading the guides and tutorials before coming\nto the Cookbook. Cookbook recipes assume that you have a basic understanding of Ember's concepts.\n\nIf you have experience with Ember and would like to contribute to the Cookbook, the discussion section of each\nrecipe is a great place to start.\nRecipes\n\nUnderstanding the Cookbook Format\nParticipating If You Know Ember\nParticipating If You Don't Know Ember\nDeciding If A Recipe is a Good Fit\nSuggesting A Recipe\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"38a21f770ff7d34b31b3d286fd42a7fa","fields":[{"name":"title","value":"Participating If You Don't Know Ember","type":"string"},{"name":"url","value":"/cookbook/contributing/participating_if_you_dont_know_ember/","type":"enum"},{"name":"body","value":"Problem\nYou are new to Ember, but want to help write the Cookbook.\nSolution\nSuggest and/or submit pull requests with a problem statement (see Suggesting A Recipe). You do not need to worry about providing a solution or discussion. Someone more experienced with Ember will be able to take your problem and provide a solution and discussion.\nDiscussion\nThe first version of the Ember Cookbook will be completed in a few phases. First, we will be accepting\nrecipe suggestions. You can suggest a recipe by forking this repository and submitting a pull request\n(see Suggesting a Recipe). Once we have written recipes, we'll be asking for help to proofread and test\nthem.\n\nSee \"Watch a project\" on Github for information on watching projects.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"772fabfc19fd4ef231bdea28f78e6978","fields":[{"name":"title","value":"Participating If You Know Ember","type":"string"},{"name":"url","value":"/cookbook/contributing/participating_if_you_know_ember/","type":"enum"},{"name":"body","value":"Problem\nYou are familiar with Ember and want to help write the Cookbook.\nSolution\nGet started by forking the repository. Send a pull request with an\nupdate to an existing recipe or a new recipe.\nDiscussion\nBased on your experience and knowledge of Ember, we recommend submitting pull requests with the following:\n\n\n  Beginner\n  Problem statements are a good place for anyone to start helping. Feel free to submit pull requests that are just problem statements if there is a recipe you'd like to see. If you're new to Ember and/or haven't ever written an Ember app, this is a perfect place to start contributing.\n  Intermediate\n  Problem \u0026 Solution statements are a great way to participate if you're already writing Ember applications and have a known good solution to a particular problem statement. Feel free to leave _Discussion_ missing for someone else to fill out later.\n  Advanced\n  Problem, Solution \u0026 Discussion is the right way to help if you have a deeper understanding of the topic and can write cogently about why the solution is a good idea, explain pitfalls of other solutions, etc.\n\n\nYou will be able to suggest possible recipes by forking this project and submitting a pull request with a new recipe (see Suggesting a Recipe).\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f5c7f82ba913be21095ff6ce282194f7","fields":[{"name":"title","value":"Suggesting A Recipe","type":"string"},{"name":"url","value":"/cookbook/contributing/suggesting_a_recipe/","type":"enum"},{"name":"body","value":"Problem\nYou'd like to submit a recipe to the Ember Cookbook.\nSolution\nFork the repository and create a feature branch named after your\nrecipe. New recipes should have four sections: a title, a problem statement, a solution statement, and\nan empty discussion section.\nDiscussion\nA feature branch is a branch in a local git\nrepository. Its name should be the camel-cased or underscored name of your recipe. For example, the branch\nname for this recipe â \"Suggesting a Recipe\" â would be SuggestingARecipe or suggesting_a_recipe.\n\nThe title, problem, and solution of your recipe should match the Cookbook's style (see\nUnderstanding the Cookbook Format). While your recipe should include a discussion section, you should leave\nit blank. These sections will be created in a later phase of the Cookbook project.\n\nThe filename of your suggested recipe should be the lowercase, underscored version of your recipe's name. The\nfilename name for this recipe \u0026nash; \"Suggesting a Recipe\" â would be suggesting_a_recipe.mdown.\n\nWhen you are ready to submit your recipe, push your local branch to the remote branch on your Github fork and\nsubmit a pull request. Before submitting a pull request, make sure someone hasn't already submitted a similar\nrecipe and that your recipe is a good fit for the Cookbook (see Deciding If A Recipe Is A Good Fit).\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f52fc00c428d9353d4c46c79a238b67e","fields":[{"name":"title","value":"Understanding the Cookbook Format","type":"string"},{"name":"url","value":"/cookbook/contributing/understanding_the_cookbook_format/","type":"enum"},{"name":"body","value":"Problem\nYou want to contribute, but aren't familiar with the Cookbook format or don't know\nhow your contribution should be formatted.\nSolution\nCookbook-style guides contain recipes that guide a beginning programmer to a deeper knowledge of the subject\nby answering specific, \"how-to\" style questions. Cookbook recipes address more topics than\nAPI documentation for a class, but are smaller in\nscope than a topic-based guide.\n\nAll recipes follow the same format:\n\n\n  Title\n  Broadly explains the topic of the recipe\n  Problem\n  Outlines the recipe's goals\n  Solution\n  Summarizes the correct approach to addressing the problem\n  Discussion\n  Explores the solution in detail\n\n\nA Cookbook does not need to be read in any particular order, and each recipe should contain all the information\nnecessary for a beginner to address the problem statement. Referring to other recipes that are considered\nprerequisite knowledge is encouraged.\nDiscussion\nTake a look at an O'Reilly Cookbook or the\nCoffeescript Cookbook. Both of these are great examples of the Cookbook\nformat.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4884e4d6d82b771a64e79aa0c5e5330d","fields":[{"name":"title","value":"Binding Properties of an Object to Its Own Properties","type":"string"},{"name":"url","value":"/cookbook/event_handling_and_data_binding/binding_properties_of_an_object_to_its_own_properties/","type":"enum"},{"name":"body","value":"Problem\nYou want to base the value of one property on the value of another property.\nSolution\nUse one of the computed property macros like Ember.computed.alias or Ember.computed.gte\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Object.extend({\n    firstName : null,\n    lastName : null,\n    surname : Ember.computed.alias(\"lastName\"),\n    eligibleForRetirement: Ember.computed.gte(\"age\", 65)\n});\n\n\nDiscussion\nEmber.js includes a number of macros that will help create properties whose values are based\non the values of other properties, correctly connecting them with bindings so they remain\nupdated when values change. These all are stored on the Ember.computed object\nand documented in the API documentation\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"330d340741cab3bb5f7a9565ae50551f","fields":[{"name":"title","value":"Event Handling \u0026 Data Binding","type":"string"},{"name":"url","value":"/cookbook/event_handling_and_data_binding/","type":"enum"},{"name":"body","value":"Here are some recipes for managing events and dealing with bindings.\n\n\nBinding Properties of an Object to Its Own Properties\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"950060fbebe4e96580cf049a3a23d580","fields":[{"name":"title","value":"Adding Google Analytics Tracking","type":"string"},{"name":"url","value":"/cookbook/helpers_and_components/adding_google_analytics_tracking/","type":"enum"},{"name":"body","value":"Problem\nYou want to add analytics to your Ember application.\nSolution\nSubscribe to the didTransition event inside your application router.\n\nIn the following examples we're using Google Analytics but it could be any other analytics product.\nAdd google analytic's base code to the html file that renders your ember app.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  \u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n  \u003ctitle\u003eMy Ember Site\u003c/title\u003e\n  \u003cscript type=\"text/javascript\"\u003e\n\n    var _gaq = _gaq || [];\n    _gaq.push(['_setAccount', 'UA-XXXXX-Y']);\n\n    (function() {\n      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;\n      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';\n      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);\n    })();\n\n  \u003c/script\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\n\u003c/body\u003e\n\u003c/html\u003e\n\n\n\nThen reopen the application router and add this function. It will be called when\ndidTransition is fired by the router.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  var Router = Ember.Router.extend({\n  // customization goes here\n});\n\nRouter.reopen({\n  notifyGoogleAnalytics: function() {\n    return ga('send', 'pageview', {\n        'page': this.get('url'),\n        'title': this.get('url')\n      });\n  }.on('didTransition')\n});\n\nexport default Router;\n\n\nDiscussion\nThe didTransition event is responsible for notifying listeners of any URL\nchanges, in this example we are getting the path after the hash in the url so we\ncan notify Google Analytics about moving between areas of the site.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"19e03258c1115ce2ed917edfaaff2d8b","fields":[{"name":"title","value":"Creating Reusable Social Share Buttons","type":"string"},{"name":"url","value":"/cookbook/helpers_and_components/creating_reusable_social_share_buttons/","type":"enum"},{"name":"body","value":"Problem\nYou want to create a reusable Tweet button\nfor your application.\nSolution\nWrite a custom component that renders the Tweet button with specific attributes\npassed in.\n\n  1\n2\n3\n4\n\n  {{share-twitter class='twitter-share-button' href=url\n                    data-text=text\n                    data-size=\"large\"\n                    data-hashtags=\"emberjs\"}}\n\n\n\n  \n    \n      app/components/share-twitter.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Component.extend({\n  tagName: 'a',\n  classNames: 'twitter-share-button',\n  attributeBindings: ['data-size', 'data-url', 'data-text', 'data-hashtags']\n});\n\n\n\nInclude Twitter's widget code in your HTML:\n\n  1\n2\n3\n\n  \u003cscript\u003e\nwindow.twttr=(function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return;js=d.createElement(s);js.id=id;js.src=\"https://platform.twitter.com/widgets.js\";fjs.parentNode.insertBefore(js,fjs);t._e=[];t.ready=function(f){t._e.push(f);};return t;}(document,\"script\",\"twitter-wjs\"));\n\u003c/script\u003e\n\n\n\nNote: the Twitter api does change from time to time. Refer to the documents if necessary.\nDiscussion\nTwitter's widget library expects to find an \u003ca\u003e tag on the page with specific data- attributes applied.\nIt takes the values of these attributes and, when the \u003ca\u003e tag is clicked, opens an iFrame for twitter sharing.\n\nThe share-twitter component takes four options that match the four attributes for the resulting \u003ca\u003e tag:\ndata-url, data-text, data-size, data-hashtags. These options and their values become properties on the\ncomponent object. \n\nThe component defines certain attributes of its HTML representation as bound to properties of the object through\nits attributeBindings property. When the values of these properties change, the component's HTML element's\nattributes will be updated to match the new values.\n\nAn appropriate tag and css class are applied through the tagName and classNames properties.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"15f1bde6f3b703fd693ce18e0c1b8d81","fields":[{"name":"title","value":"Helpers \u0026 Components","type":"string"},{"name":"url","value":"/cookbook/helpers_and_components/","type":"enum"},{"name":"body","value":"Here are some recipes to help you encapsulate your code into Components and build Helpers.\n\n\nCreating Reusable Social Share Buttons\nA Spinning Button for Asynchronous Actions\nAdding Google Analytics Tracking\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b617fcfefa51d145d6a139c21ebdae70","fields":[{"name":"title","value":"A Spinning Button for Asynchronous Actions","type":"string"},{"name":"url","value":"/cookbook/helpers_and_components/spin_button_for_asynchronous_actions/","type":"enum"},{"name":"body","value":"Problem\nYou want a button component that spins to show asynchronous action till completion. Eg- Save Button.\nSolution\nWrite an Ember Component to change to loading state when action is taking place.\n\nFor example a button to save data could be as\n\n  \n    \n      app/templates/application.hbs\n    \n  \n\n  1\n\n  {{spin-button id=\"forapplication\" isLoading = isLoading buttonText=buttonText action='saveData'}}\n\n\n\n  \n    \n      app/templates/components/spin-button.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  \n\u003cbutton id={{id}} {{action 'showLoading'}}\u003e\n  {{#if isLoading}}\n    \u003cimg src=\"http://i639.photobucket.com/albums/uu116/pksjce/spiffygif_18x18.gif\"\u003e\n  {{else}}\n    {{buttonText}}\n  {{/if}}\n\u003c/button\u003e\n\n\n\n  \n    \n      app/controllers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  export default Ember.Controller.extend({\n    isLoading:false,\n    buttonText:\"Submit\",\n    actions:{\n        saveData:function(){\n            var self = this;\n\n           //Do Asynchronous action here. Set \"isLoading = false\" after a timeout.\n            Ember.run.later(function(){\n                self.set('isLoading', false);\n            }, 1000);\n        }\n    }\n});\n\n\n\n  \n    \n      app/components/spin-button.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  export default Ember.Component.extend({\n    classNames: ['button'],\n    buttonText:\"Save\",\n    isLoading:false,\n    actions:{\n        showLoading:function(){\n            if(!this.get('isLoading')){\n                this.set('isLoading', true);\n                this.sendAction('action');\n            }\n        }\n    }\n});\n\n\nDiscussion\nI have dumbed down the sample code to only change text within the button. One may add a loading image inside the button or change the button to a div styled like a button.\nThe component is in charge of setting isLoading = true and the base controller performing asynchronous action decides when the 'isLoading' becomes false again.\nFor safety and sanity of the component, one can add a settimeout of however much time and then set 'isLoading' back to false so that the components comes to initial state no matter the result of the asynchronous call. But I would prefer it was properly handled in the parent controller.\nAlso note that the component does not let multiple clicks get in the way of loading status.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"88c83cda7168eea4a444aaae82405ae5","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/cookbook/","type":"enum"},{"name":"body","value":"Welcome to the Ember.js Cookbook! The Cookbook provides answers and solutions\nto common Ember questions and problems. Anyone is welcome to contribute.\n\nHere are all of the available recipes:\nContributing\n\nUnderstanding the Cookbook Format\nParticipating If You Know Ember\nParticipating If You Don't Know Ember\nDeciding If A Recipe is a Good Fit\nSuggesting A Recipe\n\nUser Interface \u0026 Interaction\n\nAdding CSS Classes to Your Components\nAdding CSS Classes to Your Components Based on Properties\nFocusing a Textfield after It's Been Inserted\nDisplaying Formatted Dates With Moment.js\nSpecifying Data-Driven Areas of Templates That Do Not Need To Update\nUsing Modal Dialogs\nResetting scroll on route changes\n\nEvent Handling \u0026 Data Binding\n\nBinding Properties of an Object to Its Own Properties\n\nHelpers \u0026 Components\n\nCreating Reusable Social Share Buttons\nA Spinning Button for Asynchronous Actions\nAdding Google Analytics Tracking\n\nWorking with Objects\n\nIncrementing Or Decrementing A Property\nSetting Multiple Properties At Once\nContinuous Redrawing of Views\n\n\nIf you would like to see more recipes, take a look at the Suggesting A Recipe section.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2df8728459776c61d05ca768128c004b","fields":[{"name":"title","value":"Adding CSS Classes to Your Components","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/adding_css_classes_to_your_components/","type":"enum"},{"name":"body","value":"Problem\nYou want to add CSS class names to your Ember Components.\nSolution\nSet additional class names with the classNames property of subclassed components:\n\n  \n    \n      app/components/awesome-input.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Component.extend({\n  classNames: ['css-framework-fancy-class']  \n});\n\n\n\n  1\n\n  {{awesome-input}}\n\n\n\n  1\n\n  \u003cdiv class=\"css-framework-fancy-class\"\u003e\u003c/div\u003e\n\n\nDiscussion\nIf desired, you can apply multiple class names.\n\n  1\n\n  classNames: ['bold', 'italic', 'blue']\n\n\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"94aa466c359de8843e39693c877cdd64","fields":[{"name":"title","value":"Adding CSS Classes to Your Components Based on Properties","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/adding_css_classes_to_your_components_based_on_properties/","type":"enum"},{"name":"body","value":"Problem\nYou want to add or remove CSS class names to your Ember Components based on properties of the component.\nSolution\nAdd property names to the classNameBindings property of subclassed components.\nDiscussion\nYou can apply classes based on properties of the component, or even by properties bound to data passed into the component. This is done by binding the class attribute using classNameBindings.\n\n  1\n2\n\n  classNameBindings: ['active'],\nactive: true\n\n\n\nYou can also set the class name based on a computed property.\n\n  1\n2\n3\n4\n\n  classNameBindings: ['isActive'],\nisActive: function() {\n  return 'active';\n}.property('someAttribute')\n\n\n\nAnother way would be to bind the class name to a bound property.\n\n  1\n2\n\n  classNameBindings: ['isRelated:relative'],\nisRelatedBinding: \"content.isRelated\" // value resolves to boolean\n\n\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"356077cd8cbe65ee0bc9345c0360cb99","fields":[{"name":"title","value":"Displaying Formatted Dates With Moment.js","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/displaying_formatted_dates_with_moment_js/","type":"enum"},{"name":"body","value":"Problem\nDisplay JavaScript Date objects in human readable format.\nSolution\nThere are two ways of formatting the value:\n\n\nCreate a Handlebars helper {{format-date}} and use it in your template\nCreate a computed property formattedDate that will return a transformed date\n\n\nWe will use Moment.js for formatting dates.\n\nLet's look at a simple example. You're working on a website for your\nclient, and one of the requirements is to have the current date on the index page in human readable format. This is a perfect place to use a\nHandlebars helper that \"pretty prints\" the current date:\n\n  \n    \n      app/helpers/current-date.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Handlebars.makeBoundHelper(function() {\n  return moment().format('LL');\n});\n\n\n\nYour template will look like:\n\n  1\n\n  Today's date: {{current-date}}  // Today's date: August 30 2013\n\n\n\nYou can even enhance your code and pass in the date format to the helper:\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  Ember.Handlebars.registerBoundHelper('currentDate', function(format) {\n  return moment().format(format);\n});\n\nexport default Ember.Route.extend({\n});\n\n\n\nNow you would need to pass an additional parameter to the helper:\n\n  1\n\n  Today's date: {{current-date 'LL'}}  // Today's date: August 30 2013\n\n\n\nLet's look at another example. Say you need\nto create a simple control that allows you to type in a date and\na date format. The date will be formatted accordingly.\n\nDefine formattedDate computed property that depends on\ndate and format. Computed property in this example does\nthe same thing as Handlebars helpers defined above.\n\n  \n    \n      app/controllers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Controller.extend({\n  format: \"YYYYMMDD\",\n  date: null,\n  formattedDate: function() {\n    var date = this.get('date'),\n        format = this.get('format');\n    return moment(date).format(format);\n  }.property('date', 'format')\n});\n\n\n\n  \n    \n      /app/templates/application.hbs\n    \n  \n\n  1\n2\n3\n\n  {{input value=date}}\n{{input value=format}}\n\u003cdiv\u003e{{formattedDate}}\u003c/div\u003e\n\n\nDiscussion\nBoth helper and computed property can format your date value. \nWhich one do I use and when?\n\nHandlebars helpers are shorthand for cases where you want to format\na value specifically for presentation. That value may be used \nacross different models and controllers.\n\nYou can use {{current-date}} across your application to format dates\nwithout making any changes to controllers.\n\nComputed property in the example above does the same thing as the\nHandlebars helper with one big difference:\nformattedDate can be consumed later without applying\ndate format on the date property again.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"83c1f0cd7e851a3458314ba223f87911","fields":[{"name":"title","value":"Focusing a Textfield after It's Been Inserted","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/focusing_a_textfield_after_its_been_inserted/","type":"enum"},{"name":"body","value":"Problem\nYou have an Ember.TextField instance that you would like become focused after it's been inserted.\nSolution\nSubclass Ember.TextField and define a method marked with\n.on('didInsertElement'). Inside this method apply focus\nto the text field by accessing the component's jQuery $ property:\n\n  \n    \n      app/components/focus-input.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.TextField.extend({\n  becomeFocused: function() {\n    this.$().focus();\n  }.on('didInsertElement')\n});\n\n\n\nFor the component's template:\n\n  1\n\n  Focus Input component!\n\n\n\n  1\n\n  {{focus-input}}\n\n\nDiscussion\nCustom components provide a way to extend native HTML elements with new behavior\nlike autofocusing.\n\nOur App.FocusInputComponent is an extension of the Ember.TextField component\nwith a becomeFocused method added. After it is added to the DOM, every\ncomponent in Ember.js has access to an underlying jQuery object. This object wraps\nthe component's element and provides a unified, cross-browser interface for DOM\nmanipulations like triggering focus.\n\nBecause we can only work with these DOM features once an Ember.js component has\nbeen added to the DOM we need to wait for this event to occur. Component's have a\ndidInsertElement event that is triggered when the component has been added to the\nDOM.\n\nBy default Ember.js extends the native Function.prototype object to include a\nnumber of additional functions, the on function among them.  on gives us a declarative\nsyntax for signify that a method should be called when a specific event has fired. In this case,\nwe want to call our new becomeFocused method when the didInsertElement is fired for an instance \nof our component.\n\nPrototype extension can be disabled by setting the Ember.EXTEND_PROTOTYPES property to false.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"7885361de2e0b9cf0ea815192a0f9e6e","fields":[{"name":"title","value":"User Interface and Interaction","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/","type":"enum"},{"name":"body","value":"Here are some recipes that will help you provide a better user experience.\n\n\nAdding CSS Classes to Your Components\nAdding CSS Classes to Your Components Based on Properties\nFocusing a Textfield after It's Been Inserted\nDisplaying Formatted Dates With Moment.js\nSpecifying Data-Driven Areas of Templates That Do Not Need To Update\nUsing Modal Dialogs\nResetting scroll on route changes\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"63d8e08cdc54ce42a343231a617f595c","fields":[{"name":"title","value":"Resetting scroll on route changes","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/resetting_scroll_on_route_changes/","type":"enum"},{"name":"body","value":"Problem\nThe page scroller keeps in the same position when you go from one page to another. For instance, if you scroll down a long list of displayed elements on a page and then you navigate to another page with another long list of elements, you should be able to notice that scroll position is not being reset.\nSolution\nAdd the following mixin to the affected Routes:\n\n  \n    \n      app/mixins/reset-scroll.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Mixin.create({\n  activate: function() {\n    this._super();\n    window.scrollTo(0,0);\n  }\n});\n\n\n\nOnly if you need do something on the activate method you must call this._super() at the beginning:\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  import ResetScroll from '../mixins/reset-scroll/';\n\nexport default Ember.Route.extend(ResetScroll, {\n  //I need to do other things with activate\n  activate: function() {\n    this._super.apply(this, arguments); // Call super at the beginning\n    // Your stuff\n  }\n});\n\n\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ce0ad930ab039b25194ad5056f380516","fields":[{"name":"title","value":"Specifying Data-Driven Areas of Templates That Do Not Need To Update","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/specifying_data_driven_areas_of_templates_that_do_not_need_to_update/","type":"enum"},{"name":"body","value":"Problem\nYou have a section of a template that is based on a data but you don't need the template to update\nSolution\nUse the {{unbound}} Handlebars helper.\n\n  1\n2\n\n  {{unbound firstName}}\n{{lastName}}\n\n\nDiscussion\nBy default all uses of Handlebars helpers in Ember.js will use data bound values that will automatically update\nthe section of the template where a property changes after initial rendering.  Ember.Handlebars does this by\napplying the {{bind}} helper automatically for you.\n\nFor example, the two following uses of Handlebars are identical in an Ember.js application:\n\n  1\n2\n\n  {{lastName}}\n{{bind lastName}}\n\n\n\nIf you know that a property accessed in Handlebars will not change for the duration of the application's\nlife, you can specify that the property is not bound by applying the {{unbound}} helper. A property\nthat is not bound will avoid adding unnecessary observers on a property.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"118458a47bfa45283f898609ab029fd1","fields":[{"name":"title","value":"Using Modal Dialogs","type":"string"},{"name":"url","value":"/cookbook/user_interface_and_interaction/using_modal_dialogs/","type":"enum"},{"name":"body","value":"Problem\nYou want to show part of your UI in a modal dialog.\nSolution\nRender a specific controller into a named modal outlet in your application\ntemplate.\nDiscussion\nYou can use a route's render method to render a specific controller and\ntemplate into a named outlet. In this case we can setup our application template\nto handle the main outlet and a modal outlet:\n\n  1\n2\n\n  {{outlet}}\n{{outlet 'modal'}}\n\n\n\nThen you can render a controller and template into the modal outlet.  Sending\nan action in a template will propagate to the application route's actions.\n\nIn a template:\n\n  1\n\n  \u003cbutton {{action 'openModal' 'myModal'}}\u003eOpen modal\u003c/button\u003e\n\n\n\nIn your application route:\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default Ember.Route.extend({\n  actions: {\n    openModal: function(modalName) {\n      return this.render(modalName, {\n        into: 'application',\n        outlet: 'modal'\n      });\n    }\n  }\n});\n\n\n\nWhen closing a modal, you can use the route's disconnectOutlet method to remove\nthe modal from the DOM.\n\n  1\n2\n3\n4\n5\n6\n\n  closeModal: function() {\n  return this.disconnectOutlet({\n    outlet: 'modal',\n    parentView: 'application'\n  });\n}\n\n\n\nIt may also be helpful to use a modal-dialog component to handle common markup\nand interactions such as rendering an overlay and handling clicks outside of the\nmodal.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a3aef6a7a8621d2a8f6a06aeba45ea05","fields":[{"name":"title","value":"Continuous Redrawing of Views","type":"string"},{"name":"url","value":"/cookbook/working_with_objects/continuous_redrawing_of_views/","type":"enum"},{"name":"body","value":"Problem\nYou'd like to redraw your views every few seconds/minutes e.g. to update\nrelative timestamps (like on twitter.com).\nSolution\nHave a clock object with a pulse attribute in your application which\nincrements using a timed interval. You want to let view(s) bind values to be\nrefreshed when the pulse attribute increments.\n\nThe clock object can be used to create new instances for binding to new views\ngenerated within the application, like a list of comments.\n\n\nClockService object\nThis ClockService is an example of an object that may come from a library.\nAnd, is injected into the application via an initializer.\n\nDuring initialization the tick method is called which uses Ember.run.later\nwith a time of 250 milliseconds as the interval. A property is set at the end\nof the interval. Since the tick method observes the incremented property\nanother interval is triggered each time the property increases.\n\n  \n    \n      app/services/clock.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  export default Ember.Object.extend({\n    pulse: Ember.computed.oneWay('_seconds').readOnly(),\n    tick: function () {\n      var clock = this;\n      Ember.run.later(function () {\n        var seconds = clock.get('_seconds');\n        if (typeof seconds === 'number') {\n          clock.set('_seconds', seconds + (1/4));\n        }\n      }, 250);\n    }.observes('_seconds').on('init'),\n    _seconds: 0\n  });\n\n\nBinding to the pulse attribute\nIn this recipe, an application initializer is used to inject an instance of the\nClockService object, setting a controller's clock property to this instance.\n\n  \n    \n      app/initializers/services.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default {\n  name: 'services',\n  initialize: function(container, app) {\n    // inject into a specific route\n    app.inject('controller:interval', 'clock', 'service:clock');\n  }\n};\n\n\n\nThe controller can set any computed properties based on the pulse property of\nthe injected clock instance.\n\nIn this case the seconds property is bound to the pulse property of the\ncontroller's clock. The property clock.pulse was injected during\ninitialization.\n\nThe controller has (session) data to display seconds to visitors, as well as\na handful of properties used as conditions in the Handlebars template.\n\n  \n    \n      app/controllers/interval.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export default Ember.Controller.extend({\n    secondsBinding: 'clock.pulse',\n    fullSecond: function () {\n      return (this.get('seconds') % 1 === 0);\n    }.property('seconds'),\n    quarterSecond: function () {\n      return (this.get('seconds') % 1 === 1/4);\n    }.property('seconds'),\n    halfSecond: function () {\n      return (this.get('seconds') % 1 === 1/2);\n    }.property('seconds'),\n    threeQuarterSecond: function () {\n      return (this.get('seconds') % 1 === 3/4);\n    }.property('seconds')\n  });\n\n\n\nA controller for a list of comments, each comment will have a new clock\ninstance when added to the list. The comment item controller sets up\nthe seconds binding, used by the template to show the time since the\ncomment was created.\n\n  \n    \n      app/controllers/comment-item.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Controller.extend({\n  seconds: Ember.computed.oneWay('clock.pulse').readOnly()\n});\n\n\n\n  \n    \n      app/controllers/comments.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  import ClockService from '../services/clock';\n\nexport default Ember.ArrayController.extend({\n    itemController: 'commentItem',\n    comment: null,\n    actions: {\n      add: function () {\n        this.addObject(Ember.Object.create({\n          comment: this.get('comment'),\n          clock: ClockService.create()\n        }));\n        this.set('comment', null);\n      }\n    }\n  });\n\n\nHandlebars template which displays the pulse\nThe seconds value is computed from the pulse attribute. And the controller\nhas a few properties to select a component to render, fullSecond,\nquarterSecond, halfSecond, threeQuarterSecond.\n\n  \n    \n      app/templates/interval.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  {{#if fullSecond}}\n  {{nyan-start}}\n{{/if}}\n{{#if quarterSecond}}\n  {{nyan-middle}}\n{{/if}}\n{{#if halfSecond}}\n  {{nyan-end}}\n{{/if}}\n{{#if threeQuarterSecond}}\n  {{nyan-middle}}\n{{/if}}\n\u003ch3\u003eYou\u0026apos;ve nyaned for {{digital-clock seconds}} (h:m:s)\u003c/h3\u003e\n{{render 'comments'}}\n\n\n\nA template for a list of comments\napp/templates/comments.hbs\n\u003cform {{action \"add\" on=\"submit\"}}\u003e\n  {{input value=comment}}\n  \u003cbutton\u003eAdd Comment\u003c/button\u003e\n\u003c/form\u003e\n\u003cul\u003e\n{{#each this as |item|}}\n  \u003cli\u003e{{item.comment}} ({{digital-clock item.seconds}})\u003c/li\u003e\n{{/each}}\n\u003c/ul\u003e\n\nHandlebars helper to format the clock display (h:m:s)\nThis helper is used in the template like so {{digital-clock seconds}},\nseconds is the property of the controller that will be displayed (h:m:s).\n\n  \n    \n      app/helpers/digital-clock.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export default Ember.Handlebars.makeBoundHelper(function(seconds) {\n    var h = Math.floor(seconds / 3600);\n    var m = Math.floor((seconds % 3600) / 60);\n    var s = Math.floor(seconds % 60);\n    var addZero = function (number) {\n      return (number \u003c 10) ? '0' + number : '' + number;\n    };\n    var formatHMS = function(h, m, s) {\n      if (h \u003e 0) {\n        return '%@:%@:%@'.fmt(h, addZero(m), addZero(s));\n      }\n      return '%@:%@'.fmt(m, addZero(s));\n    };\n    return new Ember.Handlebars.SafeString(formatHMS(h, m, s));\n});\n\n\nNote\nTo explore the concept further, try adding a timestamp and updating the clock's\npulse by comparing the current time. This would be needed to update the pulse\nproperty when a user puts his/her computer to sleep then reopens their browser\nafter waking.\nLinks\n\n\nFurther reading:\n\n\nEmber Object\nEmber Application Initializers\nMethod Inject\nConditionals\nWriting Helpers\nDefining a Component\nEmber Array Controller\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"3e872f31e6a0cf6abf16d1d1f252b8c4","fields":[{"name":"title","value":"Incrementing Or Decrementing A Property","type":"string"},{"name":"url","value":"/cookbook/working_with_objects/incrementing_or_decrementing_a_property/","type":"enum"},{"name":"body","value":"Problem\nYou want to increment or decrement a property.\nSolution\nUse the incrementProperty or decrementProperty methods of Ember.Object.\n\nTo increment:\n\n  1\n\n  person.incrementProperty('age');\n\n\n\nTo decrement:\n\n  1\n\n  person.decrementProperty('age');\n\n\nDiscussion\nYou can optionally specify a value to increment or decrement by:\n\n  1\n\n  person.incrementProperty('age', 10);\n\n\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2c16149f0450be35676c93c8ba49fc26","fields":[{"name":"title","value":"Working with Objects","type":"string"},{"name":"url","value":"/cookbook/working_with_objects/","type":"enum"},{"name":"body","value":"Here are some recipes to help you understand working with Ember Objects.\n\n\nIncrementing Or Decrementing A Property\nSetting Multiple Properties At Once\nContinuous Redrawing of Views\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"5ab3bf9f56f37a23fabcd1360384b291","fields":[{"name":"title","value":"Setting Multiple Properties At Once","type":"string"},{"name":"url","value":"/cookbook/working_with_objects/setting_multiple_properties_at_once/","type":"enum"},{"name":"body","value":"Problem\nYou want to set multiple properties on an object with a single method call.\nSolution\nUse the setProperties method of Ember.Object.\n\n  1\n2\n3\n4\n\n  person.setProperties({\n  name: 'Gavin',\n  age: 36\n})\n\n\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6a54077923b8a93308baa1922a604275","fields":[{"name":"title","value":"Inspecting the Container","type":"string"},{"name":"url","value":"/ember-inspector/container/","type":"enum"},{"name":"body","value":"Ember.js implements dependency injection by using a container.  Every Ember\napplication has a container that creates instances for you. You can\ninspect these instances using the inspector's container tab.\n\n\n\nYou will see a list of object types the container has cached. Click on\none type to see the list of all instances created by the container.\n\nIn our case, we are looking at the instantiated controllers.\nInspecting Instances\nClick on one row to inspect an instance using the object inspector.\n\n\n\nTo send an instance to the console, click to open the\nobject inspector, and then click on $E at the top right of the object inspector.\nFilter and Reload\nYou can reload the container tab by clicking on the reload icon.\n\nTo search for instances, type a query in the search box.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e43dd675078ff4ac486b57fa13d5c944","fields":[{"name":"title","value":"Data Tab","type":"string"},{"name":"url","value":"/ember-inspector/data/","type":"enum"},{"name":"body","value":"If you are using a data library that supports the Ember Inspector such\nas Ember Data, you can inspect your models by clicking on the Data menu.\n\nWhen you open the Data tab, you will see a list of model types defined\nin your application. Each model type has the number loaded records next\nto it. You can click on one type to view all of its loaded records.\n\n\nInspecting Records\nEach row in the list represents a record, with the first four attributes\nas columns (just enough attributes to identify the record). To view all\nof the attributes and more properties, click on the record and it will\nopen in the object inspector.\n\n\nRecord States and Filtering\nThe data tab is a real time representation of your application's store.\nAny changes such as added records, modifications, or deleted records will\nimmediately be reflected in the data tab. Record attributes are also\nbound.\n\nNew unsaved records are green.\n\n\n\nModified unsaved records are blue.\n\n\n\nYou can filter records based on state by clicking on one of the pills\nbelow:\n\n\n\nYou can also filter records by entering a query in the search box.\nBuilding a Data Custom Adapter\nIf you have built your own data persistence library (as opposed to using Ember Data\nfor example), you can build a data adapter so you can inspect your models\nusing the data tab.\n\nYou can see the documentation for the data adapter\nhere.\n\nYou can also use Ember Data's data adapter as an example.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f1bedd99c57f624399a149361ed1ea21","fields":[{"name":"title","value":"Tackling Deprecations","type":"string"},{"name":"url","value":"/ember-inspector/deprecations/","type":"enum"},{"name":"body","value":"As part of making your app upgrades as smooth as possible, the\nEmber Inspector gathers deprecations, groups them, and displays them in a\nway that helps in tackling them.\n\nTo view the list of deprecations, click on the Deprecations menu.\n\n\n\nYou can see the total number of deprecations next to the Deprecations menu.\nYou can also see the number of occurrences for each deprecation.\nEmber Cli Deprecation Sources\nIf you are using Ember Cli and have source maps enabled, you can see a\nlist of sources for each deprecation. In Chrome and Firefox devtools,\nclicking on that source file will open the sources panel and take you to\nthe code that caused the deprecation message.\n\n\n\n\n\nYou can send the entire stack trace of the deprecation message to the\nconsole by clicking on Trace in the console.\nTransition Plans\nFor information on how to remove the deprecation warning,\nclick on the \"Transition Plan\" link to go to a helpful guide on how to\nupgrade on the Ember.js website.\n\n\nFiltering and Clearing\nYou can filter the deprecations by typing a query in the search box.\nYou can also clear the current deprecations by clicking on the clear icon\nat the top.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4d3cec3ae6d2506e5e756dc6182d88bb","fields":[{"name":"title","value":"Library Info","type":"string"},{"name":"url","value":"/ember-inspector/info/","type":"enum"},{"name":"body","value":"To see a list of libraries you are using along with their versions,\nclick on the Info menu.\n\n\nRegistering a Library\nIf you would like to add your own application to the list, or\nare a library author yourself, you can register it using:\n\n  1\n\n  Ember.libraries.register(libraryName, libraryVersion);\n\n\nEmber Cli\nEmber CLI automatically adds your application's name and version to the list\nthanks to the ember-cli-app-version addon.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6ffdaf430e1066949e727f7e18a926c0","fields":[{"name":"title","value":"Installing the Inspector","type":"string"},{"name":"url","value":"/ember-inspector/installation/","type":"enum"},{"name":"body","value":"The Ember Inspector extends browsers' developer tools to make understanding and debugging your Ember.js applications easier.\n\nSteps to install the inspector for Google Chrome, Firefox, other\nbrowsers (Bookmarklet), and apps running on mobile devices are explained\nbelow.\nGoogle Chrome\nYou can install the Ember Inspector on Google Chrome as a new developer\ntool panel.\n\nVisit the extension page on the Chrome Web Store.\n\nClick on \"Add To Chrome\":\n\n\n\nOnce installed, go to an Ember.js application, open the developer tools,\nand click on the Ember tab next to the rest of the devtools panels.\n\n\nFile:// protocol\nIf you need to use the inspector with the file:// protocol.\n\nVisit the URL: chrome://extensions and check the \"Allow access to file URLs\" checkbox:\n\n\nEnable Tomster\nYou can configure a tomster icon to show up in Chrome's url bar whenever you are visiting a site that uses Ember.js.\n\nVisit chrome://extensions.\n\nClick on Options.\n\n\n\nMake sure the \"Display the Tomster\" checkbox is checked.\n\n\nFirefox\nVisit the addon page on the Mozilla Addons\nsite.\n\nClick on \"Add to Firefox\".\n\n\n\nOnce installed, go to an Ember.js application, open the developer tools,\nand click on the Ember tab.\n\n\nEnable Tomster\nTo enable the tomster to show up in the url bar whenever you are\nvisiting a site that uses Ember.js Ember.js visit about:addons.\n\nClick on Extensions -\u003e Preferences.\n\n\n\nMake sure the \"Display the Tomster icon when a site runs Ember.js\" checkbox is checked.\n\n\nBookmarklet\nIf you are using any browser other than Chrome or Firefox, you can use the\nbookmarklet option to use the inspector.\n\nAdd the following bookmark:\n\nBookmark Me\n\nTo open the inspector, just click on the bookmark.\n\nInternet Explorer will open an iframe instead of a popup due to the lack of support for cross-origin messaging.\n\nSafari blocks popups by default, so you'll need to enable popups before\nusing this option.\nMobile Development\nIf you want to run the inspector with apps running on mobile devices,\nyou can use the Ember Cli Remote Inspector addon.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9893b6fad8e586504102380a81fea52b","fields":[{"name":"title","value":"Object Inspector","type":"string"},{"name":"url","value":"/ember-inspector/object-inspector/","type":"enum"},{"name":"body","value":"The inspector comes with its own object inspector that allows you to view and interact with your Ember objects.\nWhile using the inspector, click on any Ember object to open the object inspector and inspect its\nproperties.\nViewing Objects\nHere's what you see when you click on the posts controller.\n\n\n\nYou will see a list of parent objects and mixins that make up the object. The properties are organized by which parent object or\nmixin they were inherited from.\n\nComputed properties are preceded by a calculator icon. If a computed\nproperty hasn't been computed, you can click on the calculator to\ncompute it.\n\nAll properties are bound to your app, so property updates in your app will be reflected live in the inspector.\nSending Objects from and to the ConsoleObject Inspector to the Console\nYou can send objects and properties to the console by clicking on the $E button.\nThis will set the value to the global $E variable.\n\n\n\nWhen you hover over the object's properties, a $E button will appear\nnext to every property. Click on it to send the property's value to the\nconsole.\n\n\nConsole to the Object Inspector\nYou can send Ember objects and arrays to the object inspector by using\nEmberInspector.inspect.\n\n  1\n2\n\n  var object = Ember.Object.create();\nEmberInspector.inspect(object);\n\n\n\nMake sure the Ember Inspector is active when you call this method.\nEditing Properties\nYou can edit String, Number, and Boolean properties in the inspector.\nChanges will be reflected immediately in your app. Templates bound to\nthese properties will auto-update.\n\nClick on a property's value to start editing.\n\n\n\nDate values will open a date picker while editing.\n\n\n\nEdit the property and press the ENTER key to commit the change, or ESC to cancel.\nNavigating the Object Inspector\nProperties that are themselves Ember objects or arrays can be inspected\ntoo. Click on the property's value to inspect it.\n\n\n\nYou can keep\nnavigating through the inspector as long as properties are either an\nEmber object or an array.\nIn the image below, we clicked on the model property first, then clicked\non the store property.\n\n\n\nYou can see the current path of the inspected object at the top of the\ninspector. You can go back to the previous object by clicking on the\nleft-facing arrow at the top left.\nCustom Property Grouping\nSome objects' properties are not only grouped by inheritance, but also\nby framework level semantics. For example, if you inspect an Ember Data\nmodel, you can see Attributes, Belongs To, Has Many, and Flags\ngroups.\n\n\n\nYou can customize how any object shows up in the object inspector, and\nEmber Data models are just an example. If you are a library author, you\ncan define a _debugInfo method on your objects to customize how the inspector\ndisplays your properties. For an example on how to customize an\nobject's properties, see Ember Data's\ncustomization.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"586a911ed3096cd96da506f68a4f75ac","fields":[{"name":"title","value":"Debugging Promises","type":"string"},{"name":"url","value":"/ember-inspector/promises/","type":"enum"},{"name":"body","value":"The inspector provides a way to look at all the promises being created\nin your application. Click on the Promises menu to start inspecting\nyour promises.\n\n\n\nYou can see a hierarchical list of promises with labels describing each\npromise, its state, settled value, and the time it took to\nsettle.\nPromise States and Filtering\nPromises will have different colors based on their state.\n\n\n\n\n\n\n\nYou can filter promises by state by clicking on one of the following\npills: Rejected, Pending, Fulfilled.\n\n\n\nYou can also search for promises by typing a query in the search box.\n\nTo clear the currently logged promises, click on the clear icon on the\ntop left of the tab.\nInspecting Settled Values\nIf the fulfillment value is an Ember object or an array, you can click\non that object to open it in the object inspector.\n\n\n\nIf the rejection value is an Error object, you can send its stack trace to\nthe console.\n\n\n\nYou can also click on the $E button to send the value to the console.\nTracing\nThe inspector provides a way to view a promise's stack trace.\nTracing promises is disabled by default for performance reasons. To\nenable tracing, check the Trace promise checkbox. You may want to\nreload to trace existing promises.\n\n\n\nTo trace a promise, click on the Trace button next to the label,\nwhich will send the promise stack trace to the console.\n\n\nLabeling Promises\nPromises generated by Ember.js are all labeled by default.\nYou can also label your own RSVP promises to find them in the inspector's Promises tab.\nAll RSVP methods can take a label as the final argument.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  \nvar label = 'Find Posts'\n\nnew RSVP.Promise(method, label);\n\nRSVP.Promise.resolve(value, label);\n\nRSVP.Promise.reject(reason, label);\n\nRSVP.Promise.all(array, label);\n\nRSVP.Promise.hash(hash, label);\n\npromise.then(success, failure, label);\n\npromise.catch(callback, label);\n\npromise.finally(callback, label);\n\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ed658525bc79f3040009b9bb48c2b542","fields":[{"name":"title","value":"Rendering Performance","type":"string"},{"name":"url","value":"/ember-inspector/render-performance/","type":"enum"},{"name":"body","value":"You can use the inspector to measure the time it takes for your views to\nbe created. Click on Render Performance to start inspecting render times.\n\n\nAccuracy\nThe inspector itself adds a delay to your rendering, so the render durations you see\nare not an accurate representation of your production apps. Use these\nnumbers to compare durations and debug rendering bottlenecks, but not as\na way to accurately measure rendering times.\nToolbar\nClick on the \"clear\" icon to remove existing render logs.\n\nTo measure views that are rendered on initial application boot, you will\nneed to click on the \"Reload\" button at the top. This button ensures\nthat the inspector starts measuring render times immediately when your app boots.\n\nTo filter the render logs, type a query in the search box.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"055448419ab0ef77beac250a0a5d84ee","fields":[{"name":"title","value":"Inspecting Routes","type":"string"},{"name":"url","value":"/ember-inspector/routes/","type":"enum"},{"name":"body","value":"The inspector's Routes tab displays a list of all your application's\nroutes. To view your routes, click on the \"Routes\" menu.\n\nFor the following code:\n\n  1\n2\n3\n\n  this.route('posts', function() {\n  this.route('new');\n});\n\n\n\nThe Route Tree will display these routes:\n\n\n\nAs you can see, it shows you the routes you defined, and the routes that\nare automatically generated for you by Ember.js.\n\nWe can use this list to figure out what Ember.js expects us to name\nour objects. For example, if we want to create a controller for the\nposts.new route, the Routes tab tells us that the controller\nshould be called posts/new. If we want a to add a loading route for the\nposts resource, we can see that the route should be posts/loading.\n\nIt is also easy to see the generated URL for a specific route. In our\nexample, posts/index will have the url /posts.\n\nAs for objects that you have defined, you can click on them to send them to\nthe object inspector, or click on the $E button next to them to send them to the console.\nViewing the Current Route\nThe current route is highlighted in bold. However, as your routes grow in\nnumber, it can be quite crowded, and harder to find the current route just by looking at the\nfont weight. A better way is to click on the Current Route Only\ncheckbox to hide all routes except the currently active ones.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b95f5ae41d7e6c6611080f203e11268c","fields":[{"name":"title","value":"Troubleshooting","type":"string"},{"name":"url","value":"/ember-inspector/troubleshooting/","type":"enum"},{"name":"body","value":"Below are some common issues you may encounter, along with the necessary\nsteps to solve them. If your issue is not listed below, please submit an\nissue to the inspector's Github repo.\nEmber Application Not Detected\nIf the inspector cannot detect an Ember application, you will see\nthe following message:\n\n\n\nSome of the reasons this happens:\n\n\nThis is not an Ember application\nYou are using an old Ember version ( \u003c 1.0 ).\nYou are using a protocol other than http or https. For file:// protocol,\nfollow these steps.\nThe Ember application is inside a sandboxed iframe with no url (if you\nare using Jsbin, follow these steps.\n\nUsing the Inspector with Jsbin\nDue to the way Jsbin uses iframes, the inspector doesn't work with edit\nmode.\n\nTo use the inspector, switch to the \"live preview\" mode by clicking on the\narrow circled below.\n\n\nApplication is not Detected Without Reload\nIf you always have to reload the application after you open the\ninspector, that may mean your application's\nbooted state is corrupted. This happens if you are calling\nadvanceReadiness or deferReadiness after the application has\nalready booted.\nData Adapter Not Detected\nWhen you click on the Data tab, and see this message:\n\n\n\nIt means that you are either not using a data persistence library\n(such as Ember Data), or the library you're using does not support the\nEmber Inspector.\n\nIf you are the library's author, see this section on how to add Ember Inspector support.\nPromises Not Detected\nYou click on the Promises tab, and see this message:\n\n\n\nThis happens if you are using a version of Ember \u003c 1.3.\nMissing Promises\nIf the Promises tab is working, but there are promises you can't find,\nit's probably because these Promises were created before the\ninspector is activated.\n\nTo start detecting promises the moment the app boots, click on the Reload button below:\n\n\nInspector Version Old on Firefox\nFirefox addons need to go through a review process before every update.\nThis causes the Firefox Ember Inspector to usually be one version\nbehind.\n\nUnfortunately we don't have control over this process, so if you need\nthe latest inspector version, you will have to download and install the inspector\nmanually from Github.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a9ffd50c1c93761a22ac9b6feb6362a5","fields":[{"name":"title","value":"The View Tree","type":"string"},{"name":"url","value":"/ember-inspector/view-tree/","type":"enum"},{"name":"body","value":"You can inspect the current views and components rendered in your\napplication. The View Tree shows you a tree of what is currently rendered,\nalong with templates, controllers, and models backing each view.\n\nClick on the View Tree menu on the left to see your views.\n\n\nInspecting Objects\nYou can click on any model, controller, view, or component\nto send them to the object inspector.\n\n\n\nYou can also click on the $E button next to them to send them to the console and\nassign them to the global $E variable.\nInspecting Templates\nIf you are using Chrome or Firefox and click on a template that has a DOM element,\nyou will be sent to the Elements panel with that DOM element selected.\n\n\n\n\nComponents and Inline Views\nThe View Tree ignores components and inline views by default. To\nsee them, check the Components and All Views checkboxes.\n\n\nHighlighting TemplatesHovering over the view tree\nWhen you hover over the views in the list, the templates will be\nhighlighted in your app. For every highlighted view, you can see the\ntemplate name, controller, view, and model.\n\n\nHovering over the app\nIf you want to highlight a template directly from your app, you can\nclick on the magnifying glass and hover your mouse over your app. Any\ntime your mouse passes over a template, that template will be\nhighlighted and will show its name and its model, controller, and view names.\n\nIf you want components to be highlighted, you will need to check the\nComponents checkbox first.\n\n\n\nIf you click on a highlighted template, you will select it and can then\nclick on the controller, view, component, or model to send them to the\nobject inspector.\n\n\n\nClick on the X button to unselect a template.\nRender Duration\nDuration displays the time it took for a specific DOM element to be\ncreated along with all its children.\n\n\n\nInstrumentation however adds its own delay to rendering, so the\nnumbers you see are not an exact representation of production apps.\nThese numbers should be used to compare rendering times, and not as a\nreplacement for performance benchmarking.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ae8e92d454a11640f89eb9be33e7795a","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/enumerables/","type":"enum"},{"name":"body","value":"Enumerables\nIn Ember.js, an Enumerable is any object that contains a number of child\nobjects, and which allows you to work with those children using the\nEmber.Enumerable API. The most common\nEnumerable in the majority of apps is the native JavaScript array, which\nEmber.js extends to conform to the Enumerable interface.\n\nBy providing a standardized interface for dealing with enumerables,\nEmber.js allows you to completely change the way your underlying data is\nstored without having to modify the other parts of your application that\naccess it.\n\nThe Enumerable API follows ECMAScript specifications as much as\npossible. This minimizes incompatibility with other libraries, and\nallows Ember.js to use the native browser implementations in arrays\nwhere available.\n\nFor instance, all Enumerables support the standard forEach method:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  [1,2,3].forEach(function(item) {\n  console.log(item);\n});\n\n//=\u003e 1\n//=\u003e 2\n//=\u003e 3\n\n\n\nIn general, Enumerable methods, like forEach, take an optional second\nparameter, which will become the value of this in the callback\nfunction:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var array = [1,2,3];\n\narray.forEach(function(item) {\n  console.log(item, this.indexOf(item));\n}, array)\n\n//=\u003e 1 0\n//=\u003e 2 1\n//=\u003e 3 2\n\n\nEnumerables in Ember.js\nUsually, objects that represent lists implement the Enumerable interface. Some examples:\n\n\nArray - Ember extends the native JavaScript Array with the\nEnumerable interface (unless you disable prototype\nextensions.)\nEmber.ArrayController - A controller that wraps an underlying array and\nadds additional functionality for the view layer.\nEmber.Set - A data structure that can efficiently answer whether it\nincludes an object.\n\nAPI Overview\nIn this guide, we'll explore some of the most common Enumerable\nconveniences. For the full list, please see the Ember.Enumerable API\nreference documentation.\nIterating Over an Enumerable\nTo enumerate all the values of an enumerable object, use the forEach method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var food = [\"Poi\", \"Ono\", \"Adobo Chicken\"];\n\nfood.forEach(function(item, index) {\n  console.log('Menu Item %@: %@'.fmt(index+1, item));\n});\n\n// Menu Item 1: Poi\n// Menu Item 2: Ono\n// Menu Item 3: Adobo Chicken\n\n\nMaking an Array Copy\nYou can make a native array copy of any object that implements\nEmber.Enumerable by calling the toArray() method:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var states = Ember.Set.create();\n\nstates.add(\"Hawaii\");\nstates.add(\"California\")\n\nstates.toArray()\n//=\u003e [\"Hawaii\", \"California\"]\n\n\n\nNote that in many enumerables, such as the Ember.Set used in this\nexample, the order of the resulting array is not guaranteed.\nFirst and Last Objects\nAll Enumerables expose firstObject and lastObject properties\nthat you can bind to.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  var animals = [\"rooster\", \"pig\"];\n\nanimals.get('lastObject');\n//=\u003e \"pig\"\n\nanimals.pushObject(\"peacock\");\n\nanimals.get('lastObject');\n//=\u003e \"peacock\"\n\n\nMap\nYou can easily transform each item in an enumerable using the\nmap() method, which creates a new array with results of calling a\nfunction on each item in the enumerable.\n\n  1\n2\n3\n4\n5\n6\n\n  var words = [\"goodbye\", \"cruel\", \"world\"];\n\nvar emphaticWords = words.map(function(item) {\n  return item + \"!\";\n});\n// [\"goodbye!\", \"cruel!\", \"world!\"]\n\n\n\nIf your enumerable is composed of objects, there is a mapBy()\nmethod that will extract the named property from each of those objects\nin turn and return a new array:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  var hawaii = Ember.Object.create({\n  capital: \"Honolulu\"\n});\n\nvar california = Ember.Object.create({\n  capital: \"Sacramento\"\n});\n\nvar states = [hawaii, california];\n\nstates.mapBy('capital');\n//=\u003e [\"Honolulu\", \"Sacramento\"]\n\n\nFiltering\nAnother common task to perform on an Enumerable is to take the\nEnumerable as input, and return an Array after filtering it based on\nsome criteria.\n\nFor arbitrary filtering, use the filter method.  The filter method\nexpects the callback to return true if Ember should include it in the\nfinal Array, and false or undefined if Ember should not.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var arr = [1,2,3,4,5];\n\narr.filter(function(item, index, self) {\n  if (item \u003c 4) { return true; }\n})\n\n// returns [1,2,3]\n\n\n\nWhen working with a collection of Ember objects, you will often want to filter a set of objects based upon the value of some property. The filterBy method provides a shortcut.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  Todo = Ember.Object.extend({\n  title: null,\n  isDone: false\n});\n\ntodos = [\n  Todo.create({ title: 'Write code', isDone: true }),\n  Todo.create({ title: 'Go to sleep' })\n];\n\ntodos.filterBy('isDone', true);\n\n// returns an Array containing only items with `isDone == true`\n\n\n\nIf you want to return just the first matched value, rather than an Array containing all of the matched values, you can use find and findBy, which work just like filter and filterBy, but return only one item.\nAggregate Information (All or Any)\nIf you want to find out whether every item in an Enumerable matches some condition, you can use the every method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  Person = Ember.Object.extend({\n  name: null,\n  isHappy: false\n});\n\nvar people = [\n  Person.create({ name: 'Yehuda', isHappy: true }),\n  Person.create({ name: 'Majd', isHappy: false })\n];\n\npeople.every(function(person, index, self) {\n  if(person.get('isHappy')) { return true; }\n});\n\n// returns false\n\n\n\nIf you want to find out whether at least one item in an Enumerable matches some conditions, you can use the some method:\n\n  1\n2\n3\n4\n5\n\n  people.some(function(person, index, self) {\n  if(person.get('isHappy')) { return true; }\n});\n\n// returns true\n\n\n\nJust like the filtering methods, the every and some methods have analogous isEvery and isAny methods.\n\n  1\n2\n\n  people.isEvery('isHappy', true) // false\npeople.isAny('isHappy', true)  // true\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"be0c907ef74b9cac799c61df26fcac27","fields":[{"name":"title","value":"Glossary","type":"string"},{"name":"url","value":"/getting-started/glossary/","type":"enum"},{"name":"body","value":"Joining a web development community can be a challenge within itself, especially when all the resources you visit assume you're familiar with other technologies that you're not familiar with.\n\nOur goal is to help you avoid that mess and come up to speed as fast as possible; you can consider us your internet friend.\nCDN\nContent Delivery Network\n\nThis is typically a paid service you can use to get great performance for your app. You start by uploading a resource (image, JavaScript file, etc) to a company like Akamai or CloudFlare. That uploaded resource will have an absolute URL which you can reference anywhere in your app. This URL will resolve differently for folks depending on where they're browsing.\n\nBehind the scenes, the CDN will distribute your content geographically with the goal of end-users being able to fetch your content with the lowest latency possible. For example, if a user is in India, they'd likely get content served from India faster than from the United States.\nCoffeeScript, TypeScript\nThese are both languages that compile to JavaScript. You're able to write your code using the syntax they offer and when ready you compile your TypesScript or CoffeeScript into JavaScript.\n\nCoffeeScript vs TypeScript\nEvergreen browsers\nBrowsers that update themselves (without user intervention).\n\nEvergreen Browsers\nES3, ES5, ES5.1, ES6 (aka ES2015), etc\nES stands for ECMAScript, which is the specification that JavaScript is based on. The number that follows is the version of the specification.\n\nMost browsers support at least ES5, and some even have ES6 (also known as ES2015) support. You can check each browser's support (including yours) here:\n\n\nES5 support\nES6 support\n\n\nECMAScript\nLESS, Sass\nBoth LESS and Sass are types of CSS preprocessor markup intended to give you much more control over your CSS. During the build process, the LESS or Sass resources compile down to vanilla CSS (which can be executed in a browser).\n\nSass/Less Comparison\nLinter, linting, jslint, jshint\nA validation tool which checks for common issues in your JavaScript. You'd usually use this in your build process to enforce quality in your codebase. A great example of something to check for: making sure you've always got your semicolons.\n\nAn example of some of the options you can configure\nPolyfill\nThis is concept that typically means providing JavaScript which tests for features that are missing (prototypes not defined, etc) and \"fills\" them by providing an implementation.\nPromise\nAsynchronous calls typically return a promise (or deferred). This is an object which has a state: it can be given handlers for when it's fulfilled or rejected.\n\nEmber.js makes use of these in places like the model hook for a route. Until the promise resolves, Ember is able to put the route into a \"loading\" state.\n\n\nAn open standard for sound, interoperable JavaScript promises\nemberjs.com - A word on promises\n\nSSR\nServer Side Rendering\n\nInside FastBoot: The Road to Server-Side Rendering\nTranspile\nWhen related to JavaScript, this can be part of your build process which \"transpiles\" (converts) your ES6 syntax JavaScript to JavaScript that is supported by current browsers.\n\nBesides ES6, you'll see a lot of content about compiling/transpiling CoffeeScript, a short-hand language which can \"compile\" to JavaScript.\n\n\nEmber CLI specifically uses Babel via the ember-cli-babel plugin.\n\nShadow DOM\nNot to be confused with Virtual DOM. Shadow DOM is still a work in progress, but basically a proposed way to have an \"isolated\" DOM encapsulated within your app's DOM.\n\nCreating a re-usable \"widget\" or control might be a good use-case for this. Browsers implement some of their controls using their own version of a shadow DOM.\n\n\nW3C Working Draft\nWhat the Heck is Shadow DOM?\n\nVirtual DOM\nNot to be confused with Shadow DOM. The concept of a virtual DOM means abstracting your code (or in our case, Ember) away from using the browser's DOM in favor of a \"virtual\" DOM that can easily be accessed for read/writes or even serialized.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"59427847e14331e01de43a097e3ee4cb","fields":[{"name":"title","value":"Installing Ember","type":"string"},{"name":"url","value":"/getting-started/","type":"enum"},{"name":"body","value":"Getting started with Ember.js is easy. Ember.js projects are created and managed\nthrough our command line build tool ember-cli. The command line tool brings:\n\n\nModern application asset management (including combining, minifying, and versioning).\nBuilt-in generators to help you create components, routes, and more.\nA conventional project layout so approaching another developer's Ember.js applications is easy.\nOfficial JavaScript modules to keep your project organized.\nA complete testing framework.\nAccess to a growing ecosystem of Ember Addons.\n\nInstallation\nEmber.js installs through the npm. Install the Ember.js\nbuild tools with npm.\n\n  1\n\n  npm install -g ember-cli\n\n\nTesting your installation\nWhen installation completes, test your install to ensure it worked by generating a\nnew project:\n\n  1\n\n  ember new my-app\n\n\n\nThis will create a new my-app directory and generate an application structure for you.\n\nOnce the generation process finishes, verify that you can run the newly created application:\n\n  1\n2\n\n  cd my-app\nember server\n\n\n\nNavigate to http://localhost:4200 to see your new app in action.\nTroubleshootingGot Node, npm, and Git?\nember-cli requires Node.js 0.12 or higher, npm 2.7 or higher, and Git.\n\nNode Package Manager (npm) comes bundled with node.js.  If you're not sure if\nyou have node.js installed, try running the following command in your terminal:\n\n  1\n\n  node --version\n\n\n\nIf you have node installed you'll see a message like 0.12.x in your terminal.\n\nIf you don't have node 0.12 or higher installed:\n\n\nWindows or Mac users can download and run the installer.\nLinux users should read through this guide by Joyent for install instructions.\n\n\nOnce you've got node.js installed, run the node --version command again to verify your install.\n\nGit comes with Mac OS X and most Linux distributions.\nWindows users can download and run the installer.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6666cd76f96956469e7be39d750cc7d9","fields":[{"name":"title","value":"Ember.js Guides","type":"string"},{"name":"url","value":"/","type":"enum"},{"name":"body","value":"Welcome to the Ember.js guides! This documentation will take you from\ntotal beginner to Ember expert. It is designed to start from the basics,\nand slowly increase to more sophisticated concepts until you know\neverything there is to know about building awesome web applications.\n\nMost of these guides are designed to help you start building apps right\naway. If you'd like to know more about the thinking behind Ember.js,\nyou'll find what you're looking for in the Understanding Ember.js\nsection.\n\nThese guides are written in Markdown and are\navailable on GitHub.\nIf there is something missing, or you find a typo or\nmistake, please help us by filing an issue or submitting a pull\nrequest. Thanks!\n\nWe're excited for all of the great apps you're going to build with\nEmber.js. To get started, select a topic from the left. They are\npresented in the order that we think will be most useful to you as\nyou're learning Ember.js, but you can also jump to whatever seems\nmost interesting.\n\nGood luck!\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"298653c42879aa9157122be8d7fcad36","fields":[{"name":"title","value":"Connecting to an HTTP Server","type":"string"},{"name":"url","value":"/models/connecting-to-an-http-server/","type":"enum"},{"name":"body","value":"If your Ember application needs to load JSON data from an HTTP\nserver, this guide will walk you through the process of configuring\nEmber Data to load records in whatever format your server returns.\n\nThe store uses an object called an adapter to know how to\ncommunicate over the network. By default, the store will use\nDS.RESTAdapter, an adapter that communicates with an HTTP server by\ntransmitting JSON via XHR.\n\nThis guide is divided into two sections. The first section covers what\nthe default behavior of the adapter is, including what URLs it will\nrequest records from and what format it expects the JSON to be in.\n\nThe second section covers how to override these default settings to\ncustomize things like which URLs data is requested from and how the JSON\ndata is structured.\nURL Conventions\nThe REST adapter uses the name of the model to determine what URL to\nsend JSON to.\n\nFor example, if you ask for a photo record by ID:\n\n  \n    \n      app/routes/photo.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model: function(params) {\n    return this.store.find('photo', params.photo_id);\n  }\n});\n\n\n\nThe REST adapter will automatically send a GET request to /photos/1.\n\nThe actions you can take on a record map onto the following URLs in the\nREST adapter:\n\n\n  \n    ActionHTTP VerbURL\n  \n  \n    FindGET/photos/123\n    Find AllGET/photos\n    UpdatePUT/photos/123\n    CreatePOST/photos\n    DeleteDELETE/photos/123\n  \n\nJSON Conventions\nGiven the following models:\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  import DS from 'ember-data';\n\nexport default DS.Model.extend({\n  title:    DS.attr(),\n  comments: DS.hasMany('comment'),\n  user:     DS.belongsTo('user')\n});\n\n\n\n  \n    \n      app/models/comment.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  import DS from 'ember-data';\n\nApp.Comment = DS.Model.extend({\n  body: DS.attr()\n});\n\n\n\nEmber Data expects that a GET request to /posts/1 would\nreturn the JSON in the following format:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  {\n  \"post\": {\n    \"id\": 1,\n    \"title\": \"Rails is omakase\",\n    \"comments\": [\"1\", \"2\"],\n    \"user\" : \"dhh\"\n  },\n\n  \"comments\": [{\n    \"id\": \"1\",\n    \"body\": \"Rails is unagi\"\n  }, {\n    \"id\": \"2\",\n    \"body\": \"Omakase O_o\"\n  }]\n}\n\n\n\nTo quickly prototype a model and see the expected JSON, try using the Ember Data Model Maker by Andy Crum.\nCustomizing the Adapter\nTo customize the REST adapter, create a app/adapters/application.js file\nand export a subclass of DS.RESTAdapter. You can then override its properties\nand methods to customize how records are retrieved and saved.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  ...\n});\n\n\nCustomizing a Specific Model\nIt's entirely possible that you need to define options for just one model instead of an application-wide customization. In that case, you can create an adapter named after the model you are specifying:\n\n  \n    \n      app/adapters/post.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default DS.RESTAdapter.extend({\n  namespace: 'api/v2',\n  host: 'https://api.example2.com'\n});\n\n\n\n  \n    \n      app/adapters/photo.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default DS.RESTAdapter.extend({\n  namespace: 'api/v1',\n  host: 'https://api.example.com'\n});\n\n\n\nThis allows you to easily connect to multiple API versions simultaneously or interact with different domains on a per model basis.\nCustomizing URLsURL Prefix\nIf your JSON API lives somewhere other than on the host root,\nyou can set a prefix that will be added to all requests.\n\nFor example, if you are using a versioned JSON API, a request for a\nparticular person might go to /api/v1/people/1.\n\nIn that case, set namespace property to api/v1.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  namespace: 'api/v1'\n});\n\n\n\nRequests for a person with ID 1  would now go to /api/v1/people/1.\nURL Host\nIf your JSON API runs on a different domain than the one serving your\nEmber app, you can change the host used to make HTTP requests.\n\nNote that in order for this to work, you will need to be using a browser\nthat supports CORS, and\nyour server will need to be configured to send the correct CORS headers.\n\nTo change the host that requests are sent to, set the host property:\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  host: 'https://api.example.com'\n});\n\n\n\nRequests for a person with ID 1 would now target https://api.example.com/people/1.\nCustom HTTP Headers\nSome APIs require HTTP headers, e.g. to provide an API key. Arbitrary\nheaders can be set as key/value pairs on the RESTAdapter's headers\nproperty and Ember Data will send them along with each ajax request.\n\nFor Example\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default DS.RESTAdapter.extend({\n  headers: {\n    'API_KEY': 'secret key',\n    'ANOTHER_HEADER': 'Some header value'\n  }\n});\n\n\n\nRequests for any resource will include the following HTTP headers.\n\n  1\n2\n\n  ANOTHER_HEADER: Some header value\nAPI_KEY: secret key\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9fca6476286a0f29bd93adca72f72c4d","fields":[{"name":"title","value":"Creating and Deleting Records","type":"string"},{"name":"url","value":"/models/creating-and-deleting-records/","type":"enum"},{"name":"body","value":"You can create records by calling the createRecord method on the store.\n\n  1\n2\n3\n4\n\n  store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\n\n\nThe store object is available in controllers and routes using this.store.\n\nAlthough createRecord is fairly straightforward, the only thing to watch out for\nis that you cannot assign a promise as a relationship, currently.\n\nFor example, if you want to set the author property of a post, this would not work\nif the user with id isn't already loaded into the store:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var store = this.store;\n\nstore.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum',\n  author: store.find('user', 1)\n});\n\n\n\nHowever, you can easily set the relationship after the promise has fulfilled:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  var store = this.store;\n\nvar post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\nstore.find('user', 1).then(function(user) {\n  post.set('author', user);\n});\n\n\nDeleting Records\nDeleting records is just as straightforward as creating records. Just call deleteRecord()\non any instance of DS.Model. This flags the record as isDeleted and thus removes\nit from all() queries on the store. The deletion can then be persisted using save().\nAlternatively, you can use the destroyRecord method to delete and persist at the same time.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  store.find('post', 1).then(function (post) {\n  post.deleteRecord();\n  post.get('isDeleted'); // =\u003e true\n  post.save(); // =\u003e DELETE to /posts/1\n});\n\n// OR\nstore.find('post', 2).then(function (post) {\n  post.destroyRecord(); // =\u003e DELETE to /posts/2\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"c789ddb5644abcf443cde5398de5f989","fields":[{"name":"title","value":"Customizing Adapters","type":"string"},{"name":"url","value":"/models/customizing-adapters/","type":"enum"},{"name":"body","value":"In Ember Data, the logic for communicating with a backend data store\nlives in the Adapter. Ember Data's Adapter has some built-in\nassumptions of how a REST API should look. If\nyour backend conventions differ from these assumptions Ember Data\nmakes it easy to change its functionality by swapping out or extending\nthe default Adapter.\n\nSome reasons for customizing an Adapter include using\nunderscores_case in your urls, using a medium other than REST to\ncommunicate with your backend API or even using a\nlocal backend.\n\nExtending Adapters is a natural process in Ember Data. Ember takes the\nposition that you should extend an adapter to add different\nfunctionality instead of adding a flag. This results in code that is\nmore testable, easier to understand and reduces bloat for people who\nmay want to subclass your adapter.\n\nIf your backend has some consistent rules you can define an\nadapter:application. The adapter:application will get priority over\nthe default Adapter, however it will still be superseded by model\nspecific Adapters.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  // Application specific overrides go here\n});\n\n\n\nIf you have one model that has exceptional rules for communicating\nwith its backend than the others you can create a Model specific\nAdapter by running the command ember generate adapter adapter-name\".\nFor example, running ember generate adapter post will create the\nfollowing file:\n\n  \n    \n      app/adapters/post.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  namespace: 'api/v1'\n});\n\n\n\nBy default Ember Data comes with several builtin adapters. Feel free\nto use these adapters as a starting point for creating your own custom\nadapter.\n\n\nDS.Adapter is the basic adapter\nwith no functionality. It is generally a good starting point if you\nwant to create an adapter that is radically different from the other\nEmber adapters.\nDS.RESTAdapter is the most\ncommonly extended adapter. The RESTAdapter allows your store to\ncommunicate with an HTTP server by transmitting JSON via XHR. Most\nEmber.js apps that consume a JSON API should use the REST adapter.\nDS.ActiveModelAdapter\nis a specialized version of the RESTAdapter that is set up to work\nout of the box with Rails-style REST APIs.\n\nCustomizing the RESTAdapter\nThe DS.RESTAdapter is the\nmost commonly extended adapter that ships with Ember Data. It has a\nhandful of hooks that are commonly used to extend it to work with\nnon-standard backends.\nEndpoint Path Customization\nThe namespace property can be used to prefix requests with a\nspecific url namespace.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  namespace: 'api/1'\n});\n\n\n\nRequests for person would now target http://emberjs.com/api/1/people/1.\nHost Customization\nBy default the adapter will target the current domain. If you would\nlike to specify a new domain you can do so by setting the host\nproperty on the adapter.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  host: 'https://api.example.com'\n});\n\n\n\nRequests for person would now target https://api.example.com/people/1.\nPath Customization\nBy default the RESTAdapter will attempt to pluralize and camelCase\nthe model name to generate the path name. If this convention does not\nconform to your backend you can override the pathForType method.\n\nFor example, if you did not want to pluralize model names and needed\nunderscore_case instead of camelCase you could override the\npathForType method like this:\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.RESTAdapter.extend({\n  pathForType: function(type) {\n    return Ember.String.underscore(type);\n  }\n});\n\n\n\nRequests for person would now target /person/1.\nRequests for userProfile would now target /user_profile/1.\nAuthoring Adapters\nThe defaultSerializer property can be used to specify the serializer\nthat will be used by this adapter. This is only used when a model\nspecific serializer or ApplicationSerializer are not defined.\n\nIn an application, it is often easier to specify an\nApplicationSerializer. However, if you are the author of a community\nadapter it is important to remember to set this property to ensure\nEmber does the right thing in the case a user of your adapter\ndoes not specify an ApplicationSerializer.\n\n  \n    \n      app/adapters/my-custom-adapter.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  defaultSerializer: '-default'\n});\n\n\nCommunity Adapters\nIf none of the builtin Ember Data Adapters work for your backend,\nbe sure to check out some of the community maintained Ember Data\nAdapters. Some good places to look for Ember Data Adapters include:\n\n\nGitHub\nBower\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"03e86bc5333f6f64b9e95b540f952f9d","fields":[{"name":"title","value":"Defining Models","type":"string"},{"name":"url","value":"/models/defining-models/","type":"enum"},{"name":"body","value":"A model is a class that defines the properties and behavior of the\ndata that you present to the user. Anything that the user expects to see\nif they leave your app and come back later (or if they refresh the page)\nshould be represented by a model.\n\nMake sure to include ember-data.js after ember.js\n\n  1\n2\n\n  \u003cscript type=\"text/javascript\" src=\"ember.js\"\u003e\u003c/script\u003e\n\u003cscript type=\"text/javascript\" src=\"ember-data.js\"\u003e\u003c/script\u003e\n\n\n\nFor every model in your application, create a subclass of DS.Model:\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n\n  export default DS.Model.extend();\n\n\n\nAfter you have defined a model class, you can start finding and creating\nrecords of that type. When interacting with the store, you will need to\nspecify a record's type using the model name. For example, the store's\nfind() method expects a string as the first argument to tell it what\ntype of record to find:\n\n  1\n\n  store.find('person', 1);\n\n\n\nThe table below shows how model names map to model file paths.\n\n\n  \n  \n    Model Name\n    Model Class\n  \n  \n  \n    photo\n    app/models/photo.js\n  \n  \n    admin-user-profile\n    app/models/admin-user-profile.js\n  \n\nDefining Attributes\nYou can specify which attributes a model has by using DS.attr.\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.Model.extend({\n  firstName: DS.attr(),\n  lastName: DS.attr(),\n  birthday: DS.attr()\n});\n\n\n\nAttributes are used when turning the JSON payload returned from your\nserver into a record, and when serializing a record to save back to the\nserver after it has been modified.\n\nYou can use attributes just like any other property, including as part of a\ncomputed property. Frequently, you will want to define computed\nproperties that combine or transform primitive attributes.\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default DS.Model.extend({\n  firstName: DS.attr(),\n  lastName: DS.attr(),\n\n  fullName: function() {\n    return this.get('firstName') + ' ' + this.get('lastName');\n  }.property('firstName', 'lastName')\n});\n\n\n\nFor more about adding computed properties to your classes, see Computed\nProperties.\n\nIf you don't specify the type of the attribute, it will be whatever was\nprovided by the server. You can make sure that an attribute is always\ncoerced into a particular type by passing a type to attr:\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  birthday: DS.attr('date')\n});\n\n\n\nThe default adapter supports attribute types of string,\nnumber, boolean, and date. Custom adapters may offer additional\nattribute types, and new types can be registered as transforms. See the\ndocumentation section on the REST Adapter.\n\nPlease note: Ember Data serializes and deserializes dates according to\n                 ISO 8601. For example: 2014-05-27T12:54:01\nOptions\nDS.attr takes an optional hash as a second parameter:\n\n\ndefaultValue: Pass a string or a function to be called to set the\n              attribute to a default value if none is supplied.\n\n\nExample\n\n  \n    \n      app/models/user.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n    export default DS.Model.extend({\n      username: DS.attr('string'),\n      email: DS.attr('string'),\n      verified: DS.attr('boolean', {defaultValue: false}),\n      createdAt: DS.attr('string', {\n          defaultValue: function() { return new Date(); }\n      })\n  });\n\n\nDefining Relationships\nEmber Data includes several built-in relationship types to help you\ndefine how your models relate to each other.\nOne-to-One\nTo declare a one-to-one relationship between two models, use\nDS.belongsTo:\n\n  \n    \n      app/models/user.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  profile: DS.belongsTo('profile')\n});\n\n\n\n  \n    \n      app/models/profile.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  user: DS.belongsTo('user')\n});\n\n\nOne-to-Many\nTo declare a one-to-many relationship between two models, use\nDS.belongsTo in combination with DS.hasMany, like this:\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  comments: DS.hasMany('comment')\n});\n\n\n\n  \n    \n      app/models/comment.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  post: DS.belongsTo('post')\n});\n\n\nMany-to-Many\nTo declare a many-to-many relationship between two models, use\nDS.hasMany:\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  tags: DS.hasMany('tag')\n});\n\n\n\n  \n    \n      app/models/tag.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  posts: DS.hasMany('post')\n});\n\n\nExplicit Inverses\nEmber Data will do its best to discover which relationships map to one\nanother. In the one-to-many code above, for example, Ember Data can figure out that\nchanging the comments relationship should update the post\nrelationship on the inverse because post is the only relationship to\nthat model.\n\nHowever, sometimes you may have multiple belongsTo/hasManys for the\nsame type. You can specify which property on the related model is the\ninverse using DS.hasMany's inverse option:\n\n  \n    \n      app/models/comment.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default DS.Model.extend({\n  onePost: DS.belongsTo('post'),\n  twoPost: DS.belongsTo('post'),\n  redPost: DS.belongsTo('post'),\n  bluePost: DS.belongsTo('post')\n});\n\n\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.Model.extend({\n  comments: DS.hasMany('comment', {\n    inverse: 'redPost'\n  })\n});\n\n\n\nYou can also specify an inverse on a belongsTo, which works how you'd expect.\nReflexive relation\nWhen you want to define a reflexive relation, you must either explicitly define\nthe other side, and set the explicit inverse accordingly, and if you don't need the\nother side, set the inverse to null.\n\n  \n    \n      app/models/folder.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default DS.Model.extend({\n  children: DS.hasMany('folder', { inverse: 'parent' }),\n  parent: DS.belongsTo('folder', { inverse: 'children' })\n});\n\n\n\nor\n\n  \n    \n      app/models/folder.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  parent: belongsTo('folder', { inverse: null })\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"54352571d5fd6e786972f119be9dcf80","fields":[{"name":"title","value":"Finding Records","type":"string"},{"name":"url","value":"/models/finding-records/","type":"enum"},{"name":"body","value":"The Ember Data store provides a simple interface for finding records of a single\ntype through the store object's find method. Internally, the store\nuses find, findAll, and findQuery based on the supplied arguments.\n\nThe first argument to store.find() is always the record type. The optional second\nargument determines if a request is made for all records, a single record, or a query.\nFinding All Records of a Type\n  1\n\n  var posts = this.store.find('post'); // =\u003e GET /posts\n\n\n\nTo get a list of records already loaded into the store, without making\nanother network request, use all instead.\n\n  1\n\n  var posts = this.store.all('post'); // =\u003e no network request\n\n\n\nfind returns a DS.PromiseArray that fulfills to a DS.RecordArray and all\ndirectly returns a DS.RecordArray.\n\nIt's important to note that DS.RecordArray is not a JavaScript array.\nIt is an object that implements Ember.Enumerable. This is important\nbecause, for example, if you want to retrieve records by index, the [] notation\nwill not work--you'll have to use objectAt(index) instead.\nFinding a Single Record\nIf you provide a number or string as the second argument to store.find(),\nEmber Data will assume that you are passing in an ID and attempt to retrieve a record of the type passed in as the first argument with that ID. This will\nreturn a promise that fulfills with the requested record:\n\n  1\n\n  var aSinglePost = this.store.find('post', 1); // =\u003e GET /posts/1\n\n\nQuerying For Records\nIf you provide a plain object as the second argument to find, Ember Data will\nmake a GET request with the object serialized as query params. This method returns\nDS.PromiseArray in the same way as find with no second argument.\n\nFor example, we could search for all person models who have the name of\nPeter:\n\n  1\n\n  var peters = this.store.find('person', { name: \"Peter\" }); // =\u003e GET to /persons?name=Peter\n\n\nIntegrating with the Route's Model Hook\nAs discussed in Specifying a Route's Model, routes are\nresponsible for telling their template which model to render.\n\nEmber.Route's model hook supports asynchronous values\nout-of-the-box. If you return a promise from the model hook, the\nrouter will wait until the promise has fulfilled to render the\ntemplate.\n\nThis makes it easy to write apps with asynchronous data using Ember\nData. Just return the requested record from the model hook, and let\nEmber deal with figuring out whether a network request is needed or not.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  var Router = Ember.Router.extend({});\n\nRouter.map(function() {\n  this.route('posts');\n  this.route('post', { path: ':post_id' });\n});\n\nexport default Router;\n\n\n\n  \n    \n      app/routes/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model: function() {\n    return this.store.find('post');\n  }\n});\n\n\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model: function(params) {\n    return this.store.find('post', params.post_id);\n  }\n})\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6bd56e65140b54329f607d71ebd61f85","fields":[{"name":"title","value":"Frequently Asked Questions","type":"string"},{"name":"url","value":"/models/frequently-asked-questions/","type":"enum"},{"name":"body","value":"Should I use a query or a filter to search records?\nIt depends on how many records you want to search and whether they have\nbeen loaded into the store.\n\nQueries are useful for doing searches of hundreds, thousands, or even\nmillions of records. You just hand the search options to your server,\nand it is responsible for handing you back the list of records that\nmatch. Because the response from the server includes the ID of all of\nthe records that matched, it doesn't matter if the store hadn't loaded\nthem previously; it sees that they are not in the cache and can request\nthe records by ID if necessary.\n\nThe downside of queries is that they do not live update, they are\nslower, and they require that your server support the kind of queries\nthat you wish to perform.\n\nBecause the server decides which records match the query, not the store,\nqueries do not live update. If you want to update them, you must\nmanually call reload() and wait for the server to respond. If you\ncreate a new record on the client, it will not show up in the results\nuntil you both save the new record to the server and reload the query\nresults.\n\nBecause the store must confer with your server to determine the results\nof a query, it necessitates a network request. This can feel slow to\nusers, especially if they are on a slow connection or your server is\nslow to respond. The typical speed of JavaScript web applications can\nheighten the perceived slowness when the server must be consulted.\n\nLastly, performing queries requires collaboration between the store and\nyour server. By default, Ember Data will send the search options that\nyou pass as the body of an HTTP request to your server. If your server\ndoes not support requests in this format, you will need to either change\nyour server to do so, or customize how queries are sent by creating a\ncustom adapter.\n\nFilters, on the other hand, perform a live search of all of the records\nin the store's cache. As soon as a new record is loaded into the store,\nthe filter will check to see if the record matches, and if so, add it to\nthe array of search results. If that array is displayed in a template,\nit will update automatically.\n\nFilters also take into account newly created records that have not been\nsaved, and records that have been modified but not yet saved. If you\nwant records to show up in search results as soon as they are created or\nmodified on the client, you should use a filter.\n\nKeep in mind that records will not show up in a filter if the store\ndoesn't know about them. You can ensure that a record is in the store by\nusing the store's push() method.\n\nThere is also a limit to how many records you can reasonably keep in\nmemory and search before you start hitting performance issues.\n\nFinally, keep in mind that you can combine queries and filters to take\nadvantage of their respective strengths and weaknesses. Remember that\nrecords returned by a query to the server are cached in the store. You\ncan use this fact to perform a filter, passing it a query that starts\nmatching records into the store, and a filter function that matches the\nsame records.\n\nThis will offload searching all of the possible records to the server,\nwhile still creating a live updating list that includes records created\nand modified on the client.\n\n  \n    \n      app/routes/posts/favourited.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export default Ember.Route.extend({\n  model: function() {\n    var store = this.store;\n\n    // Create a filter for all favorited posts that will be displayed in\n    // the template. Any favorited posts that are already in the store\n    // will be displayed immediately;\n    // Kick off a query to the server for all posts that\n    // the user has favorited. As results from the query are\n    // returned from the server, they will also begin to appear.\n    return store.filter('post', { favorited: true }, function(post) {\n      return post.get('isFavorited');\n    });\n  }\n});\n\n\nHow do I inform Ember Data about new records created on the backend?\nWhen you request a record using Ember Data's store.find method, Ember\nwill automatically load the data into the store. This allows Ember to\navoid the latency of making a round trip to the backend next time\nthat record is requested. Additionally, loading a record into the\nstore will update any RecordArrays (e.g. the result of\nstore.filter or store.all) that should include that record. This\nmeans any data bindings or computed properties that depend on the\nRecordArray will automatically be synced to include the new or\nupdated record values.\n\nSome applications may want to add or update records in the store\nwithout requesting the record via store.find. To accomplish this you\ncan use the DS.Store's push or pushPayload\nmethods. This is useful for web applications that have a channel\n(such as SSE or\nWeb Sockets) to\nnotify it of new or updated records on the backend.\n\npush\nis the simplest way to load or update records in Ember Data's store.\nWhen using push it is important to\nnormalize\nthe JSON object before pushing it into the store.\n\npush only accepts one record at a time. If you would like to load an\narray of records to the store you can call\npushMany.\n\n  1\n2\n3\n4\n\n  socket.on('message', function (message) {\n  var modelName = message.model;\n  store.push(modelName, store.normalize(modelName, message.data));\n});\n\n\n\nAs of v1.0.0-beta.14 the push method accepts partial attributes for\nupdating existing records. The update method is therefore deprecated.\nUpdating partial attributes is useful if your web application only\nreceives notifications of the changed attributes on a model.\n\npushPayload\nis a convenience wrapper for store#push that will deserialize\npayloads if the model's Serializer implements a pushPayload\nmethod. It is important to note this method will not work with the\nJSONSerializer because it does not implement a pushPayload\nmethod.\n\n  1\n2\n3\n\n  socket.on('message', function (message) {\n  store.pushPayload(message.model, message.data);\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"aaa673b0a07a7fad8549b3be79862344","fields":[{"name":"title","value":"Handling Metadata","type":"string"},{"name":"url","value":"/models/handling-metadata/","type":"enum"},{"name":"body","value":"Along with the records returned from your store, you'll likely need to handle some kind of metadata. Metadata is data that goes along with a specific model or type instead of a record.\n\nPagination is a common example of using metadata. Imagine a blog with far more posts than you can display at once. You might query it like so:\n\n  1\n2\n3\n4\n\n  var result = this.store.find(\"post\", {\n  limit: 10,\n  offset: 0\n});\n\n\n\nTo get different pages of data, you'd simply change your offset in increments of 10. So far, so good. But how do you know how many pages of data you have? Your server would need to return the total number of records as a piece of metadata.\n\nBy default, Ember Data's JSON deserializer looks for a meta key:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  {\n  \"post\": {\n    \"id\": 1,\n    \"title\": \"Progressive Enhancement is Dead\",\n    \"comments\": [\"1\", \"2\"],\n    \"links\": {\n      \"user\": \"/people/tomdale\"\n    },\n    // ...\n  },\n\n  \"meta\": {\n    \"total\": 100\n  }\n}\n\n\n\nThe metadata for a specific type is then set to the contents of meta. You can access it either with store.metadataFor, which is updated any time any query is made against the same type:\n\n  1\n\n  var meta = this.store.metadataFor(\"post\");\n\n\n\nOr you can access the metadata just for this query:\n\n  1\n\n  var meta = result.get(\"content.meta\");\n\n\n\nNow, meta.total can be used to calculate how many pages of posts you'll have.\n\nYou can also customize metadata extraction by overriding the extractMeta method. For example, if instead of a meta object, your server simply returned:\n\n  1\n2\n3\n4\n5\n6\n\n  {\n  \"post\": [\n    // ...\n  ],\n  \"total\": 100\n}\n\n\n\nYou could extract it like so:\n\n  \n    \n      app/serializers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default DS.RESTSerializer.extend({\n  extractMeta: function(store, type, payload) {\n    if (payload \u0026\u0026 payload.total) {\n      store.setMetadataFor(type, { total: payload.total });  // sets the metadata for \"post\"\n      delete payload.total;  // keeps ember data from trying to parse \"total\" as a record\n    }\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f6824ed2e6c9f37fc0a6d7f987afee17","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/models/","type":"enum"},{"name":"body","value":"Models\nIn Ember, every route has an associated model. This model is set by\nimplementing a route's model hook, by passing the model as an argument\nto {{link-to}}, or by calling a route's transitionTo() method.\n\nSee Specifying a Route's\nModel for more information\non setting a route's model.\n\nFor simple applications, you can get by using jQuery to load JSON data\nfrom a server, then use those JSON objects as models.\n\nHowever, using a model library that manages finding models, making\nchanges, and saving them back to the server can dramatically simplify\nyour code while improving the robustness and performance of your\napplication.\n\nMany Ember apps use Ember Data to handle this.\nEmber Data is a library that integrates tightly with Ember.js to make it\neasy to retrieve records from a server, cache them for performance,\nsave updates back to the server, and create new records on the client.\n\nWithout any configuration, Ember Data can load and save records and\ntheir relationships served via a RESTful JSON API, provided it follows\ncertain conventions.\n\nIf you need to integrate your Ember.js app with existing JSON APIs that\ndo not follow strong conventions, Ember Data is designed to be easily\nconfigurable to work with whatever data your server returns.\n\nEmber Data is also designed to work with streaming APIs like\nsocket.io, Firebase, or WebSockets. You can open a socket to your server\nand push changes to records into the store whenever they occur.\n\nCurrently, projects generated by ember-cli include Ember Data as a\ndependency in both package.json and bower.json. If you do not wish\nto use Ember Data, run the following command:\n\n  1\n\n  $ npm rm ember-data --save-dev\n\n\nCore Concepts\nLearning to use Ember Data is easiest once you understand some of the\nconcepts that underpin its design.\nStore\nThe store is the central repository of records in your application.\nYou can think of the store as a cache of all of the records available in\nyour app. Both your application's controllers and routes have access to this\nshared store; when they need to display or modify a record, they will\nfirst ask the store for it.\n\nThis instance of DS.Store is created for you automatically and is shared\namong all of the objects in your application.\n\nYou will use the store to retrieve records, as well to create new ones.\nFor example, we might want to find a person with the ID of\n1 from our route's model hook:\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model: function() {\n    return this.store.find('person', 1);\n  }\n});\n\n\nModels\nA model is a class that defines the properties and behavior of the\ndata that you present to the user. Anything that the user expects to see\nif they leave your app and come back later (or if they refresh the page)\nshould be represented by a model.\n\nFor example, if you were writing a web application for placing orders at\na restaurant, you might have models like order, line-item, and\nmenu-item.\n\nFetching orders becomes very easy:\n\n  1\n\n  this.store.find('order');\n\n\n\nModels define the type of data that will be provided by your server. For\nexample, a Person model might have a firstName attribute that is a\nstring, and a birthday attribute that is a date:\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default DS.Model.extend({\n  firstName: DS.attr('string'),\n  birthday:  DS.attr('date')\n});\n\n\n\nA model also describes its relationships with other objects. For\nexample, an order may have many line-items, and a\nline-item may belong to a particular order.\n\n  \n    \n      app/models/order.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  lineItems: DS.hasMany('lineItem')\n});\n\n\n\n  \n    \n      app/models/line-item.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  order: DS.belongsTo('order')\n});\n\n\n\nModels don't have any data themselves; they just define the properties and\nbehavior of specific instances, which are called records.\nRecords\nA record is an instance of a model that contains data loaded from a\nserver. Your application can also create new records and save them back\nto the server.\n\nA record is uniquely identified by its model type and id.\n\nFor example, if you were writing a contact management app, you might\nhave a person. An individual record in your app might\nhave a type of person and an ID of 1 or steve-buscemi.\n\n  1\n\n  this.store.find('person', 1); // =\u003e { id: 1, name: 'steve-buscemi' }\n\n\n\nIDs are usually assigned by the server when you save them for the first\ntime, but you can also generate IDs client-side.\nAdapter\nAn adapter is an object that knows about your particular server\nbackend and is responsible for translating requests for and changes to\nrecords into the appropriate calls to your server.\n\nFor example, if your application asks for a person record with an ID\nof 1, how should Ember Data load it? Is it over HTTP or a WebSocket?\nIf it's HTTP, is the URL /person/1 or /resources/people/1?\n\nThe adapter is responsible for answering all of these questions.\nWhenever your app asks the store for a record that it doesn't have\ncached, it will ask the adapter for it. If you change a record and save\nit, the store will hand the record to the adapter to send the\nappropriate data to your server and confirm that the save was\nsuccessful.\nSerializer\nA serializer is responsible for turning a raw JSON payload returned\nfrom your server into a record object.\n\nJSON APIs may represent attributes and relationships in many different\nways. For example, some attribute names may be camelCased and others\nmay be under_scored. Representing relationships is even more diverse:\nthey may be encoded as an array of IDs, an array of embedded objects, or\nas foreign keys.\n\nWhen the adapter gets a payload back for a particular record, it will\ngive that payload to the serializer to normalize into the form that\nEmber Data is expecting.\n\nWhile most people will use a serializer for normalizing JSON, because\nEmber Data treats these payloads as opaque objects, there's no reason\nthey couldn't be binary data stored in a Blob or\nArrayBuffer.\nAutomatic Caching\nThe store will automatically cache records for you. If a record had already\nbeen loaded, asking for it a second time will always return the same\nobject instance. This minimizes the number of round-trips to the\nserver, and allows your application to render its UI to the user as fast as\npossible.\n\nFor example, the first time your application asks the store for a\nperson record with an ID of 1, it will fetch that information from\nyour server.\n\nHowever, the next time your app asks for a person with ID 1, the\nstore will notice that it had already retrieved and cached that\ninformation from the server. Instead of sending another request for the\nsame information, it will give your application the same record it had\nprovided it the first time.  This featureâalways returning the same\nrecord object, no matter how many times you look it upâis sometimes\ncalled an identity map.\n\nUsing an identity map is important because it ensures that changes you\nmake in one part of your UI are propagated to other parts of the UI. It\nalso means that you don't have to manually keep records in syncâyou can\nask for a record by ID and not have to worry about whether other parts\nof your application have already asked for and loaded it.\nArchitecture Overview\nThe first time your application asks the store for a record, the store\nsees that it doesn't have a local copy and requests it from your\nadapter. Your adapter will go and retrieve the record from your\npersistence layer; typically, this will be a JSON representation of the\nrecord served from an HTTP server.\n\n\n\nAs illustrated in the diagram above, the adapter cannot always return the\nrequested record immediately. In this case, the adapter must make an\nasynchronous request to the server, and only when that request finishes\nloading can the record be created with its backing data.\n\nBecause of this asynchronicity, the store immediately returns a\npromise from the find() method. Similarly, any requests that the\nstore makes to the adapter also return promises.\n\nOnce the request to the server returns with a JSON payload for the\nrequested record, the adapter resolves the promise it returned to the\nstore with the JSON.\n\nThe store then takes that JSON, initializes the record with the\nJSON data, and resolves the promise returned to your application\nwith the newly-loaded record.\n\n\n\nLet's look at what happens if you request a record that the store\nalready has in its cache.\n\n\n\nIn this case, because the store already knew about the record, it\nreturns a promise that it resolves with the record immediately. It does\nnot need to ask the adapter (and, therefore, the server) for a copy\nsince it already has it saved locally.\n\n\n\nThese are the core concepts you should understand to get the most out of\nEmber Data. The following sections go into more depth about each of\nthese concepts, and how to use them together.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f5cbaf46432fb32d6be26a903d80a41c","fields":[{"name":"title","value":"Persisting Records","type":"string"},{"name":"url","value":"/models/persisting-records/","type":"enum"},{"name":"body","value":"Records in Ember Data are persisted on a per-instance basis.\nCall save() on any instance of DS.Model and it will make a network request.\n\nHere are a few examples:\n\n  1\n2\n3\n4\n5\n6\n\n  var post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\npost.save(); // =\u003e POST to '/posts'\n\n\n\n  1\n2\n3\n4\n5\n6\n7\n\n  store.find('post', 1).then(function (post) {\n  post.get('title'); // =\u003e \"Rails is Omakase\"\n\n  post.set('title', 'A new post');\n\n  post.save(); // =\u003e PUT to '/posts/1'\n});\n\n\nPromises\nsave() returns a promise, so it is extremely easy to handle success and failure scenarios.\n Here's a common pattern:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  var post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\nvar self = this;\n\nfunction transitionToPost(post) {\n  self.transitionToRoute('posts.show', post);\n}\n\nfunction failure(reason) {\n  // handle the error\n}\n\npost.save().then(transitionToPost).catch(failure);\n\n// =\u003e POST to '/posts'\n// =\u003e transitioning to posts.show route\n\n\n\nPromises even make it easy to work with failed network requests:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  var post = store.createRecord('post', {\n  title: 'Rails is Omakase',\n  body: 'Lorem ipsum'\n});\n\nvar self = this;\n\nvar onSuccess = function(post) {\n  self.transitionToRoute('posts.show', post);\n};\n\nvar onFail = function(post) {\n  // deal with the failure here\n};\n\npost.save().then(onSuccess, onFail);\n\n// =\u003e POST to '/posts'\n// =\u003e transitioning to posts.show route\n\n\n\nYou can read more about promises here, but here is another\nexample showing how to retry persisting:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  function retry(callback, nTimes) {\n  // if the promise fails\n  return callback().catch(function(reason) {\n    // if we haven't hit the retry limit\n    if (nTimes \u003e 0) {\n      // retry again with the result of calling the retry callback\n      // and the new retry limit\n      return retry(callback, nTimes);\n    }\n\n    // otherwise, if we hit the retry limit, rethrow the error\n    throw reason;\n  });\n}\n\n// try to save the post up to 5 times\nretry(function() {\n  return post.save();\n}, 5);\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"0638f122b19f3ca7e20eca12d526a2e6","fields":[{"name":"title","value":"Pushing Records into the Store","type":"string"},{"name":"url","value":"/models/pushing-records-into-the-store/","type":"enum"},{"name":"body","value":"One way to think about the store is as a cache of all of the records\nthat have been loaded by your application. If a route or a controller in\nyour app asks for a record, the store can return it immediately if it is\nin the cache. Otherwise, the store must ask the adapter to load it,\nwhich usually means a trip over the network to retrieve it from the\nserver.\n\nInstead of waiting for the app to request a record, however, you can\npush records into the store's cache ahead of time.\n\nThis is useful if you have a good sense of what records the user\nwill need next. When they click on a link, instead of waiting for a\nnetwork request to finish, Ember.js can render the new template\nimmediately. It feels instantaneous.\n\nAnother use case for pushing in records is if your application has a\nstreaming connection to a backend. If a record is created or modified,\nyou want to update the UI immediately.\nPushing Records\nTo push a record into the store, call the store's push() method.\n\nFor example, imagine we want to preload some data into the store when\nthe application boots for the first time.\n\nWe can use the route:application to do so. The route:application is\nthe top-most route in the route hierarchy, and its model hook gets\ncalled once when the app starts up.\n\n  \n    \n      app/models/album.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.Model.extend({\n  title: DS.attr(),\n  artist: DS.attr(),\n  songCount: DS.attr()\n});\n\n\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  export default Ember.Route.extend({\n  model: function() {\n    this.store.push('album', {\n      id: 1,\n      title: \"Fewer Moving Parts\",\n      artist: \"David Bazan\",\n      songCount: 10\n    });\n\n    this.store.push('album', {\n      id: 2,\n      title: \"Calgary b/w I Can't Make You Love Me/Nick Of Time\",\n      artist: \"Bon Iver\",\n      songCount: 2\n    });\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"0e991ff9ce7021b901869280c0615261","fields":[{"name":"title","value":"The Rest Adapter","type":"string"},{"name":"url","value":"/models/the-rest-adapter/","type":"enum"},{"name":"body","value":"By default, your store will use\nDS.RESTAdapter to load and\nsave records. The RESTAdapter assumes that the URLs and JSON\nassociated with each model are conventional; this means that, if you\nfollow the rules, you will not need to configure the adapter or write\nany code in order to get started.\nURL Conventions\nThe REST adapter is smart enough to determine the URLs it communicates\nwith based on the name of the model. For example, if you ask for a\nPost by ID:\n\n  1\n2\n\n  store.find('post', 1).then(function(post) {\n});\n\n\n\nThe REST adapter will automatically send a GET request to /posts/1.\n\nThe actions you can take on a record map onto the following URLs in the\nREST adapter:\n\n\n  \n    ActionHTTP VerbURL\n  \n  \n    FindGET/people/123\n    Find AllGET/people\n    UpdatePUT/people/123\n    CreatePOST/people\n    DeleteDELETE/people/123\n  \n\nPluralization Customization\nIrregular or uncountable pluralizations can be specified via Ember.Inflector.inflector:\n\n  1\n2\n3\n4\n\n  var inflector = Ember.Inflector.inflector;\n\ninflector.irregular('formula', 'formulae');\ninflector.uncountable('advice');\n\n\n\nThis will tell the REST adapter that requests for formula\nshould go to /formulae/1 instead of /formulas/1.\nEndpoint Path Customization\nEndpoint paths can be prefixed with a namespace by setting the namespace\nproperty on the adapter:\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  namespace: 'api/1'\n});\n\n\n\nRequests for person would now target http://emberjs.com/api/1/people/1.\nHost Customization\nAn adapter can target other hosts by setting the host property.\n\n  \n    \n      app/adapters/application.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.RESTAdapter.extend({\n  host: 'https://api.example.com'\n});\n\n\n\nRequests for person would now target https://api.example.com/people/1.\nJSON Conventions\nWhen requesting a record, the REST adapter expects your server to return\na JSON representation of the record that conforms to the following\nconventions.\nJSON Root\nThe primary record being returned should be in a named root. For\nexample, if you request a record from /people/123, the response should\nbe nested inside a property called person:\n\n  1\n2\n3\n4\n5\n6\n\n  {\n  \"person\": {\n    \"firstName\": \"Jeff\",\n    \"lastName\": \"Atwood\"\n  }\n}\n\n\n\nAfter destroyRecord or after deleteRecord and save, the adapter expects the server to return an empty object ({}).\n\nIf you don't have the option to change the data that the server responds with, you can override the \nDS.JSONSerializer#extractDeleteRecord, like so:\n\n  1\n2\n3\n4\n5\n\n  extractDeleteRecord: function(store, type, payload) {\n  // If the payload is {delete: true}, Ember Data will try to set\n  // the new properties. Return null so it doesn't try to do that.\n  return null;\n}\n\n\nAttribute Names\nAttribute names should be camelized.  For example, if you have a model like this:\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default DS.Model.extend({\n  firstName: DS.attr('string'),\n  lastName:  DS.attr('string'),\n\n  isPersonOfTheYear: DS.attr('boolean')\n});\n\n\n\nThe JSON returned from your server should look like this:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  {\n  \"person\": {\n    \"firstName\": \"Barack\",\n    \"lastName\": \"Obama\",\n    \"isPersonOfTheYear\": true\n  }\n}\n\n\n\nIrregular keys can be mapped with a custom serializer. If the JSON for\nperson has a key of lastNameOfPerson, and the desired\nattribute name is simply lastName, then create a custom Serializer\nfor the model and override the normalizeHash property.\n\n  \n    \n      app/models/person.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  lastName: DS.attr('string')\n});\n\n\n\n  \n    \n      app/serializers/person.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default DS.RESTSerializer.extend({\n  normalizeHash: {\n    lastNameOfPerson: function(hash) {\n      hash.lastName = hash.lastNameOfPerson;\n      delete hash.lastNameOfPerson;\n\n      return hash;\n    }\n  }\n});\n\n\nRelationships\nReferences to other records should be done by ID. For example, if you\nhave a model with a hasMany relationship:\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  comments: DS.hasMany('comment', { async: true })\n});\n\n\n\nThe JSON should encode the relationship as an array of IDs:\n\n  1\n2\n3\n4\n5\n\n  {\n  \"post\": {\n    \"comments\": [1, 2, 3]\n  }\n}\n\n\n\nComments for a post can be loaded by post.get('comments'). The REST adapter\nwill send a GET request to /comments?ids[]=1\u0026ids[]=2\u0026ids[]=3.\n\nAny belongsTo relationships in the JSON representation should be the\ncamelized version of the Ember Data model's name. For example, if you have\na model:\n\n  \n    \n      app/models/comment.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  post: DS.belongsTo('post')\n});\n\n\n\nThe JSON should encode the relationship as an ID to another record:\n\n  1\n2\n3\n4\n5\n\n  {\n  \"comment\": {\n    \"post\": 1\n  }\n}\n\n\n\nIf needed these naming conventions can be overwritten by implementing\nthe keyForRelationship method.\n\n  \n    \n      app/serializers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default DS.RESTSerializer.extend({\n  keyForRelationship: function(key, relationship) {\n    return key + 'Ids';\n  }\n});\n\n\nSideloaded Relationships\nTo reduce the number of HTTP requests necessary, you can sideload\nadditional records in your JSON response. Sideloaded records live\noutside the JSON root, and are represented as an array of hashes:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  {\n  \"post\": {\n    \"id\": 1,\n    \"title\": \"Node is not omakase\",\n    \"comments\": [1, 2, 3]\n  },\n\n  \"comments\": [{\n    \"id\": 1,\n    \"body\": \"But is it _lightweight_ omakase?\"\n  },\n  {\n    \"id\": 2,\n    \"body\": \"I for one welcome our new omakase overlords\"\n  },\n  {\n    \"id\": 3,\n    \"body\": \"Put me on the fast track to a delicious dinner\"\n  }]\n}\n\n\nCreating Custom Transformations\nIn some circumstances, the built in attribute types of string,\nnumber, boolean, and date may be inadequate. For example, a\nserver may return a non-standard date format.\n\nEmber Data can have new JSON transforms\nregistered for use as attributes:\n\n  \n    \n      app/transforms/coordinate-point.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default DS.Transform.extend({\n  serialize: function(value) {\n    return [value.get('x'), value.get('y')];\n  },\n  deserialize: function(value) {\n    return Ember.create({ x: value[0], y: value[1] });\n  }\n});\n\n\n\n  \n    \n      app/models/cursor.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  position: DS.attr('coordinatePoint')\n});\n\n\n\nWhen coordinatePoint is received from the API, it is\nexpected to be an array:\n\n  1\n2\n3\n4\n5\n\n  {\n  cursor: {\n    position: [4,9]\n  }\n}\n\n\n\nBut once loaded on a model instance, it will behave as an object:\n\n  1\n2\n3\n\n  var cursor = App.Cursor.find(1);\ncursor.get('position.x'); //=\u003e 4\ncursor.get('position.y'); //=\u003e 9\n\n\n\nIf position is modified and saved, it will pass through the\nserialize function in the transform and again be presented as\nan array in JSON.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"3701fefea474dad678c5fecd87312b01","fields":[{"name":"title","value":"Working with Records","type":"string"},{"name":"url","value":"/models/working-with-records/","type":"enum"},{"name":"body","value":"Modifying Attributes\nOnce a record has been loaded, you can begin making changes to its\nattributes. Attributes behave just like normal properties in Ember.js\nobjects. Making changes is as simple as setting the attribute you\nwant to change:\n\n  1\n2\n3\n\n  var tyrion = this.store.find('person', 1);\n// ...after the record has loaded\ntyrion.set('firstName', \"Yollo\");\n\n\n\nAll of the Ember.js conveniences are available for\nmodifying attributes. For example, you can use Ember.Object's\nincrementProperty helper:\n\n  1\n\n  person.incrementProperty('age'); // Happy birthday!\n\n\n\nYou can tell if a record has outstanding changes that have not yet been\nsaved by checking its isDirty property. You can also see what parts of\nthe record were changed and what the original value was using the\nchangedAttributes function.  changedAttributes returns an object,\nwhose keys are the changed properties and values are an array of values\n[oldValue, newValue].\n\n  1\n2\n3\n4\n5\n\n  person.get('isAdmin');      //=\u003e false\nperson.get('isDirty');      //=\u003e false\nperson.set('isAdmin', true);\nperson.get('isDirty');      //=\u003e true\nperson.changedAttributes(); //=\u003e { isAdmin: [false, true] }\n\n\n\nAt this point, you can either persist your changes via save() or you\ncan rollback your changes. Calling rollback() reverts all the\nchangedAttributes to their original value.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  person.get('isDirty');      //=\u003e true\nperson.changedAttributes(); //=\u003e { isAdmin: [false, true] }\n\nperson.rollback();\n\nperson.get('isDirty');      //=\u003e false\nperson.get('isAdmin');      //=\u003e false\nperson.changedAttributes(); //=\u003e {}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"7bdaf101518cf52ad2c7b8a7eb71a128","fields":[{"name":"title","value":"Bindings","type":"string"},{"name":"url","value":"/object-model/bindings/","type":"enum"},{"name":"body","value":"A binding creates a link between two properties such that when one changes, the\nother one is updated to the new value automatically. Bindings can connect\nproperties on the same object, or across two different objects. Unlike most other\nframeworks that include some sort of binding implementation, bindings in\nEmber.js can be used with any object, not just between views and models.\n\nThe easiest way to create a two-way binding is to use a computed alias, that\nspecifies the path to another object.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  wife = Ember.Object.create({\n  householdIncome: 80000\n});\n\nHusband = Ember.Object.extend({\n  householdIncome: Ember.computed.alias('wife.householdIncome')\n});\n\nhusband = Husband.create({\n  wife: wife\n});\n\nhusband.get('householdIncome'); // 80000\n\n// Someone gets raise.\nhusband.set('householdIncome', 90000);\nwife.get('householdIncome'); // 90000\n\n\n\nNote that bindings don't update immediately. Ember waits until all of your\napplication code has finished running before synchronizing changes, so you can\nchange a bound property as many times as you'd like without worrying about the\noverhead of syncing bindings when values are transient.\nOne-Way Bindings\nA one-way binding only propagates changes in one direction. Often, one-way\nbindings are just a performance optimization and you can safely use a two-way binding\n(as, of course, two-way bindings are de facto one-way bindings if you only ever change\none side). Sometimes one-way bindings are useful to achieve specific behaviour such\nas a default that is the same as another property but can be overridden (e.g. a\nshipping address that starts the same as a billing address but can later be changed)\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n  user = Ember.Object.create({\n  fullName: \"Kara Gates\"\n});\n\nUserView = Ember.View.extend({\n  userName: Ember.computed.oneWay('user.fullName')\n});\n\nuserView = UserView.create({\n  user: user\n});\n\n// Changing the name of the user object changes\n// the value on the view.\nuser.set('fullName', \"Krang Gates\");\n// userView.userName will become \"Krang Gates\"\n\n// ...but changes to the view don't make it back to\n// the object.\nuserView.set('userName', \"Truckasaurus Gates\");\nuser.get('fullName'); // \"Krang Gates\"\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4eb2fcd4e32d72e009d1c1d9fdceee41","fields":[{"name":"title","value":"Classes and Instances","type":"string"},{"name":"url","value":"/object-model/classes-and-instances/","type":"enum"},{"name":"body","value":"Defining Classes\nTo define a new Ember class, call the extend() method on\nEmber.Object:\n\n  1\n2\n3\n4\n5\n\n  Person = Ember.Object.extend({\n  say: function(thing) {\n    alert(thing);\n  }\n});\n\n\n\nThis defines a new Person class with a say() method.\n\nYou can also create a subclass from any existing class by calling\nits extend() method. For example, you might want to create a subclass\nof Ember's built-in Ember.View class:\n\n  \n    \n      app/views/person.js\n    \n  \n\n  1\n2\n3\n4\n\n  PersonView = Ember.View.extend({\n  tagName: 'li',\n  classNameBindings: ['isAdministrator']\n});\n\n\n\nWhen defining a subclass, you can override methods but still access the\nimplementation of your parent class by calling the special _super()\nmethod:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  Person = Ember.Object.extend({\n  say: function(thing) {\n    var name = this.get('name');\n    alert(name + \" says: \" + thing);\n  }\n});\n\nSoldier = Person.extend({\n  say: function(thing) {\n    this._super(thing + \", sir!\");\n  }\n});\n\nvar yehuda = Soldier.create({\n  name: \"Yehuda Katz\"\n});\n\nyehuda.say(\"Yes\"); // alerts \"Yehuda Katz says: Yes, sir!\"\n\n\nCreating Instances\nOnce you have defined a class, you can create new instances of that\nclass by calling its create() method. Any methods, properties and\ncomputed properties you defined on the class will be available to\ninstances:\n\n  1\n2\n\n  var person = Person.create();\nperson.say(\"Hello\"); // alerts \" says: Hello\"\n\n\n\nWhen creating an instance, you can initialize the values of its properties\nby passing an optional hash to the create() method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  Person = Ember.Object.extend({\n  helloWorld: function() {\n    alert(\"Hi, my name is \" + this.get('name'));\n  }\n});\n\nvar tom = Person.create({\n  name: \"Tom Dale\"\n});\n\ntom.helloWorld(); // alerts \"Hi, my name is Tom Dale\"\n\n\n\nFor performance reasons, note that you cannot redefine an instance's\ncomputed properties or methods when calling create(), nor can you\ndefine new ones. You should only set simple properties when calling\ncreate(). If you need to define or redefine methods or computed\nproperties, create a new subclass and instantiate that.\n\nBy convention, properties or variables that hold classes are\nPascalCased, while instances are not. So, for example, the variable\nPerson would point to a class, while person would point to an instance\n(usually of the Person class). You should stick to these naming\nconventions in your Ember applications.\nInitializing Instances\nWhen a new instance is created, its init method is invoked\nautomatically. This is the ideal place to do setup required on new\ninstances:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  Person = Ember.Object.extend({\n  init: function() {\n    var name = this.get('name');\n    alert(name + \", reporting for duty!\");\n  }\n});\n\nPerson.create({\n  name: \"Stefan Penner\"\n});\n\n// alerts \"Stefan Penner, reporting for duty!\"\n\n\n\nIf you are subclassing a framework class, like Ember.View or\nEmber.ArrayController, and you override the init method, make sure\nyou call this._super()! If you don't, the system may not have an\nopportunity to do important setup work, and you'll see strange behavior\nin your application.\nAccessing Object Properties\nWhen accessing the properties of an object, use the get\nand set accessor methods:\n\n  1\n2\n3\n4\n\n  var person = Person.create();\n\nvar name = person.get('name');\nperson.set('name', \"Tobias FÃ¼nke\");\n\n\n\nMake sure to use these accessor methods; otherwise, computed properties won't\nrecalculate, observers won't fire, and templates won't update.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e959824557e508bda4cb824e0466f1ac","fields":[{"name":"title","value":"Computed Properties and Aggregate Data with @each","type":"string"},{"name":"url","value":"/object-model/computed-properties-and-aggregate-data/","type":"enum"},{"name":"body","value":"Often, you may have a computed property that relies on all of the items in an\narray to determine its value. For example, you may want to count all of the\ntodo items in a controller to determine how many of them are completed.\n\nHere's what that computed property might look like:\n\n  \n    \n      app/controllers/todos.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Controller.extend({\n  todos: [\n    Ember.Object.create({ isDone: true }),\n    Ember.Object.create({ isDone: false }),\n    Ember.Object.create({ isDone: true })\n  ],\n\n  remaining: function() {\n    var todos = this.get('todos');\n    return todos.filterBy('isDone', false).get('length');\n  }.property('todos.@each.isDone')\n});\n\n\n\nNote here that the dependent key (todos.@each.isDone) contains the special\nkey @each. This instructs Ember.js to update bindings and fire observers for\nthis computed property when one of the following four events occurs:\n\n\nThe isDone property of any of the objects in the todos array changes.\nAn item is added to the todos array.\nAn item is removed from the todos array.\nThe todos property of the controller is changed to a different array.\n\n\nIn the example above, the remaining count is 1:\n\n  1\n2\n3\n4\n\n  import TodosController from 'app/controllers/todos';\ntodosController = TodosController.create();\ntodosController.get('remaining');\n// 1\n\n\n\nIf we change the todo's isDone property, the remaining property is updated\nautomatically:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  var todos = todosController.get('todos');\nvar todo = todos.objectAt(1);\ntodo.set('isDone', true);\n\ntodosController.get('remaining');\n// 0\n\ntodo = Ember.Object.create({ isDone: false });\ntodos.pushObject(todo);\n\ntodosController.get('remaining');\n// 1\n\n\n\nNote that @each only works one level deep. You cannot use nested forms like\ntodos.@each.owner.name or todos.@each.owner.@each.name.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a26ec310640ced8b722a53a9ac4a703a","fields":[{"name":"title","value":"Computed Properties","type":"string"},{"name":"url","value":"/object-model/computed-properties/","type":"enum"},{"name":"body","value":"What are Computed Properties?\nIn a nutshell, computed properties let you declare functions as properties. You create one by defining a computed property as a function, which Ember will automatically call when you ask for the property. You can then use it the same way you would any normal, static property.\n\nIt's super handy for taking one or more normal properties and transforming or manipulating their data to create a new value. \nComputed properties in action\nWe'll start with a simple example:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  Person = Ember.Object.extend({\n  // these will be supplied by `create`\n  firstName: null,\n  lastName: null,\n\n  fullName: function() {\n    return this.get('firstName') + ' ' + this.get('lastName');\n  }.property('firstName', 'lastName')\n});\n\nvar ironMan = Person.create({\n  firstName: \"Tony\",\n  lastName:  \"Stark\"\n});\n\nironMan.get('fullName'); // \"Tony Stark\"\n\n\n\nNotice that the fullName function calls property. This declares the function to be a computed property, and the arguments tell Ember that it depends on the firstName and lastName attributes.\n\nWhenever you access the fullName property, this function gets called, and it returns the value of the function, which simply calls firstName + lastName.\nAlternate invocation\nAt this point, you might be wondering how you are able to call the .property function on a function.  This is possible because Ember extends the function prototype.  More information about extending native prototypes is available in the disabling prototype extensions guide. If you'd like to replicate the declaration from above without using these extensions you could do so with the following:\n\n  1\n2\n3\n\n    fullName: Ember.computed('firstName', 'lastName', function() {\n    return this.get('firstName') + ' ' + this.get('lastName');\n  })\n\n\nChaining computed properties\nYou can use computed properties as values to create new computed properties. Let's add a description computed property to the previous example, and use the existing fullName property and add in some other properties:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n  Person = Ember.Object.extend({\n  firstName: null,\n  lastName: null,\n  age: null,\n  country: null,\n\n  fullName: function() {\n    return this.get('firstName') + ' ' + this.get('lastName');\n  }.property('firstName', 'lastName'),\n\n  description: function() {\n    return this.get('fullName') + '; Age: ' + this.get('age') + '; Country: ' + this.get('country');\n  }.property('fullName', 'age', 'country')\n});\n\nvar captainAmerica = Person.create({\n  firstName: 'Steve',\n  lastName: 'Rogers',\n  age: 80,\n  country: 'USA'\n});\n\ncaptainAmerica.get('description'); // \"Steve Rogers; Age: 80; Country: USA\"\n\n\nDynamic updating\nComputed properties, by default, observe any changes made to the properties they depend on and are dynamically updated when they're called. Let's use computed properties to dynamically update. \n\n  1\n2\n3\n\n  captainAmerica.set('firstName', 'William');\n\ncaptainAmerica.get('description'); // \"William Rogers; Age: 80; Country: USA\"\n\n\n\nSo this change to firstName was observed by fullName computed property, which was itself observed by the description property.\n\nSetting any dependent property will propagate changes through any computed properties that depend on them, all the way down the chain of computed properties you've created.\nSetting Computed Properties\nYou can also define what Ember should do when setting a computed property. If you try to set a computed property, it will be invoked with the key (property name), the value you want to set it to, and the previous value.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n  Person = Ember.Object.extend({\n  firstName: null,\n  lastName: null,\n\n  fullName: function(key, value, previousValue) {\n    // setter\n    if (arguments.length \u003e 1) {\n      var nameParts = value.split(/\\s+/);\n      this.set('firstName', nameParts[0]);\n      this.set('lastName',  nameParts[1]);\n    }\n\n    // getter\n    return this.get('firstName') + ' ' + this.get('lastName');\n  }.property('firstName', 'lastName')\n});\n\n\nvar captainAmerica = Person.create();\ncaptainAmerica.set('fullName', \"William Burnside\");\ncaptainAmerica.get('firstName'); // William\ncaptainAmerica.get('lastName'); // Burnside\n\n\n\nEmber will call the computed property for both setters and getters, so if you want to use a computed property as a setter, you'll need to check the number of arguments to determine whether it is being called as a getter or a setter. Note that if a value is returned from the setter, it will be cached as the propertyâs value.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2899adf50b491f36747129255557b93d","fields":[{"name":"title","value":"Observers","type":"string"},{"name":"url","value":"/object-model/observers/","type":"enum"},{"name":"body","value":"Ember supports observing any property, including computed properties.\nYou can set up an observer on an object by using the observes\nmethod on a function:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n  Person = Ember.Object.extend({\n  // these will be supplied by `create`\n  firstName: null,\n  lastName: null,\n\n  fullName: function() {\n    var firstName = this.get('firstName');\n    var lastName = this.get('lastName');\n\n    return firstName + ' ' + lastName;\n  }.property('firstName', 'lastName'),\n\n  fullNameChanged: function() {\n    // deal with the change\n  }.observes('fullName').on('init')\n});\n\nvar person = Person.create({\n  firstName: 'Yehuda',\n  lastName: 'Katz'\n});\n\nperson.set('firstName', 'Brohuda'); // observer will fire\n\n\n\nBecause the fullName computed property depends on firstName,\nupdating firstName will fire observers on fullName as well.\nObservers and asynchrony\nObservers in Ember are currently synchronous. This means that they will fire\nas soon as one of the properties they observe changes. Because of this, it\nis easy to introduce bugs where properties are not yet synchronized:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  Person.reopen({\n  lastNameChanged: function() {\n    // The observer depends on lastName and so does fullName. Because observers\n    // are synchronous, when this function is called the value of fullName is\n    // not updated yet so this will log the old value of fullName\n    console.log(this.get('fullName'));\n  }.observes('lastName')\n});\n\n\n\nThis synchronous behaviour can also lead to observers being fired multiple\ntimes when observing multiple properties:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  Person.reopen({\n  partOfNameChanged: function() {\n    // Because both firstName and lastName were set, this observer will fire twice.\n  }.observes('firstName', 'lastName')\n});\n\nperson.set('firstName', 'John');\nperson.set('lastName', 'Smith');\n\n\n\nTo get around these problems, you should make use of Ember.run.once. This will\nensure that any processing you need to do only happens once, and happens in the\nnext run loop once all bindings are synchronized:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  Person.reopen({\n  partOfNameChanged: function() {\n    Ember.run.once(this, 'processFullName');\n  }.observes('firstName', 'lastName'),\n\n  processFullName: function() {\n    // This will only fire once if you set two properties at the same time, and\n    // will also happen in the next run loop once all properties are synchronized\n    console.log(this.get('fullName'));\n  }\n});\n\nperson.set('firstName', 'John');\nperson.set('lastName', 'Smith');\n\n\nObservers and object initialization\nObservers never fire until after the initialization of an object is complete.\n\nIf you need an observer to fire as part of the initialization process, you\ncannot rely on the side effect of set. Instead, specify that the observer\nshould also run after init by using .on('init'):\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  Person = Ember.Object.extend({\n  init: function() {\n    this.set('salutation', \"Mr/Ms\");\n  },\n\n  salutationDidChange: function() {\n    // some side effect of salutation changing\n  }.observes('salutation').on('init')\n});\n\n\nUnconsumed Computed Properties Do Not Trigger Observers\nIf you never get a computed property, its observers will not fire even if\nits dependent keys change. You can think of the value changing from one unknown\nvalue to another.\n\nThis doesn't usually affect application code because computed properties are\nalmost always observed at the same time as they are fetched. For example, you get\nthe value of a computed property, put it in DOM (or draw it with D3), and then\nobserve it so you can update the DOM once the property changes.\n\nIf you need to observe a computed property but aren't currently retrieving it,\njust get it in your init method.\nWithout prototype extensions\nYou can define inline observers by using the Ember.observer method if you\nare using Ember without prototype extensions:\n\n  1\n2\n3\n4\n5\n\n  Person.reopen({\n  fullNameChanged: Ember.observer('fullName', function() {\n    // deal with the change\n  })\n});\n\n\nOutside of class definitions\nYou can also add observers to an object outside of a class definition\nusing addObserver:\n\n  1\n2\n3\n\n  person.addObserver('fullName', function() {\n  // deal with the change\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"f8ecff8837ebc62045275db96d37ff19","fields":[{"name":"title","value":"Reopening Classes and Instances","type":"string"},{"name":"url","value":"/object-model/reopening-classes-and-instances/","type":"enum"},{"name":"body","value":"You don't need to define a class all at once. You can reopen a class and\ndefine new properties using the reopen method.\n\n  1\n2\n3\n4\n5\n\n  Person.reopen({\n  isPerson: true\n});\n\nPerson.create().get('isPerson') // true\n\n\n\nWhen using reopen, you can also override existing methods and\ncall this._super.\n\n  1\n2\n3\n4\n5\n6\n\n  Person.reopen({\n  // override `say` to add an ! at the end\n  say: function(thing) {\n    this._super(thing + \"!\");\n  }\n});\n\n\n\nreopen is used to add instance methods and properties that are shared across all instances of a class. It does not add\nmethods and properties to a particular instance of a class as in vanilla JavaScript (without using prototype).\n\nBut when you need to add static methods or static properties to the class itself you can use reopenClass.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  // add static property to class\nPerson.reopenClass({\n  isPerson: false\n});\n// override property of Person instance\nPerson.reopen({\n  isPerson: true\n});\n\nPerson.isPerson; // false - because it is static property created by `reopenClass`\nPerson.create().get(\"isPerson\"); // true\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e85689a1d05f5ca425e72f28075b9737","fields":[{"name":"title","value":"Bindings, Observers, Computed Properties: What Do I Use When?","type":"string"},{"name":"url","value":"/object-model/what-do-i-use-when/","type":"enum"},{"name":"body","value":"Sometimes new users are confused about when to use computed properties,\nbindings and observers. Here are some guidelines to help:\n\n\nUse computed properties to build a new property by synthesizing other\nproperties. Computed properties should not contain application behavior, and\nshould generally not cause any side-effects when called. Except in rare cases,\nmultiple calls to the same computed property should always return the same\nvalue (unless the properties it depends on have changed, of course.)\nObservers should contain behavior that reacts to changes in another\nproperty. Observers are especially useful when you need to perform some\nbehavior after a binding has finished synchronizing.\nBindings are most often used to ensure objects in two different layers\nare always in sync. For example, you bind your views to your controller using\nHandlebars.\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"2e1967ab300f10bb0db8e074948cdccf","fields":[{"name":"title","value":"Asynchronous Routing","type":"string"},{"name":"url","value":"/routing/asynchronous-routing/","type":"enum"},{"name":"body","value":"This section covers some more advanced features of the router and its\ncapability for handling complex async logic within your app.\nA Word on Promises...\nEmber's approach to handling asynchronous logic in the router makes\nheavy use of the concept of Promises. In short, promises are objects that\nrepresent an eventual value. A promise can either fulfill\n(successfully resolve the value) or reject (fail to resolve the\nvalue). The way to retrieve this eventual value, or handle the cases\nwhen the promise rejects, is via the promise's then method, which\naccepts two optional callbacks, one for fulfillment and one for\nrejection. If the promise fulfills, the fulfillment handler gets called\nwith the fulfilled value as its sole argument, and if the promise rejects,\nthe rejection handler gets called with a reason for the rejection as its\nsole argument. For example:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  var promise = fetchTheAnswer();\n\npromise.then(fulfill, reject);\n\nfunction fulfill(answer) {\n  console.log(\"The answer is \" + answer);\n}\n\nfunction reject(reason) {\n  console.log(\"Couldn't get the answer! Reason: \" + reason);\n}\n\n\n\nMuch of the power of promises comes from the fact that they can be\nchained together to perform sequential asynchronous operations:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  // Note: jQuery AJAX methods return promises\nvar usernamesPromise = Ember.$.getJSON('/usernames.json');\n\nusernamesPromise.then(fetchPhotosOfUsers)\n                .then(applyInstagramFilters)\n                .then(uploadTrendyPhotoAlbum)\n                .then(displaySuccessMessage, handleErrors);\n\n\n\nIn the above example, if any of the methods\nfetchPhotosOfUsers, applyInstagramFilters, or\nuploadTrendyPhotoAlbum returns a promise that rejects,\nhandleErrors will be called with\nthe reason for the failure. In this manner, promises approximate an\nasynchronous form of try-catch statements that prevent the rightward\nflow of nested callback after nested callback and facilitate a saner\napproach to managing complex asynchronous logic in your applications.\n\nThis guide doesn't intend to fully delve into all the different ways\npromises can be used, but if you'd like a more thorough introduction,\ntake a look at the readme for RSVP,\nthe promise library that Ember uses.\nThe Router Pauses for Promises\nWhen transitioning between routes, the Ember router collects all of the\nmodels (via the model hook) that will be passed to the route's\ncontrollers at the end of the transition. If the model hook (or the related\nbeforeModel or afterModel hooks) return normal (non-promise) objects or\narrays, the transition will complete immediately. But if the model hook\n(or the related beforeModel or afterModel hooks) returns a promise (or\nif a promise was provided as an argument to transitionTo), the transition\nwill pause until that promise fulfills or rejects.\n\nThe router considers any object with a then method\ndefined on it to be a promise.\n\nIf the promise fulfills, the transition will pick up where it left off and\nbegin resolving the next (child) route's model, pausing if it too is a\npromise, and so on, until all destination route models have been\nresolved. The values passed to the setupController hook for each route\nwill be the fulfilled values from the promises.\n\nA basic example:\n\n  \n    \n      app/routes/tardy.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  export default Ember.Route.extend({\n  model: function() {\n    return new Ember.RSVP.Promise(function(resolve) {\n      Ember.run.later(function() {\n        resolve({ msg: \"Hold Your Horses\" });\n      }, 3000);\n    });\n  },\n\n  setupController: function(controller, model) {\n    console.log(model.msg); // \"Hold Your Horses\"\n  }\n});\n\n\n\nWhen transitioning into route:tardy, the model hook will be called and\nreturn a promise that won't resolve until 3 seconds later, during which time\nthe router will be paused in mid-transition. When the promise eventually\nfulfills, the router will continue transitioning and eventually call\nroute:tardy's setupController hook with the resolved object.\n\nThis pause-on-promise behavior is extremely valuable for when you need\nto guarantee that a route's data has fully loaded before displaying a\nnew template.\nWhen Promises Reject...\nWe've covered the case when a model promise fulfills, but what if it rejects?\n\nBy default, if a model promise rejects during a transition, the transition is\naborted, no new destination route templates are rendered, and an error\nis logged to the console.\n\nYou can configure this error-handling logic via the error handler on\nthe route's actions hash. When a promise rejects, an error event\nwill be fired on that route and bubble up to route:application's\ndefault error handler unless it is handled by a custom error handler\nalong the way, e.g.:\n\n  \n    \n      app/routes/good-for-nothing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  export default Ember.Route.extend({\n  model: function() {\n    return Ember.RSVP.reject(\"FAIL\");\n  },\n\n  actions: {\n    error: function(reason) {\n      alert(reason); // \"FAIL\"\n\n      // Can transition to another route here, e.g.\n      // this.transitionTo('index');\n\n      // Uncomment the line below to bubble this error event:\n      // return true;\n    }\n  }\n});\n\n\n\nIn the above example, the error event would stop right at\nroute:good-for-nothing's error handler and not continue to bubble. To\nmake the event continue bubbling up to route:application, you can\nreturn true from the error handler.\nRecovering from Rejection\nRejected model promises halt transitions, but because promises are chainable,\nyou can catch promise rejects within the model hook itself and convert\nthem into fulfills that won't halt the transition.\n\n  \n    \n      app/routes/funky.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Route.extend({\n  model: function() {\n    return iHopeThisWorks().then(null, function() {\n      // Promise rejected, fulfill with some default value to\n      // use as the route's model and continue on with the transition\n      return { msg: \"Recovered from rejected promise\" };\n    });\n  }\n});\n\n\nbeforeModel and afterModel\nThe model hook covers many use cases for pause-on-promise transitions,\nbut sometimes you'll need the help of the related hooks beforeModel\nand afterModel. The most common reason for this is that if you're\ntransitioning into a route with a dynamic URL segment via {{link-to}} or\ntransitionTo (as opposed to a transition caused by a URL change),\nthe model for the route you're transitioning into will have already been\nspecified (e.g. {{#link-to 'article' article}} or\nthis.transitionTo('article', article)), in which case the model hook\nwon't get called. In these cases, you'll need to make use of either\nthe beforeModel or afterModel hook to house any logic while the\nrouter is still gathering all of the route's models to perform a\ntransition.\nbeforeModel\nEasily the more useful of the two, the beforeModel hook is called\nbefore the router attempts to resolve the model for the given route. In\nother words, it is called before the model hook gets called, or, if\nmodel doesn't get called, it is called before the router attempts to\nresolve any model promises passed in for that route.\n\nLike model, returning a promise from beforeModel will pause the\ntransition until it resolves, or will fire an error if it rejects.\n\nThe following is a far-from-exhaustive list of use cases in which\nbeforeModel is very handy:\n\n\nDeciding whether to redirect to another route before performing a\npotentially wasteful server query in model\nEnsuring that the user has an authentication token before proceeding\nonward to model\nLoading application code required by this route\n\n\n  \n    \n      app/routes/secret-articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  beforeModel: function() {\n    if (!this.controllerFor('auth').get('isLoggedIn')) {\n      this.transitionTo('login');\n    }\n  }\n});\n\n\n\nSee the API Docs for beforeModel\nafterModel\nThe afterModel hook is called after a route's model (which might be a\npromise) is resolved, and follows the same pause-on-promise semantics as\nmodel and beforeModel. It is passed the already-resolved model\nand can therefore perform any additional logic that\ndepends on the fully resolved value of a model.\n\n  \n    \n      app/routes/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  export default Ember.Route.extend({\n  model: function() {\n    // `this.store.find('article')` returns a promise-like object\n    // (it has a `then` method that can be used like a promise)\n    return this.store.find('article');\n  },\n  afterModel: function(articles) {\n    if (articles.get('length') === 1) {\n      this.transitionTo('article.show', articles.get('firstObject'));\n    }\n  }\n});\n\n\n\nYou might be wondering why we can't just put the afterModel logic\ninto the fulfill handler of the promise returned from model; the\nreason, as mentioned above, is that transitions initiated\nvia {{link-to}} or transitionTo likely already provided the\nmodel for this route, so model wouldn't be called in these cases.\n\nSee the API Docs for afterModel\nMore Resources\n\nEmbercasts: Client-side Authentication Part 2\nRC6 Blog Post describing these new features\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"bc0bfb567fedd41ba7b17f66df025608","fields":[{"name":"title","value":"Defining Your Routes","type":"string"},{"name":"url","value":"/routing/defining-your-routes/","type":"enum"},{"name":"body","value":"When your application starts, the router is responsible for displaying\ntemplates, loading data, and otherwise setting up application state.\nIt does so by matching the current URL to the routes that you've\ndefined.\n\nThe map method\nof your Ember application's router can be invoked to define URL mappings. When\ncalling map, you should pass a function that will be invoked with the value\nthis set to an object which you can use to create\nroutes.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function() {\n  this.route('about', { path: '/about' });\n  this.route('favorites', { path: '/favs' });\n});\n\n\n\nNow, when the user visits /about, Ember.js will render the about\ntemplate. Visiting /favs will render the favorites template.\n\nHeads up! You get a few routes for free: the route:application and\nroute:index (corresponding to the / path).\nSee below for more details.\n\nYou can leave off the path if it is the same as the route\nname. In this case, the following is equivalent to the above example:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function() {\n  this.route('about');\n  this.route('favorites', { path: '/favs' });\n});\n\n\n\nInside your templates, you can use {{link-to}} to navigate between\nroutes, using the name that you provided to the route method (or, in\nthe case of /, the name index).\n\n  1\n2\n3\n4\n5\n6\n\n  {{#link-to 'index'}}\u003cimg class=\"logo\"\u003e{{/link-to}}\n\n\u003cnav\u003e\n  {{#link-to 'about'}}About{{/link-to}}\n  {{#link-to 'favorites'}}Favorites{{/link-to}}\n\u003c/nav\u003e\n\n\n\nThe {{link-to}} helper will also add an active class to the link that\npoints to the currently active route.\n\nYou can customize the behavior of a route by creating an Ember.Route\nsubclass. For example, to customize what happens when your user visits\n/, create an route:index:\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Route.extend({\n  setupController: function(controller) {\n    // Set the IndexController's `title`\n    controller.set('title', 'My App');\n  }\n});\n\n\n\ncontroller:index is the starting context for the index template.\nNow that you've set title, you can use it in the template:\n\n  1\n2\n\n  \u003c!-- get the title from the IndexController --\u003e\n\u003ch1\u003e{{title}}\u003c/h1\u003e\n\n\n\n(If you don't explicitly define an controller:index, Ember.js will\nautomatically generate one for you.)\n\nEmber.js automatically figures out the names of the routes and controllers based on\nthe name you pass to this.route.\n\n\n  \n  \n    URL\n    Route Name\n    \n      Controller\n      app/controllers/\n    \n    \n      Route\n      app/routes/\n    \n    \n      Template\n      app/templates/\n    \n  \n  \n  \n    /\n    index\n    â³index.js\n    â³index.js\n    â³index.hbs\n  \n  \n    /about\n    about\n    â³about.js\n    â³about.js\n    â³about.hbs\n  \n  \n    /favs\n    favorites\n    â³favorites.js\n    â³favorites.js\n    â³favorites.hbs\n  \n\nNested Routes\nYou can define nested routes by passing a callback to this.route:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('posts', { path: '/posts' }, function() {\n    this.route('new');\n  });\n});\n\n\n\nThis router creates these routes:\n\n\n  \n  \n   URL\n   Route Name\n   \n     Controller\n     app/controllers/\n   \n   \n     Route\n     app/routes/\n   \n   \n     Template\n     app/templates/\n   \n  \n  \n  \n    /\n    index\n    â³index.js\n    â³index.js\n    â³index.js\n  \n  \n    N/A\n    posts\n    â³posts.js\n    â³posts.js\n    â³posts.hbs\n  \n  \n    /posts\n    posts.index\n    â³posts.jsâ³posts/index.js\n    â³posts.jsâ³posts/index.js\n    â³posts.hbsâ³posts/index.hbs\n  \n  \n    /posts/new\n    posts.new\n    â³posts.jsâ³posts/new.js\n    â³posts.jsâ³posts/new.js\n    â³posts.hbsâ³posts/new.hbs\n  \n\n\nA nested route's names includes the names of its ancestors.\nIf you want to transition to a route (either\nvia transitionTo or {{#link-to}}), make sure to use the full route\nname (posts.new, not new).\n\nThat said, transitioning to posts or creating a link to posts is equivalent\nto transitioning to posts.index or linking to posts.index.\n\nVisiting / renders the index template, as you would expect.\n\nVisiting /posts is slightly different. It will first render the\nposts template. Then, it will render the posts/index template into the\nposts template's outlet.\n\nFinally, visiting /posts/new will first render the posts template,\nthen render the posts/new template into its outlet.\nMulti-word Model Names\nFor multi-word models all the names are camel cased except for the dynamic segment. For example, a model named BigMac would have a path of /bigMacs/:big_mac_id, route named bigMac, template named bigMac.\nDynamic Segments\nOne of the responsibilities of a route handler is to convert a URL\ninto a model.\n\nFor example, if we have the route this.route('posts');, our\nroute handler might look like this:\n\n  \n    \n      app/routes/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model: function() {\n    return $.getJSON(\"/url/to/some/posts.json\");\n  }\n});\n\n\n\nThe posts template will then receive a list of all available posts as\nits context.\n\nBecause /posts represents a fixed model, we don't need any\nadditional information to know what to retrieve.  However, if we want a route\nto represent a single post, we would not want to have to hardcode every\npossible post into the router.\n\nEnter dynamic segments.\n\nA dynamic segment is a portion of a URL that starts with a : and is\nfollowed by an identifier.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function() {\n  this.route('posts');\n  this.route('post', { path: '/post/:post_id' });\n});\n\n\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model: function(params) {\n    return $.getJSON(\"/url/to/some/posts/\" + params.post_id + \".json\");\n  }\n});\n\n\n\nIf your model does not use the id property in the URL, you should\ndefine a serialize method on your route:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('post', { path: '/posts/:post_slug' });\n});\n\n\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Route.extend({\n  model: function(params) {\n    // the server returns `{ slug: 'foo-post' }`\n    return Ember.$.getJSON('/posts/' + params.post_slug);\n  },\n\n  serialize: function(model) {\n    // this will make the URL `/posts/foo-post`\n    return { post_slug: model.get('slug') };\n  }\n});\n\n\n\nThe default serialize method inserts the model's id into the route's\ndynamic segment (in this case, :post_id).\nInitial routes\nA few routes are immediately available within your application:\n\n\nroute:application is entered when your app first boots up. It renders\nthe application template.\nroute:index is the default route, and will render the index template\nwhen the user visits / (unless / has been overridden by your own\ncustom route).\n\n\nThese routes are part of every application, so you don't need to\nspecify them in your app/router.js.\nWildcard / globbing routes\nYou can define wildcard routes that will match multiple routes. This could be used, for example,\nif you'd like a catch-all route which is useful when the user enters an incorrect URL not managed\nby your app.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('catchall', { path: '/*wildcard' });\n});\n\n\n\nLike all routes with a dynamic segment, you must provide a context when using a {{link-to}}\nor transitionTo to programatically enter this route.\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  actions: {\n    error: function() {\n      this.transitionTo('catchall', 'application-error');\n    }\n  }\n});\n\n\n\nWith this code, if an error bubbles up to the Application route, your application will enter\nthe catchall route and display /application-error in the URL.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"c5953994735a42bd20744325ddcc8f3c","fields":[{"name":"title","value":"Generated Objects","type":"string"},{"name":"url","value":"/routing/generated-objects/","type":"enum"},{"name":"body","value":"As explained in the routing guide, whenever you define a new route,\nEmber.js attempts to find corresponding Route, Controller, View, and Template\nclasses named according to naming conventions. If an implementation of any of\nthese objects is not found, appropriate objects will be generated in memory for you.\nGenerated routes\nGiven you have the following route:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('posts');\n});\n\n\n\nWhen you navigate to /posts, Ember.js looks for route:posts.\nIf it doesn't find it, it will automatically generate an route:posts for you.\nGenerated Controllers\nIf you navigate to route posts, Ember.js looks for a controller called controller:posts.\nIf you did not define it, one will be generated for you.\nGenerated Views and Templates\nA route also expects a view and a template.  If you don't define a view,\na view will be generated for you.\n\nA generated template is empty.\nIf it's a resource template, the template will simply act\nas an outlet so that nested routes can be seamlessly inserted.  It is equivalent to:\n\n  1\n\n  {{outlet}}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e220634be1096dfda0635ee4cccf6449","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/routing/","type":"enum"},{"name":"body","value":"Routing\nAs users interact with your application, it moves through many\ndifferent states. Ember.js gives you helpful tools for managing\nthat state in a way that scales with your application.\n\nTo understand why this is important, imagine we are writing a web app\nfor managing a blog. At any given time, we should be able to answer\nquestions like: Is the user currently logged in? Are they an admin\nuser? What post are they looking at? Is the settings screen open?  Are\nthey editing the current post?\n\nIn Ember.js, each of the possible states in your application is\nrepresented by a URL. Because all of the questions we asked aboveâ\nAre we logged in?  What post are we looking at? âare encapsulated by\nroute handlers for the URLs, answering them is both simple and accurate.\n\nAt any given time, your application has one or more active route\nhandlers. The active handlers can change for one of two reasons:\n\n\nThe user interacted with a view, which generated an event that caused\nthe URL to change.\nThe user changed the URL manually (e.g., via the back button), or the\npage was loaded for the first time.\n\n\nWhen the current URL changes, the newly active route handlers may do one\nor more of the following:\n\n\nConditionally redirect to a new URL.\nUpdate a controller so that it represents a particular model.\nChange the template on screen, or place a new template into an\nexisting outlet.\n\nLogging Route Changes\nAs your application increases in complexity, it can be helpful to see exactly what is going on with the router. To have Ember write out transition events to the log modify your project configuration:\n\n  \n    \n      config/environment.js\n    \n  \n\n  1\n\n  ENV.APP.LOG_TRANSITIONS = true;\n\n\nSpecifying a Root URL\nIf your Ember application is one of multiple web applications served from the same domain, it may be necessary to indicate to the router what the root URL for your Ember application is. By default, Ember will assume it is served from the root of your domain.\n\nFor example, if you wanted to serve your blogging application from http://emberjs.com/blog/, it would be necessary to specify a root URL of /blog/.\n\nThis can be achieved by setting the rootURL on the router:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Ember.Router.extend({\n  rootURL: '/blog/'\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b73d2dfe086aa008696fa624bef07e0e","fields":[{"name":"title","value":"Loading / Error Substates","type":"string"},{"name":"url","value":"/routing/loading-and-error-substates/","type":"enum"},{"name":"body","value":"In addition to the techniques described in the\nAsynchronous Routing Guide,\nthe Ember Router provides powerful yet overridable\nconventions for customizing asynchronous transitions\nbetween routes by making use of error and loading\nsubstates.\nloading substates\nThe Ember Router allows you to return promises from the various\nbeforeModel/model/afterModel hooks in the course of a transition\n(described here).\nThese promises pause the transition until they fulfill, at which point\nthe transition will resume.\n\nConsider the following:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('foo', function() {\n    this.route('slow-model');\n  });\n});\n\n\n\n  \n    \n      app/routes/foo/slow-model.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model: function() {\n    return somePromiseThatTakesAWhileToResolve();\n  }\n});\n\n\n\nIf you navigate to foo/slow-model, and in the model hook,\nyou return an AJAX query promise that takes a long time to complete.\nDuring this time, your UI isn't really giving you any feedback as to\nwhat's happening; if you're entering this route after a full page\nrefresh, your UI will be entirely blank, as you have not actually\nfinished fully entering any route and haven't yet displayed any\ntemplates; if you're navigating to foo/slow-model from another\nroute, you'll continue to see the templates from the previous route\nuntil the model finish loading, and then, boom, suddenly all the\ntemplates for foo/slow-model load.\n\nSo, how can we provide some visual feedback during the transition?\n\nEmber provides a default implementation of the loading process that implements\nthe following loading substate behavior.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  Router.map(function() {\n  this.route('foo', function() {\n    this.route('bar', function() {\n      this.route('baz');\n    });\n  });\n});\n\n\n\nIf a route with the path foo.bar.baz returns a promise that doesn't immediately\nresolve, Ember will try to find a loading route in the hierarchy\nabove foo.bar.baz that it can transition into, starting with\nfoo.bar.baz's sibling:\n\n\nfoo.bar.loading\nfoo.loading\nloading\n\n\nEmber will find a loading route at the above location if either a) a\nRoute subclass has been defined for such a route, e.g.\n\n\napp/routes/foo/bar/loading.js\napp/routes/foo/loading.js\napp/routes/loading.js\n\n\nor b) a properly-named loading template has been found, e.g.\n\n\napp/templates/foo/bar/loading.hbs\napp/templates/foo/loading.hbs\napp/templates/loading.hbs\n\n\nDuring a slow asynchronous transition, Ember will transition into the\nfirst loading sub-state/route that it finds, if one exists. The\nintermediate transition into the loading substate happens immediately\n(synchronously), the URL won't be updated, and, unlike other transitions\nthat happen while another asynchronous transition is active, the\ncurrently active async transition won't be aborted.\n\nAfter transitioning into a loading substate, the corresponding template\nfor that substate, if present, will be rendered into the main outlet of\nthe parent route, e.g. foo.bar.loading's template would render into\nfoo.bar's outlet. (This isn't particular to loading routes; all\nroutes behave this way by default.)\n\nOnce the main async transition into foo.bar.baz completes, the loading\nsubstate will be exited, its template torn down, foo.bar.baz will be\nentered, and its templates rendered.\nEager vs. Lazy Async Transitions\nLoading substates are optional, but if you provide one,\nyou are essentially telling Ember that you\nwant this async transition to be \"eager\"; in the absence of destination\nroute loading substates, the router will \"lazily\" remain on the pre-transition route\nwhile all of the destination routes' promises resolve, and only fully\ntransition to the destination route (and renders its templates, etc.)\nonce the transition is complete. But once you provide a destination\nroute loading substate, you are opting into an \"eager\" transition, which\nis to say that, unlike the \"lazy\" default, you will eagerly exit the\nsource routes (and tear down their templates, etc) in order to\ntransition into this substate. URLs always update immediately unless the\ntransition was aborted or redirected within the same run loop.\n\nThis has implications on error handling, i.e. when a transition into\nanother route fails, a lazy transition will (by default) just remain on the\nprevious route, whereas an eager transition will have already left the\npre-transition route to enter a loading substate.\nThe loading event\nIf you return a promise from the various beforeModel/model/afterModel hooks,\nand it doesn't immediately resolve, a loading event will be fired on that route\nand bubble upward to route:application.\n\nIf the loading handler is not defined at the specific route,\nthe event will continue to bubble above a transition's pivot\nroute, providing the route:application the opportunity to manage it.\n\n  \n    \n      app/routes/foo-slow-model.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  export default Ember.Route.extend({\n  model: function() {\n    return somePromiseThatTakesAWhileToResolve();\n  },\n  actions: {\n    loading: function(transition, originRoute) {\n      //displayLoadingSpinner();\n\n      // Return true to bubble this event to `FooRoute`\n      // or `ApplicationRoute`.\n      return true;\n    }\n  }\n});\n\n\n\nThe loading handler provides the ability to decide what to do during\nthe loading process. If the last loading handler is not defined\nor returns true, Ember will perform the loading substate behavior.\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default Ember.Route.extend({\n  actions: {\n    loading: function(transition, originRoute) {\n      displayLoadingSpinner();\n\n      // substate implementation when returning `true`\n      return true;\n    }\n  }\n});\n\n\nerror substates\nEmber provides an analogous approach to loading substates in\nthe case of errors encountered during a transition.\n\nSimilar to how the default loading event handlers are implemented,\nthe default error handlers will look for an appropriate error substate to\nenter, if one can be found.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('articles', function() {\n    this.route('overview');\n  });\n});\n\n\n\nFor instance, an thrown error or rejected promise returned from\nroute:articles/overview's #model hook (or beforeModel or afterModel)\nwill look for:\n\n\nEither route:articles/error or articles/error template\nEither route:error or error template\n\n\nIf one of the above is found, the router will immediately transition into\nthat substate (without updating the URL). The \"reason\" for the error\n(i.e. the exception thrown or the promise reject value) will be passed\nto that error state as its model.\n\nIf no viable error substates can be found, an error message will be\nlogged.\nerror substates with dynamic segments\nRoutes with dynamic segments are often mapped to a mental model of \"two\nseparate levels.\" Take for example:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('foo', { path: '/foo/:id' }, function() {\n    this.route('baz');\n  });\n});\n\n\n\n  \n    \n      app/routes/foo.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  model: function(params) {\n    return new Ember.RSVP.Promise(function(resolve, reject) {\n       reject(\"Error\");\n    });\n  }\n});\n\n\n\nIn the URL hierarchy you would visit /foo/12 which would result in rendering\nthe foo template into the application template's outlet. In the event of\nan error while attempting to load the foo route you would also render the\ntop-level error template into the application template's outlet. This is\nintentionally parallel behavior as the foo route is never successfully\nentered. In order to create a foo scope for errors and render foo/error\ninto foo's outlet you would need to split the dynamic segment:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  Router.map(function() {\n  this.route('foo', {path: '/foo'}, function() {\n    this.route('elem', {path: ':id'}, function() {\n      this.route('baz');\n    });\n  });\n});\n\n\n\nExample JSBin\nThe error event\nIf route:articles/overview's model hook returns a promise that rejects (for\ninstance the server returned an error, the user isn't logged in,\netc.), an error event will fire on route:articles/overview and bubble upward.\nThis error event can be handled and used to display an error message,\nredirect to a login page, etc.\n\n  \n    \n      app/routes/articles-overview.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  export default Ember.Route.extend({\n  model: function(params) {\n    return new Ember.RSVP.Promise(function(resolve, reject) {\n       reject(\"Error\");\n    });\n  },\n  actions: {\n    error: function(error, transition) {\n\n      if (error \u0026\u0026 error.status === 400) {\n        // error substate and parent routes do not handle this error\n        return this.transitionTo('modelNotFound');\n      }\n\n      // Return true to bubble this event to any parent route.\n      return true;\n    }\n  }\n});\n\n\n\nAnalogous to the loading event, you could manage the error event\nat the Application level to perform any application logic and based on the\nresult of the last error handler, Ember will decide if substate behavior\nmust be performed or not.\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  export default Ember.Route.extend({\n  actions: {\n    error: function(error, transition) {\n\n      // Manage your errors\n      Ember.onerror(error);\n\n      // substate implementation when returning `true`\n      return true;\n\n    }\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"73217f11fed62d7b09ccc1c4378f49e7","fields":[{"name":"title","value":"Preventing and Retrying Transitions","type":"string"},{"name":"url","value":"/routing/preventing-and-retrying-transitions/","type":"enum"},{"name":"body","value":"During a route transition, the Ember Router passes a transition\nobject to the various hooks on the routes involved in the transition.\nAny hook that has access to this transition object has the ability\nto immediately abort the transition by calling transition.abort(),\nand if the transition object is stored, it can be re-attempted at a\nlater time by calling transition.retry().\nPreventing Transitions via willTransition\nWhen a transition is attempted, whether via {{link-to}}, transitionTo,\nor a URL change, a willTransition action is fired on the currently\nactive routes. This gives each active route, starting with the leaf-most\nroute, the opportunity to decide whether or not the transition should occur.\n\nImagine your app is in a route that's displaying a complex form for the user\nto fill out and the user accidentally navigates backwards. Unless the\ntransition is prevented, the user might lose all of the progress they\nmade on the form, which can make for a pretty frustrating user experience.\n\nHere's one way this situation could be handled:\n\n  \n    \n      app/routes/form.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  export default Ember.Route.extend({\n  actions: {\n    willTransition: function(transition) {\n      if (this.controller.get('userHasEnteredData') \u0026\u0026\n          !confirm(\"Are you sure you want to abandon progress?\")) {\n        transition.abort();\n      } else {\n        // Bubble the `willTransition` action so that\n        // parent routes can decide whether or not to abort.\n        return true;\n      }\n    }\n  }\n});\n\n\n\nWhen the user clicks on a {{link-to}} helper, or when the app initiates a\ntransition by using transitionTo, the transition will be aborted and the URL\nwill remain unchanged. However, if the browser back button is used to\nnavigate away from route:form, or if the user manually changes the URL, the\nnew URL will be navigated to before the willTransition action is\ncalled. This will result in the browser displaying the new URL, even if\nwillTransition calls transition.abort().\nAborting Transitions Within model, beforeModel, afterModel\nThe model, beforeModel, and afterModel hooks described in\nAsynchronous Routing\neach get called with a transition object. This makes it possible for\ndestination routes to abort attempted transitions.\n\n  \n    \n      app/routes/disco.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  beforeModel: function(transition) {\n    if (new Date() \u003c new Date(\"January 1, 1980\")) {\n      alert(\"Sorry, you need a time machine to enter this route.\");\n      transition.abort();\n    }\n  }\n});\n\n\nStoring and Retrying a Transition\nAborted transitions can be retried at a later time. A common use case\nfor this is having an authenticated route redirect the user to a login\npage, and then redirecting them back to the authenticated route once\nthey've logged in.\n\n  \n    \n      app/routes/some-authenticated.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Route.extend({\n  beforeModel: function(transition) {\n    if (!this.controllerFor('auth').get('userIsLoggedIn')) {\n      var loginController = this.controllerFor('login');\n      loginController.set('previousTransition', transition);\n      this.transitionTo('login');\n    }\n  }\n});\n\n\n\n  \n    \n      app/controllers/login.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export default Ember.Controller.extend({\n  actions: {\n    login: function() {\n      // Log the user in, then reattempt previous transition if it exists.\n      var previousTransition = this.get('previousTransition');\n      if (previousTransition) {\n        this.set('previousTransition', null);\n        previousTransition.retry();\n      } else {\n        // Default back to homepage\n        this.transitionToRoute('index');\n      }\n    }\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a10da78f7f24528b1e5d721dbc5e424b","fields":[{"name":"title","value":"Query Parameters","type":"string"},{"name":"url","value":"/routing/query-params/","type":"enum"},{"name":"body","value":"Query parameters are optional key-value pairs that appear to the right of\nthe ? in a URL. For example, the following URL has two query params,\nsort and page, with respective values ASC and 2:\n\n  1\n\n  http://example.com/articles?sort=ASC\u0026page=2\n\n\n\nQuery params allow for additional application state to be serialized\ninto the URL that can't otherwise fit into the path of the URL (i.e.\neverything to the left of the ?). Common use cases for query params include\nrepresenting the current page number in a paginated collection, filter criteria, or sorting criteria.\nSpecifying Query Parameters\nQuery params are declared on route-driven controllers. For example, to\nconfigure query params that are active within the articles route,\nthey must be declared on controller:articles.\n\nTo add a category\nquery parameter that will filter out all the articles that haven't\nbeen categorized as popular we'd specify 'category'\nas one of controller:article's queryParams:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Controller.extend({\n  queryParams: ['category'],\n  category: null\n});\n\n\n\nThis sets up a binding between the category query param in the URL,\nand the category property on controller:articles. In other words,\nonce the articles route has been entered, any changes to the\ncategory query param in the URL will update the category property\non controller:articles, and vice versa.\n\nNow we just need to define a computed property of our category-filtered\narray that the articles template will render:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export default Ember.Controller.extend({\n  queryParams: ['category'],\n  category: null,\n\n  filteredArticles: function() {\n    var category = this.get('category');\n    var articles = this.get('model');\n\n    if (category) {\n      return articles.filterBy('category', category);\n    } else {\n      return articles;\n    }\n  }.property('category', 'model')\n});\n\n\n\nWith this code, we have established the following behaviors:\n\n\nIf the user navigates to /articles, category will be null, so\nthe articles won't be filtered.\nIf the user navigates to /articles?category=recent,\ncategory will be set to \"recent\", so articles will be filtered.\nOnce inside the articles route, any changes to the category\nproperty on controller:articles will cause the URL to update the\nquery param. By default, a query param property change won't cause a\nfull router transition (i.e. it won't call model hooks and\nsetupController, etc.); it will only update the URL.\n\nlink-to Helper\nThe link-to helper supports specifying query params using the\nquery-params subexpression helper.\n\n  1\n2\n3\n4\n5\n\n  // Explicitly set target query params\n{{#link-to 'posts' (query-params direction=\"asc\")}}Sort{{/link-to}}\n\n// Binding is also supported\n{{#link-to 'posts' (query-params direction=otherDirection)}}Sort{{/link-to}}\n\n\n\nIn the above examples, direction is presumably a query param property\non the controller:post, but it could also refer to a direction property\non any of the controllers associated with the posts route hierarchy,\nmatching the leaf-most controller with the supplied property name.\n\nThe link-to helper takes into account query parameters when determining\nits \"active\" state, and will set the class appropriately. The active state\nis determined by calculating whether the query params end up the same after\nclicking a link. You don't have to supply all of the current,\nactive query params for this to be true.\ntransitionTo\nRoute#transitionTo and Controller#transitionToRoute\naccept a final argument, which is an object with the key queryParams.\n\n  \n    \n      app/routes/some-route.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  this.transitionTo('post', object, {queryParams: {showDetails: true}});\nthis.transitionTo('posts', {queryParams: {sort: 'title'}});\n\n// if you just want to transition the query parameters without changing the route\nthis.transitionTo({queryParams: {direction: 'asc'}});\n\n\n\nYou can also add query params to URL transitions:\n\n  \n    \n      app/routes/some-route.js\n    \n  \n\n  1\n\n  this.transitionTo(\"/posts/1?sort=date\u0026showDetails=true\");\n\n\nOpting into a full transition\nArguments provided to transitionTo\nor link-to only correspond to a change in query param values,\nand not a change in the route hierarchy, it is not considered a\nfull transition, which means that hooks like model and\nsetupController won't fire by default, but rather only\ncontroller properties will be updated with new query param values, as\nwill the URL.\n\nBut some query param changes necessitate loading data from the server,\nin which case it is desirable to opt into a full-on transition. To opt\ninto a full transition when a controller query param property changes,\nyou can use the optional queryParams configuration hash on the Route\nassociated with that controller, and set that query param's\nrefreshModel config property to true:\n\n  \n    \n      app/routes/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  export default Ember.Route.extend({\n  queryParams: {\n    category: {\n      refreshModel: true\n    }\n  },\n  model: function(params) {\n    // This gets called upon entering 'articles' route\n    // for the first time, and we opt into refiring it upon\n    // query param changes by setting `refreshModel:true` above.\n\n    // params has format of { category: \"someValueOrJustNull\" },\n    // which we can just forward to the server.\n    return this.store.findQuery('articles', params);\n  }\n});\n\n\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.ArrayController.extend({\n  queryParams: ['category'],\n  category: null\n});\n\n\nUpdate URL with replaceState instead\nBy default, Ember will use pushState to update the URL in the\naddress bar in response to a controller query param property change, but\nif you would like to use replaceState instead (which prevents an\nadditional item from being added to your browser's history), you can\nspecify this on the Route's queryParams config hash, e.g. (continued\nfrom the example above):\n\n  \n    \n      app/routes/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  queryParams: {\n    category: {\n      replace: true\n    }\n  }\n});\n\n\n\nNote that the name of this config property and its default value of\nfalse is similar to the link-to helper's, which also lets\nyou opt into a replaceState transition via replace=true.\nMap a controller's property to a different query param key\nBy default, specifying foo as a controller query param property will\nbind to a query param whose key is foo, e.g. ?foo=123. You can also map\na controller property to a different query param key using the\nfollowing configuration syntax:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.ArrayController.extend({\n  queryParams: {\n    category: \"articles_category\"\n  },\n  category: null\n});\n\n\n\nThis will cause changes to the controller:articles's category\nproperty to update the articles_category query param, and vice versa.\n\nNote that query params that require additional customization can\nbe provided along with strings in the queryParams array.\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Controller.extend({\n  queryParams: [ \"page\", \"filter\", {\n    category: \"articles_category\"\n  }],\n  category: null,\n  page: 1,\n  filter: \"recent\"\n});\n\n\nDefault values and deserialization\nIn the following example, the controller query param property page is\nconsidered to have a default value of 1.\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.ArrayController.extend({\n  queryParams: 'page',\n  page: 1\n});\n\n\n\nThis affects query param behavior in two ways:\n\n\nQuery param values are cast to the same datatype as the default\nvalue, e.g. a URL change from /?page=3 to /?page=2 will set\ncontroller:articles's page property to the number 2, rather than\nthe string \"2\". The same also applies to boolean default values.\nWhen a controller's query param property is currently set to its\ndefault value, this value won't be serialized into the URL. So in the\nabove example, if page is 1, the URL might look like /articles,\nbut once someone sets the controller's page value to 2, the URL\nwill become /articles?page=2.\n\nSticky Query Param Values\nBy default, query param values in Ember are \"sticky\", in that if you\nmake changes to a query param and then leave and re-enter the route, the\nnew value of that query param will be preserved (rather than reset to\nits default). This is a particularly handy default for preserving sort/filter\nparameters as you navigate back and forth between routes.\n\nFurthermore, these sticky query param values are remembered/restored\naccording to the model loaded into the route. So, given a team route\nwith dynamic segment /:team_name and controller query param \"filter\",\nif you navigate to /badgers and filter by \"rookies\", then navigate\nto /bears and filter by \"best\", and then navigate to /potatoes and\nfilter by \"lamest\", then given the following nav bar links,\n\n  1\n2\n3\n\n  {{#link-to 'team' 'badgers '}}Badgers{{/link-to}}\n{{#link-to 'team' 'bears'   }}Bears{{/link-to}}\n{{#link-to 'team' 'potatoes'}}Potatoes{{/link-to}}\n\n\n\nthe generated links would be\n\n  1\n2\n3\n\n  \u003ca href=\"/badgers?filter=rookies\"\u003eBadgers\u003c/a\u003e\n\u003ca href=\"/bears?filter=best\"\u003eBears\u003c/a\u003e\n\u003ca href=\"/potatoes?filter=lamest\"\u003ePotatoes\u003c/a\u003e\n\n\n\nThis illustrates that once you change a query param, it is stored and\ntied to the model loaded into the route.\n\nIf you wish to reset a query param, you have two options:\n\n\nexplicitly pass in the default value for that query param into\nlink-to or transitionTo\nuse the Route.resetController hook to set query param values back to\ntheir defaults before exiting the route or changing the route's model\n\n\nIn the following example, the controller's page query param is reset\nto 1, while still scoped to the pre-transition ArticlesRoute model.\nThe result of this is that all links pointing back into the exited route\nwill use the newly reset value 1 as the value for the page query\nparam.\n\n  \n    \n      app/routes/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  resetController: function (controller, isExiting, transition) {\n    if (isExiting) {\n      // isExiting would be false if only the route's model was changing\n      controller.set('page', 1);\n    }\n  }\n});\n\n\n\nIn some cases, you might not want the sticky query param value to be\nscoped to the route's model but would rather reuse a query param's value\neven as a route's model changes. This can be accomplished by setting the\nscope option to \"controller\" within the controller's queryParams\nconfig hash:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.ArrayController.extend({\n  queryParams: [{\n    showMagnifyingGlass: {\n      scope: \"controller\"\n    }\n  }]\n});\n\n\n\nThe following demonstrates how you can override both the scope and the\nquery param URL key of a single controller query param property:\n\n  \n    \n      app/controllers/articles.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default Ember.Controller.extend({\n  queryParams: [ \"page\", \"filter\",\n    {\n      showMagnifyingGlass: {\n        scope: \"controller\",\n        as: \"glass\",\n      }\n    }\n  ]\n});\n\n\nExamples\n\nSearch queries\nSort: client-side, no refiring of model hook\nSort: server-side, refire model hook\nPagination + Sorting\nBoolean values. False value removes QP from URL\nGlobal query params on app route\nOpt-in to full transition via refresh()\nupdate query params by changing controller QP property\nupdate query params with replaceState by changing controller QP property\nw/ {{partial}} helper for easy tabbing\nlink-to with no route name, only QP change\nComplex: serializing textarea content into URL (and subexpressions))\nArrays\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"088e52d28fa44f8c93ca2f490bad93c3","fields":[{"name":"title","value":"Redirecting","type":"string"},{"name":"url","value":"/routing/redirection/","type":"enum"},{"name":"body","value":"Transitioning and Redirecting\nCalling transitionTo from a route or transitionToRoute from a controller\nwill stop any transition currently in progress and start a new one, functioning\nas a redirect. transitionTo takes parameters and behaves exactly like the link-to helper:\n\n\nIf you transition into a route without dynamic segments that route's model hook\nwill always run.\nIf the new route has dynamic segments, you need to pass either a model or an identifier for each segment.\nPassing a model will skip that segment's model hook.  Passing an identifier will run the model hook and you'll be able to access the identifier in the params. See Links for more detail.\n\nBefore the model is known\nIf you want to redirect from one route to another, you can do the transition in\nthe beforeModel hook of your route handler.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('posts');\n});\n\n\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  beforeModel: function() {\n    this.transitionTo('posts');\n  }\n});\n\n\nAfter the model is known\nIf you need information about the current model in order to decide about\nredirection, you should either use the afterModel or the redirect hook.\nThey receive the resolved model as the first parameter and the transition as\nthe second one, and thus function as aliases. (In fact, the default\nimplementation of afterModel just calls redirect.)\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n\n  Router.map(function() {\n  this.route('posts');\n  this.route('post', { path: '/post/:post_id' });\n});\n\n\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  afterModel: function(posts, transition) {\n    if (posts.get('length') === 1) {\n      this.transitionTo('post', posts.get('firstObject'));\n    }\n  }\n});\n\n\n\nWhen transitioning to the posts route if it turns out that there is only one post,\nthe current transition will be aborted in favor of redirecting to the PostRoute\nwith the single post object being its model.\nBased on other application state\nYou can conditionally transition based on some other application state.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  Router.map(function() {\n  this.route('topCharts', function() {\n    this.route('choose', { path: '/' });\n    this.route('albums');\n    this.route('songs');\n    this.route('artists');\n    this.route('playlists');\n  });\n});\n\n\n\n  \n    \n      app/routes/top-charts-choose.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Route.extend({\n  beforeModel: function() {\n    var lastFilter = this.controllerFor('application').get('lastFilter');\n    this.transitionTo('topCharts.' + (lastFilter || 'songs'));\n  }\n});\n\n\n\n  \n    \n      app/routes/filter.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  // Superclass to be used by all of the filter routes: albums, songs, artists, playlists\nexport default Ember.Route.extend({\n  activate: function() {\n    var controller = this.controllerFor('application');\n    controller.set('lastFilter', this.templateName);\n  }\n});\n\n\n\nIn this example, navigating to the / URL immediately transitions into\nthe last filter URL that the user was at. The first time, it transitions\nto the /songs URL.\n\nYour route can also choose to transition only in some cases. If the\nbeforeModel hook does not abort or transition to a new route, the remaining\nhooks (model, afterModel, setupController, renderTemplate) will execute\nas usual.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b1db196c912b89d4bb0d82325bb9137c","fields":[{"name":"title","value":"Rendering a Template","type":"string"},{"name":"url","value":"/routing/rendering-a-template/","type":"enum"},{"name":"body","value":"One of the most important jobs of a route handler is rendering the\nappropriate template to the screen.\n\nBy default, a route handler will render the template into the closest\nparent with a template.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('posts');\n});\n\n\n\n  \n    \n      app/routes/posts.js\n    \n  \n\n  1\n\n  export default Ember.Route.extend();\n\n\n\nIf you want to render a template other than the one associated with the\nroute handler, implement the renderTemplate hook:\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  renderTemplate: function() {\n    this.render('favoritePost');\n  }\n});\n\n\n\nIf you want to use a different controller than the route handler's\ncontroller, pass the controller's name in the controller option:\n\n  \n    \n      app/routes/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  renderTemplate: function() {\n    this.render({ controller: 'favoritePost' });\n  }\n});\n\n\n\nEmber allows you to name your outlets. For instance, this code allows\nyou to specify two outlets with distinct names:\n\n  \n    \n      app/templates/application.hbs\n    \n  \n\n  1\n2\n\n  \u003cdiv class=\"toolbar\"\u003e{{outlet \"toolbar\"}}\u003c/div\u003e\n\u003cdiv class=\"sidebar\"\u003e{{outlet \"sidebar\"}}\u003c/div\u003e\n\n\n\nSo, if you want to render your posts into the sidebar outlet, use code\nlike this:\n\n  \n    \n      app/routes/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  renderTemplate: function() {\n    this.render({ outlet: 'sidebar' });\n  }\n});\n\n\n\nAll of the options described above can be used together in whatever\ncombination you'd like:\n\n  \n    \n      app/routes/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  export default Ember.Route.extend({\n  renderTemplate: function() {\n    var controller = this.controllerFor('favoritePost');\n\n    // Render the `favoritePost` template into\n    // the outlet `posts`, and use the `favoritePost`\n    // controller.\n    this.render('favoritePost', {\n      outlet: 'posts',\n      controller: controller\n    });\n  }\n});\n\n\n\nIf you want to render two different templates into outlets of two different rendered templates of a route:\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  export default Ember.Route.extend({\n  renderTemplate: function() {\n    this.render('favoritePost', {   // the template to render\n      into: 'posts',                // the template to render into\n      outlet: 'posts',              // the name of the outlet in that template\n      controller: 'blogPost'        // the controller to use for the template\n    });\n    this.render('comments', {\n      into: 'favoritePost',\n      outlet: 'comment',\n      controller: 'blogPost'\n    });\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d03c0729ed2df89a208ead1f07dcf9fd","fields":[{"name":"title","value":"Setting Up a Controller","type":"string"},{"name":"url","value":"/routing/setting-up-a-controller/","type":"enum"},{"name":"body","value":"Changing the URL may also change which template is displayed on\nscreen. Templates, however, are usually only useful if they have some\nsource of information to display.\n\nIn Ember.js, a template retrieves information to display from a\ncontroller.\n\nThere is a special built-in controllerâ Ember.ArrayController âto make it easy to\npresent some collections properties to a template, along with any additional\ndisplay-specific properties.\n\nTo tell the controller which model to present, set its\nmodel property in the route handler's setupController hook.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('post', { path: '/posts/:post_id' });\n});\n\n\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  // The code below is the default behavior, so if this is all you\n  // need, you do not need to provide a setupController implementation\n  // at all.\n  setupController: function(controller, model) {\n    controller.set('model', model);\n  }\n});\n\n\n\nThe setupController hook receives the route handler's associated\ncontroller as its first argument. In this case, the PostRoute's\nsetupController receives the application's instance of\ncontroller:posts.\n\nTo specify a controller other than the default, set the route's\ncontrollerName property:\n\n  \n    \n      app/routes/special-post.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Route.extend({\n  controllerName: 'post'\n});\n\n\n\nAs a second argument, it receives the route handler's model. For more\ninformation, see Specifying a Route's Model.\n\nThe default setupController hook sets the model property of the\nassociated controller to the route handler's model.\n\nIf you want to configure a controller other than the controller\nassociated with the route handler, use the controllerFor method:\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  setupController: function(controller, model) {\n    this.controllerFor('topPost').set('model', model);\n  }\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d94b756c7278f11f9a951d1a47d8640f","fields":[{"name":"title","value":"Specifying a Route's Model","type":"string"},{"name":"url","value":"/routing/specifying-a-routes-model/","type":"enum"},{"name":"body","value":"Templates in your application are backed by models. But how do templates\nknow which model they should display?\n\nFor example, if you have a photos template, how does it know which\nmodel to render?\n\nThis is one of the jobs of an Ember.Route. You can tell a template\nwhich model it should render by defining a route with the same name as\nthe template, and implementing its model hook.\n\nFor example, to provide some model data to the photos template, we\nwould define an route:photos object:\n\n  \n    \n      app/routes/photos.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Route.extend({\n  model: function() {\n    return [{\n      title: \"Tomster\",\n      url: \"http://emberjs.com/images/about/ember-productivity-sm.png\"\n    }, {\n      title: \"Eiffel Tower\",\n      url: \"http://emberjs.com/images/about/ember-structure-sm.png\"\n    }];\n  }\n});\n\n\n\nJS Bin\nAsynchronously Loading Models\nIn the above example, the model data was returned synchronously from the\nmodel hook. This means that the data was available immediately and\nyour application did not need to wait for it to load, in this case\nbecause we immediately returned an array of hardcoded data.\n\nOf course, this is not always realistic. Usually, the data will not be\navailable synchronously, but instead must be loaded asynchronously over\nthe network. For example, we may want to retrieve the list of photos\nfrom a JSON API available on our server.\n\nIn cases where data is available asynchronously, you can just return a\npromise from the model hook, and Ember will wait until that promise is\nresolved before rendering the template.\n\nIf you're unfamiliar with promises, the basic idea is that they are\nobjects that represent eventual values. For example, if you use jQuery's\ngetJSON() method, it will return a promise for the JSON that is\neventually returned over the network. Ember uses this promise object to\nknow when it has enough data to continue rendering.\n\nFor more about promises, see A Word on\nPromises\nin the Asynchronous Routing guide.\n\nLet's look at an example in action. Here's a route that loads the most\nrecent pull requests sent to Ember.js on GitHub:\n\n  \n    \n      app/routes/pull-requests.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model: function() {\n    return Ember.$.getJSON('https://api.github.com/repos/emberjs/ember.js/pulls');\n  }\n});\n\n\n\nWhile this example looks like it's synchronous, making it easy to read\nand reason about, it's actually completely asynchronous. That's because\njQuery's getJSON() method returns a promise. Ember will detect the\nfact that you've returned a promise from the model hook, and wait\nuntil that promise resolves to render the pullRequests template.\n\n(For more information on jQuery's XHR functionality, see\njQuery.ajax in the jQuery\ndocumentation.)\n\nBecause Ember supports promises, it can work with any persistence\nlibrary that uses them as part of its public API. You can also use many\nof the conveniences built in to promises to make your code even nicer.\n\nFor example, imagine if we wanted to modify the above example so that\nthe template only displayed the three most recent pull requests. We can\nrely on promise chaining to modify the data returned from the JSON\nrequest before it gets passed to the template:\n\n  \n    \n      app/routes/pull-requests.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  model: function() {\n    var url = 'https://api.github.com/repos/emberjs/ember.js/pulls';\n    return Ember.$.getJSON(url).then(function(data) {\n      return data.splice(0, 3);\n    });\n  }\n});\n\n\nSetting Up Controllers with the Model\nSo what actually happens with the value you return from the model\nhook?\n\nBy default, the value returned from your model hook will be assigned\nto the model property of the associated controller. For example, if your\nroute:posts returns an object from its model hook, that object\nwill be set as the model property of the controller:posts.\n\n(This, under the hood, is how templates know which model to render: they\nlook at their associated controller's model property. For example, the\nphotos template will render whatever the controller:photos's\nmodel property is set to.)\n\nSee the Setting Up a Controller guide to learn how to change this\ndefault behavior. Note that if you override the default behavior and do\nnot set the model property on a controller, your template will not\nhave any data to render!\nDynamic Models\nSome routes always display the same model. For example, the /photos\nroute will always display the same list of photos available in the\napplication. If your user leaves this route and comes back later, the\nmodel does not change.\n\nHowever, you will often have a route whose model will change depending\non user interaction. For example, imagine a photo viewer app. The\n/photos route will render the photos template with the list of\nphotos as the model, which never changes. But when the user clicks on a\nparticular photo, we want to display that model with the photo\ntemplate. If the user goes back and clicks on a different photo, we want\nto display the photo template again, this time with a different model.\n\nIn cases like this, it's important that we include some information in\nthe URL about not only which template to display, but also which model.\n\nIn Ember, this is accomplished by defining routes with dynamic segments.\n\nA dynamic segment is a part of the URL that is filled in by the current\nmodel's ID. Dynamic segments always start with a colon (:). Our photo\nexample might have its photo route defined like this:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('photo', { path: '/photos/:photo_id' });\n});\n\n\n\nIn this example, the photo route has a dynamic segment :photo_id.\nWhen the user goes to the photo route to display a particular photo\nmodel (usually via the {{link-to}} helper), that model's ID will be\nplaced into the URL automatically.\n\nSee Links for more information about linking\nto a route with a model using the {{link-to}} helper.\n\nFor example, if you transitioned to the photo route with a model whose\nid property was 47, the URL in the user's browser would be updated\nto:\n\n  1\n\n  /photos/47\n\n\n\nWhat happens if the user visits your application directly with a URL\nthat contains a dynamic segment? For example, they might reload the\npage, or send the link to a friend, who clicks on it. At that point,\nbecause we are starting the application up from scratch, the actual\nJavaScript model object to display has been lost; all we have is the ID\nfrom the URL.\n\nLuckily, Ember will extract any dynamic segments from the URL for\nyou and pass them as a hash to the model hook as the first argument:\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Router.map(function() {\n  this.route('photo', { path: '/photos/:photo_id' });\n});\n\n\n\n  \n    \n      app/routes/photo.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Route.extend({\n  model: function(params) {\n    return Ember.$.getJSON('/photos/'+params.photo_id);\n  }\n});\n\n\n\nIn the model hook for routes with dynamic segments, it's your job to\nturn the ID (something like 47 or post-slug) into a model that can\nbe rendered by the route's template. In the above example, we use the\nphoto's ID (params.photo_id) to construct a URL for the JSON\nrepresentation of that photo. Once we have the URL, we use jQuery to\nreturn a promise for the JSON model data.\n\nNote: A route with a dynamic segment will only have its model hook called\nwhen it is entered via the URL. If the route is entered through a transition\n(e.g. when using the link-to Handlebars helper), then a model context is\nalready provided and the hook is not executed. Routes without dynamic segments\nwill always execute the model hook.\nRefreshing your model\nIf your data represented by your model is being updated frequently, you may\nwant to refresh it periodically:\n\nJS Bin\n\nThe controller can send an action to the Route; in this example above, the\nIndexController exposes an action getLatest which sends the route an\naction called invalidateModel. Calling the route's refresh method will force\nEmber to execute the model hook again.\nEmber Data\nMany Ember developers use a model library to make finding and saving\nrecords easier than manually managing Ajax calls. In particular, using a\nmodel library allows you to cache records that have been loaded,\nsignificantly improving the performance of your application.\n\nOne popular model library built for Ember is Ember Data. To learn more\nabout using Ember Data to manage your models, see the\nModels guide.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6e746c1a547709a4f7e74f0ab1401f16","fields":[{"name":"title","value":"Specifying the URL Type","type":"string"},{"name":"url","value":"/routing/specifying-the-location-api/","type":"enum"},{"name":"body","value":"By default the Router uses the browser's hash to load the starting state of your\napplication and will keep it in sync as you move around. At present, this relies\non a hashchange event existing in the browser.\n\nGiven the following router, entering /#/posts/new will take you to the posts.new\nroute.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route('posts', function() {\n    this.route('new');\n  });\n});\n\n\n\nIf you want to remove the #/ at the beginning so that the URL is simply /posts/new,\nyou can tell the Router to use the browser's history API.\n\nKeep in mind that your server must serve the Ember app from all the URLs defined in your\nRouter.map function.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Ember.Router.extend({\n  location: 'history'\n});\n\n\n\nFinally, if you don't want the browser's URL to interact with your application\nat all, you can disable the location API entirely. This is useful for\ntesting, or when you need to manage state with your Router, but temporarily\ndon't want it to muck with the URL (for example when you embed your\napplication in a larger page).\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n\n  Ember.Router.extend({\n  location: 'none'\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"1b11151882558c3e878b1c432610d998","fields":[{"name":"title","value":"Actions","type":"string"},{"name":"url","value":"/templates/actions/","type":"enum"},{"name":"body","value":"The {{action}} Helper\nYour app will often need a way to let users interact with controls that\nchange application state. For example, imagine that you have a template\nthat shows a blog post, and supports expanding the post with additional\ninformation.\n\nYou can use the {{action}} helper to make an HTML element clickable.\nWhen a user clicks the element, the named event will be sent to your\napplication.\n\n  \n    \n      app/templates/post.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  \u003cdiv class='intro'\u003e\n  {{intro}}\n\u003c/div\u003e\n\n{{#if isExpanded}}\n  \u003cdiv class='body'\u003e{{body}}\u003c/div\u003e\n  \u003cbutton {{action 'contract'}}\u003eContract\u003c/button\u003e\n{{else}}\n  \u003cbutton {{action 'expand'}}\u003eShow More...\u003c/button\u003e\n{{/if}}\n\n\n\n  \n    \n      app/controllers/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n  export default Ember.Controller.extend({\n  intro: Ember.computed.alias('model.intro'),\n  body: Ember.computed.alias('model.body'),\n\n  // initial value\n  isExpanded: false,\n\n  actions: {\n    expand: function() {\n      this.set('isExpanded', true);\n    },\n\n    contract: function() {\n      this.set('isExpanded', false);\n    }\n  }\n});\n\n\n\nNote that actions may be attached to any element of the DOM, but not all\nrespond to the click event. For example, if an action is attached to an a\nlink without an href attribute, or to a div, some browsers won't execute\nthe associated function. If it's really needed to define actions over such\nelements, a CSS workaround exists to make them clickable, cursor: pointer.\nFor example:\n\n  1\n2\n3\n\n  [data-ember-action] {\n  cursor: pointer;\n}\n\n\nAction Bubbling\nBy default, the {{action}} helper triggers a method on the template's\ncontroller, as illustrated above.\n\nIf the controller does not implement a method with the same name as the\naction in its actions object, the action will be sent to the router, where\nthe currently active leaf route will be given a chance to handle the action.\n\nRoutes and controllers that handle actions must place action handlers\ninside an actions hash. Even if a route has a method with the same name\nas the actions, it will not be triggered unless it is inside an actions hash.\nIn the case of a controller, while there is deprecated support for triggering\na method directly on the controller, it is strongly recommended that you\nput your action handling methods inside an actions hash for forward\ncompatibility.\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Route.extend({\n  actions: {\n    expand: function() {\n      this.controller.set('isExpanded', true);\n    },\n\n    contract: function() {\n      this.controller.set('isExpanded', false);\n    }\n  }\n});\n\n\n\nAs you can see in this example, the action handlers are called such\nthat when executed, this is the route, not the actions hash.\n\nTo continue bubbling the action, you must return true from the handler:\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  export default Ember.Route.extend({\n  actions: {\n    expand: function() {\n      this.controller.set('isExpanded', true);\n    },\n\n    contract: function() {\n      // ...\n      if (actionShouldAlsoBeTriggeredOnParentRoute) {\n        return true;\n      }\n    }\n  }\n});\n\n\n\nIf neither the template's controller nor the currently active route\nimplements a handler, the action will continue to bubble to any parent\nroutes. Ultimately, if an ApplicationRoute is defined, it will have an\nopportunity to handle the action.\n\nWhen an action is triggered, but no matching action handler is\nimplemented on the controller, the current route, or any of the\ncurrent route's ancestors, an error will be thrown.\n\n\n\nThis allows you to create a button that has different behavior based on\nwhere you are in the application. For example, you might want to have a\nbutton in a sidebar that does one thing if you are somewhere inside of\nthe /posts route, and another thing if you are inside of the /about\nroute.\nAction Parameters\nYou can optionally pass arguments to the action handler. Any values\npassed to the {{action}} helper after the action name will be passed to\nthe handler as arguments.\n\nFor example, if the post argument was passed:\n\n  1\n\n  \u003cp\u003e\u003cbutton {{action \"select\" post}}\u003eâ\u003c/button\u003e {{post.title}}\u003c/p\u003e\n\n\n\nThe controller's select action handler would be called with a single argument\ncontaining the post model:\n\n  \n    \n      app/controllers/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Controller.extend({\n  actions: {\n    select: function(post) {\n      console.log(post.get('title'));\n    }\n  }\n});\n\n\nSpecifying the Type of Event\nBy default, the {{action}} helper listens for click events and triggers\nthe action when the user clicks on the element.\n\nYou can specify an alternative event by using the on option.\n\n  1\n2\n3\n4\n\n  \u003cp\u003e\n  \u003cbutton {{action \"select\" post on=\"mouseUp\"}}\u003eâ\u003c/button\u003e\n  {{post.title}}\n\u003c/p\u003e\n\n\n\nYou should use the normalized event names listed in the View guide.\nIn general, two-word event names (like keypress) become keyPress.\nSpecifying Whitelisted Modifier Keys\nBy default the {{action}} helper will ignore click events with\npressed modifier keys. You can supply an allowedKeys option\nto specify which keys should not be ignored.\n\n  1\n2\n3\n\n  \u003cdiv {{action 'anActionName' allowedKeys=\"alt\"}}\u003e\n  click me\n\u003c/div\u003e\n\n\n\nThis way the {{action}} will fire when clicking with the alt key\npressed down.\nStopping Event Propagation\nBy default, the {{action}} helper allows events it handles to bubble\nup to parent DOM nodes. If you want to stop propagation, you can disable\npropagation to the parent node.\n\nFor example, if you have a â button inside of a link, you will want\nto ensure that if the user clicks on the â, that the link is not\nclicked.\n\n  1\n2\n3\n4\n\n  {{#link-to 'post'}}\n  Post\n  \u003cbutton {{action 'close' bubbles=false}}\u003eâ\u003c/button\u003e\n{{/link-to}}\n\n\n\nWithout bubbles=false, if the user clicked on the button, Ember.js\nwill trigger the action, and then the browser will propagate the click\nto the link.\n\nWith bubbles=false, Ember.js will stop the browser from propagating\nthe event.\nSpecifying a Target\nBy default, the {{action}} helper will send the action to the view's\ntarget, which is generally the view's controller. (Note: in the case of\nan Ember.Component, the default target is the component itself.)\n\nYou can specify an alternative target by using the target option. This\nis most commonly used to send actions to a view instead of a controller.\n\n  1\n2\n3\n4\n\n  \u003cp\u003e\n  \u003cbutton {{action \"select\" post target=view}}\u003eâ\u003c/button\u003e\n  {{post.title}}\n\u003c/p\u003e\n\n\n\nYou would handle this in an actions hash on your view.\n\n  \n    \n      app/views/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.View.extend({\n  actions: {\n    select: function(post) {\n      // do your business.\n    }\n  }\n});\n\n\n\nNote that actions sent to views in this way do not bubble up the\ncurrently rendered view hierarchy. If you want to handle the action in\na parent view, use the following:\n\n  1\n2\n3\n4\n\n  \u003cp\u003e\n  \u003cbutton {{action \"select\" post target=view.parentView}}\u003eâ\u003c/button\u003e\n  {{post.title}}\n\u003c/p\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"59c50884dd61207af6fc0a831825eb47","fields":[{"name":"title","value":"Binding Element Attributes","type":"string"},{"name":"url","value":"/templates/binding-element-attributes/","type":"enum"},{"name":"body","value":"In addition to normal text, you may also want to have your templates\ncontain HTML elements whose attributes are bound to the controller.\n\nFor example, imagine your controller has a property that contains a URL\nto an image:\n\n  1\n2\n3\n\n  \u003cdiv id=\"logo\"\u003e\n  \u003cimg src={{logoUrl}} alt=\"Logo\"\u003e\n\u003c/div\u003e\n\n\n\nThis generates the following HTML:\n\n  1\n2\n3\n\n  \u003cdiv id=\"logo\"\u003e\n  \u003cimg src=\"http://www.example.com/images/logo.png\" alt=\"Logo\"\u003e\n\u003c/div\u003e\n\n\n\nIf you use data binding with a Boolean value, it will add or remove\nthe specified attribute. For example, given this template:\n\n  1\n\n  \u003cinput type=\"checkbox\" disabled={{isAdministrator}}\u003e\n\n\n\nIf isAdministrator is true, Handlebars will produce the following\nHTML element:\n\n  1\n\n  \u003cinput type=\"checkbox\" disabled\u003e\n\n\n\nIf isAdministrator is false, Handlebars will produce the following:\n\n  1\n\n  \u003cinput type=\"checkbox\"\u003e\n\n\nAdding data attributes\nBy default, view helpers do not accept data attributes. For example\n\n  1\n2\n3\n\n  {{#link-to \"photos\" data-toggle=\"dropdown\"}}Photos{{/link-to}}\n\n{{input type=\"text\" data-toggle=\"tooltip\" data-placement=\"bottom\" title=\"Name\"}}\n\n\n\nrenders the following HTML:\n\n  1\n2\n3\n\n  \u003ca id=\"ember239\" class=\"ember-view\" href=\"#/photos\"\u003ePhotos\u003c/a\u003e\n\n\u003cinput id=\"ember257\" class=\"ember-view ember-text-field\" type=\"text\" title=\"Name\"\u003e\n\n\n\nThere are two ways to enable support for data attributes. One way would be to add an\nattribute binding on the view, e.g. Ember.LinkView or Ember.TextField for the specific attribute:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.LinkView.reopen({\n  attributeBindings: ['data-toggle']\n});\n\nexport default Ember.TextField.reopen({\n  attributeBindings: ['data-toggle', 'data-placement']\n});\n\n\n\nNow the same handlebars code above renders the following HTML:\n\n  1\n2\n3\n4\n\n  \u003ca id=\"ember240\" class=\"ember-view\" href=\"#/photos\" data-toggle=\"dropdown\"\u003ePhotos\u003c/a\u003e\n\n\u003cinput id=\"ember259\" class=\"ember-view ember-text-field\"\n       type=\"text\" data-toggle=\"tooltip\" data-placement=\"bottom\" title=\"Name\"\u003e\n\n\n\nYou can also automatically bind data attributes on the base view with the\nfollowing:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  export default Ember.View.reopen({\n  init: function() {\n    this._super();\n    var self = this;\n\n    // bind attributes beginning with 'data-'\n    Ember.keys(this).forEach(function(key) {\n      if (key.substr(0, 5) === 'data-') {\n        self.get('attributeBindings').pushObject(key);\n      }\n    });\n  }\n});\n\n\n\nNow you can add as many data-attributes as you want without having to specify them by name.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"e478e22e0d1033f8572e38161a50bf9a","fields":[{"name":"title","value":"Binding Element Class Names","type":"string"},{"name":"url","value":"/templates/binding-element-class-names/","type":"enum"},{"name":"body","value":"An HTML element's class attribute can be bound like any other\nattribute:\n\n  1\n2\n3\n\n  \u003cdiv class={{priority}}\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nIf the component's priority property is \"p4\", this template will emit the following HTML:\n\n  1\n2\n3\n\n  \u003cdiv class=\"p4\"\u003e\n  Warning!\n\u003c/div\u003e\n\n\nConditional Values\nIf you want a class value based on a conditional property, use the Handlebars if helper:\n\n  1\n2\n3\n\n  \u003cdiv class={{if isUrgent 'is-urgent'}}\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nIf isUrgent is true, this emits the following HTML:\n\n  1\n2\n3\n\n  \u003cdiv class=\"is-urgent\"\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nIf isUrgent is false, no class name is added:\n\n  1\n2\n3\n\n  \u003cdiv\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nYou can also specify a class name to add when the property is false:\n\n  1\n2\n3\n\n  \u003cdiv class={{if isEnabled 'enabled' 'disabled'}}\u003e\n  Warning!\n\u003c/div\u003e\n\n\n\nIn this case, if the isEnabled property is true, the enabled\nclass will be added. If the property is false, the class disabled\nwill be added.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"95d724148efe2cc1481ae51952ecf2b7","fields":[{"name":"title","value":"Conditionals","type":"string"},{"name":"url","value":"/templates/conditionals/","type":"enum"},{"name":"body","value":"Sometimes you may only want to display part of your template if a property\nexists.\n\nWe can use the {{#if}} helper to conditionally render a block:\n\n  1\n2\n3\n\n  {{#if person}}\n  Welcome back, \u003cb\u003e{{person.firstName}} {{person.lastName}}\u003c/b\u003e!\n{{/if}}\n\n\n\nHandlebars will not render the block if the argument passed evaluates to\nfalse, undefined, null or [] (i.e., any \"falsy\" value).\n\nIf the expression evaluates to falsy, we can also display an alternate template\nusing {{else}}:\n\n  1\n2\n3\n4\n5\n\n  {{#if person}}\n  Welcome back, \u003cb\u003e{{person.firstName}} {{person.lastName}}\u003c/b\u003e!\n{{else}}\n  Please log in.\n{{/if}}\n\n\n\nHandlebars also supports chained else helpers, the most common use being else if. An example:\n\n  1\n2\n3\n4\n5\n\n  {{#if isAtWork}}\n  Ship that code!\n{{else if isReading}}\n  You can finish War and Peace eventually...\n{{/if}}\n\n\n\nTo only render a block if a value is falsy, use {{#unless}}:\n\n  1\n2\n3\n\n  {{#unless hasPaid}}\n  You owe: ${{total}}\n{{/unless}}\n\n\n\n{{#if}} and {{#unless}} are examples of block expressions. These allow you\nto invoke a helper with a portion of your template. Block expressions look like\nnormal expressions except that they contain a hash (#) before the helper name,\nand require a closing expression.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6a114533ff2793c31df860c375985bcb","fields":[{"name":"title","value":"Development Helpers","type":"string"},{"name":"url","value":"/templates/development-helpers/","type":"enum"},{"name":"body","value":"Development Helpers\nHandlebars and Ember come with a few helpers that can make developing your\ntemplates a bit easier. These helpers make it simple to output variables into\nyour browser's console, or activate the debugger from your templates.\nLogging\nThe {{log}} helper makes it easy to output variables or expressions in the\ncurrent rendering context into your browser's console:\n\n  1\n\n  {{log 'Name is:' name}}\n\n\n\nThe {{log}} helper also accepts primitive types such as strings or numbers.\nAdding a breakpoint\nThe {{debugger}} helper provides a handlebars equivalent to JavaScript's\ndebugger keyword.  It will halt execution inside the debugger helper and give\nyou the ability to inspect the current rendering context:\n\n  1\n\n  {{debugger}}\n\n\n\nJust before the helper is invoked two useful variables are defined:\n\n\ntemplateContext The current context that variables are fetched from. This\nis likely a controller.\ntypeOfTemplateContext A string describing what the templateContext is.\n\n\nFor example, if you are wondering why a specific variable isn't displaying in\nyour template, you could use the {{debugger}} helper. When the breakpoint is\nhit, you can use the templateContext in your console to lookup properties:\n\n  1\n2\n\n  \u003e templateContext.get('name')\n\"Bruce Lee\"\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"94f518795fa706013cfd0ed73c5a9d3c","fields":[{"name":"title","value":"Displaying a List of Items","type":"string"},{"name":"url","value":"/templates/displaying-a-list-of-items/","type":"enum"},{"name":"body","value":"If you need to enumerate over a list of objects, use Handlebars' {{#each}} helper:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each people as |person|}}\n    \u003cli\u003eHello, {{person.name}}!\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nThe template inside of the {{#each}} block will be repeated once for\neach item in the array, with the each item set to the person keyword.\n\nThe above example will print a list like this:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  \u003cli\u003eHello, Yehuda!\u003c/li\u003e\n  \u003cli\u003eHello, Tom!\u003c/li\u003e\n  \u003cli\u003eHello, Trek!\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\nLike everything in Handlebars, the {{#each}} helper is bindings-aware.\nIf your application adds a new item to the array, or removes an item,\nthe DOM will be updated without having to write any code.\n\nThe {{#each}} helper can have a matching {{else}}.\nThe contents of this block will render if the collection is empty:\n\n  1\n2\n3\n4\n5\n\n  {{#each people as |person|}}\n  Hello, {{person.name}}!\n{{else}}\n  Sorry, nobody is here.\n{{/each}}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"619a7f1e4091d5852889772b71be63d0","fields":[{"name":"title","value":"Handlebars Basics","type":"string"},{"name":"url","value":"/templates/handlebars-basics/","type":"enum"},{"name":"body","value":"Ember.js uses the Handlebars templating library\nto power your app's user interface. Handlebars templates are just like\nregular HTML, but also give you the ability to embed expressions that\nchange what is displayed.\n\nWe take Handlebars and extend it with many powerful features. It may\nhelp to think of your Handlebars templates as an HTML-like DSL for\ndescribing the user interface of your app. And, once you've told\nEmber.js to render a given template on the screen, you don't need to\nwrite any additional code to make sure it keeps up-to-date.\nDefining Templates\nBy default, adjust your application template, that is created automatically for you and will be displayed on the page when your app loads.\n\nYou can also define templates by name that can be used later. If you would like to create a template that is shared across many areas of your site, you should investigate components. The components section contains information on creating re-usable templates.\nHandlebars Expressions\nEach template has an associated controller: this is where the template\nfinds the properties that it displays.\n\nYou can display a property from your controller by wrapping the property\nname in curly braces, like this:\n\n  1\n\n  Hello, \u003cstrong\u003e{{firstName}} {{lastName}}\u003c/strong\u003e!\n\n\n\nThis would look up the firstName and lastName properties from the\ncontroller, insert them into the HTML described in the template, then\nput them into the DOM.\n\nBy default, your top-most application template is bound to your application controller. Note that this file is not shown by default because it is created behind the scenes by Ember CLI. To customize the controller, create the following file:\n\n  \n    \n      app/controllers/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Controller.extend({\n  firstName: \"Trek\",\n  lastName: \"Glowacki\"\n});\n\n\n\n\nThe above template and controller would combine to display the following\nrendered HTML:\n\n  1\n\n  Hello, \u003cstrong\u003eTrek Glowacki\u003c/strong\u003e!\n\n\n\nThese expressions (and the other Handlebars features you will learn\nabout next) are bindings aware. That means that if the values used\nby your templates ever change, your HTML will be updated automatically.\n\nAs your application grows in size, it will have many templates, each\nbound to different controllers.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"cbc42197752a02e932444274327e4808","fields":[{"name":"title","value":"Input Helpers","type":"string"},{"name":"url","value":"/templates/input-helpers/","type":"enum"},{"name":"body","value":"Input Helpers\nThe {{input}} and {{textarea}} helpers in Ember.js are the easiest way to\ncreate common form controls. The {{input}} helper wraps the built-in\nEmber.TextField and Ember.Checkbox views, while {{textarea}} wraps\nEmber.TextArea. Using these helpers, you can create these views with\ndeclarations almost identical to how you'd create a traditional \u003cinput\u003e or\n\u003ctextarea\u003e element.\nText fields\n  1\n\n  {{input value=\"http://www.facebook.com\"}}\n\n\n\nWill become:\n\n  1\n\n  \u003cinput type=\"text\" value=\"http://www.facebook.com\"/\u003e\n\n\n\nYou can pass the following standard \u003cinput\u003e attributes within the input\nhelper:\n\n\n  `readonly``required``autofocus`\n  `value``placeholder``disabled`\n  `size``tabindex``maxlength`\n  `name``min``max`\n  `pattern``accept``autocomplete`\n  `autosave``formaction``formenctype`\n  `formmethod``formnovalidate``formtarget`\n  `height``inputmode``multiple`\n  `step``width``form`\n  `selectionDirection``spellcheck`Â \n\n\nIf these attributes are set to a quoted string, their values will be set\ndirectly on the element, as in the previous example. However, when left\nunquoted, these values will be bound to a property on the template's current\nrendering context. For example:\n\n  1\n\n  {{input type=\"text\" value=firstName disabled=entryNotAllowed size=\"50\"}}\n\n\n\nWill bind the disabled attribute to the value of entryNotAllowed in the\ncurrent context.\nActions\nTo dispatch an action on specific events, such as enter or key-press, use the following\n\n  1\n\n  {{input value=firstName action=\"updateFirstName\" on=\"key-press\"}}\n\n\n\nEvent Names must be dasherized when assigned to on.\nCheckboxes\nYou can also use the {{input}} helper to create a checkbox by setting its\ntype:\n\n  1\n\n  {{input type=\"checkbox\" name=\"isAdmin\" checked=isAdmin}}\n\n\n\nCheckboxes support the following properties:\n\n\nchecked\ndisabled\ntabindex\nindeterminate\nname\nautofocus\nform\n\n\nWhich can be bound or set as described in the previous section.\nText Areas\n  1\n\n  {{textarea value=name cols=\"80\" rows=\"6\"}}\n\n\n\nWill bind the value of the text area to name on the current context.\n\n{{textarea}} supports binding and/or setting the following properties:\n\n\nvalue\nname\nrows\ncols\nplaceholder\ndisabled\nmaxlength\ntabindex\nselectionEnd\nselectionStart\nselectionDirection\nwrap\nreadonly\nautofocus\nform\nspellcheck\nrequired\n\nExtending Built-In Controls\nSee the Built-in Views section of these guides to learn how to further\nextend these views.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"a3506f82f88ccbc90b445c4c8d73f39a","fields":[{"name":"title","value":"Links","type":"string"},{"name":"url","value":"/templates/links/","type":"enum"},{"name":"body","value":"The {{link-to}} Helper\nYou create a link to a route using the {{link-to}} helper.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  Router.map(function() {\n  this.route(\"photos\", function(){\n    this.route(\"edit\", { path: \"/:photo_id\" });\n  });\n});\n\n\n\n  \n    \n      app/templates/photos.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  {{#each photos as |photo|}}\n    \u003cli\u003e{{#link-to 'photos.edit' photo}}{{photo.title}}{{/link-to}}\u003c/li\u003e\n  {{/each}}\n\u003c/ul\u003e\n\n\n\nIf the model for the photos template is a list of three photos, the\nrendered HTML would look something like this:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  \u003cli\u003e\u003ca href=\"/photos/1\"\u003eHappy Kittens\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/2\"\u003ePuppy Running\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/3\"\u003eMountain Landscape\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\nThe {{link-to}} helper takes one or two arguments:\n\n\nThe name of a route. In this example, it would be index, photos, or\nphotos.edit.\nAt most one model for each dynamic segment.\nBy default, Ember.js will replace each segment with the value of the corresponding object's id property.\nIn the example above, the second argument is each photo object, and the id property is used to fill in\nthe dynamic segment with either 1, 2, or 3. If there is no model to pass to the helper, you can provide\nan explicit value instead:\n\n\n  \n    \n      app/templates/photos.hbs\n    \n  \n\n  1\n2\n3\n\n  {{#link-to 'photos.photo.edit' 1}}\n  First Photo Ever\n{{/link-to}}\n\n\n\nWhen the rendered link matches the current route, and the same\nobject instance is passed into the helper, then the link is given\nclass=\"active\". For example, if you were at the URL /photos/2,\nthe first example above would render as:\n\n  1\n2\n3\n4\n5\n\n  \u003cul\u003e\n  \u003cli\u003e\u003ca href=\"/photos/1\"\u003eHappy Kittens\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/2\" class=\"active\"\u003ePuppy Running\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/photos/3\"\u003eMountain Landscape\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\nExample for Multiple Segments\nIf the route is nested, you can supply a model or an identifier for each dynamic\nsegment.\n\n  \n    \n      app/router.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  Router.map(function() {\n  this.route(\"photos\", function(){\n    this.route(\"photo\", { path: \"/:photo_id\" }, function(){\n      this.route(\"comments\");\n      this.route(\"comment\", { path: \"/comments/:comment_id\" });\n    });\n  });\n});\n\n\n\n  \n    \n      app/templates/photo/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003cdiv class=\"photo\"\u003e\n  {{body}}\n\u003c/div\u003e\n\n\u003cp\u003e{{#link-to 'photos.photo.comment' primaryComment}}Main Comment{{/link-to}}\u003c/p\u003e\n\n\n\nIf you specify only one model, it will represent the innermost dynamic segment :comment_id.\nThe :photo_id segment will use the current photo.\n\nAlternatively, you could pass both a photo's ID and a comment to the helper:\n\n  \n    \n      app/templates/photo/index.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n\n  \u003cp\u003e\n  {{#link-to 'photo.comment' 5 primaryComment}}\n    Main Comment for the Next Photo\n  {{/link-to}}\n\u003c/p\u003e\n\n\n\nIn the above example, the model hook for PhotoRoute will run with params.photo_id = 5.  The model hook for\nCommentRoute won't run since you supplied a model object for the comment segment. The comment's id will\npopulate the url according to CommentRoute's serialize hook.\nUsing link-to as an inline helper\nIn addition to being used as a block expression, the link-to helper\ncan also be used in inline form by specifying the link text as the first\nargument to the helper:\n\n  1\n2\n\n  A link in {{#link-to 'index'}}Block Expression Form{{/link-to}},\nand a link in {{link-to 'Inline Form' 'index'}}.\n\n\n\nThe output of the above would be:\n\n  1\n2\n\n  A link in \u003ca href='/'\u003eBlock Expression Form\u003c/a\u003e,\nand a link in \u003ca href='/'\u003eInline Form\u003c/a\u003e.\n\n\nAdding additional attributes on a link\nWhen generating a link you might want to set additional attributes for it. You can do this with additional\narguments to the link-to helper:\n\n  1\n2\n3\n\n  \u003cp\u003e\n  {{link-to 'Edit this photo' 'photo.edit' photo class=\"btn btn-primary\"}}\n\u003c/p\u003e\n\n\n\nMany of the common HTML properties you would want to use like class, and rel will work. When\nadding class names, Ember will also apply the standard ember-view and possibly active class names.\nReplacing history entries\nThe default behavior for link-to is to add entries to the browser's history\nwhen transitioning between the routes. However, to replace the current entry in\nthe browser's history you can use the replace=true option:\n\n  1\n2\n3\n4\n5\n\n  \u003cp\u003e\n  {{#link-to 'photo.comment' 5 primaryComment replace=true}}\n    Main Comment for the Next Photo\n  {{/link-to}}\n\u003c/p\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"bc7ea295f86185ac867cf8954eef551a","fields":[{"name":"title","value":"Rendering with Helpers","type":"string"},{"name":"url","value":"/templates/rendering-with-helpers/","type":"enum"},{"name":"body","value":"Ember.js provides several helpers that allow you to render other views and templates in different ways.\nThe {{partial}} Helper\n{{partial}} takes the template to be rendered as an argument, and renders that template in place.\n\n{{partial}} does not change context or scope.  It simply drops the given template into place with the current scope.\n\n  \n    \n      app/templates/author.hbs\n    \n  \n\n  1\n\n  Written by {{author.firstName}} {{author.lastName}}\n\n\n\n  \n    \n      app/templates/post.hbs\n    \n  \n\n  1\n2\n3\n\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n\u003cdiv\u003e{{body}}\u003c/div\u003e\n{{partial \"author\"}}\n\n\n\nOutput:\n\n  1\n2\n3\n4\n5\n\n  \u003cdiv\u003e\n  \u003ch1\u003eWhy You Should Use Ember.js\u003c/h1\u003e\n  \u003cdiv\u003eBecause it's awesome!\u003c/div\u003e\n  Written by Yehuda Katz\n\u003c/div\u003e\n\n\nThe {{view}} Helper\nThis helper works like the partial helper, except instead of providing a template to be rendered within the current template, you provide a view class.  The view controls what template is rendered.\n\n  \n    \n      app/views/author.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default Ember.View.extend({\n  // We are setting templateName manually here to the default value\n  templateName: \"author\",\n\n  // A fullName property should probably go on the model,\n  // but we're doing it here for the sake of example\n  fullName: (function() {\n    return this.get(\"author.firstName\") + \" \" + this.get(\"author.lastName\");\n  }).property(\"firstName\",\"lastName\")\n})\n\n\n\n  \n    \n      app/views/author.hbs\n    \n  \n\n  1\n\n  Written by {{view.fullName}}\n\n\n\n  \n    \n      app/templates/author.hbs\n    \n  \n\n  1\n2\n3\n\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n\u003cdiv\u003e{{body}}\u003c/div\u003e\n{{view \"author\"}}\n\n\n\nOutput:\n\n  1\n2\n3\n4\n5\n\n  \u003cdiv\u003e\n  \u003ch1\u003eWhy You Should Use Ember.js\u003c/h1\u003e\n  \u003cdiv\u003eBecause it's awesome!\u003c/div\u003e\n  Written by Yehuda Katz\n\u003c/div\u003e\n\n\n\nWhen using {{partial \"author\"}}:\n\n\nNo instance of author view will be created\nThe given template will be rendered\n\n\nWhen using {{view \"author\"}}:\n\n\nAn instance of author view will be created\nIt will be rendered here, using the template associated with that view (the default template being \"author\")\n\n\nFor more information, see Inserting Views in Templates.\nThe {{render}} Helper\n{{render}} takes two parameters:\n\n\nThe first parameter describes the context to be setup\nThe optional second parameter is a model, which will be passed to the controller if provided\n\n\n{{render}} does several things:\n\n\nWhen no model is provided it gets the singleton instance of the corresponding controller\nWhen a model is provided it gets a unique instance of the corresponding controller\nRenders the named template using this controller\nSets the model of the corresponding controller\n\n\nModifying the post / author example slightly:\n\n  \n    \n      app/templates/author.hbs\n    \n  \n\n  1\n2\n\n  Written by {{firstName}} {{lastName}}.\nTotal Posts: {{postCount}}\n\n\n\n  \n    \n      app/templates/post.hbs\n    \n  \n\n  1\n2\n3\n\n  \u003ch1\u003e{{title}}\u003c/h1\u003e\n\u003cdiv\u003e{{body}}\u003c/div\u003e\n{{render \"author\" author}}\n\n\n\n  \n    \n      app/controllers/author.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.Controller.extend({\n  postCount: function() {\n    return this.get(\"model.posts.length\");\n  }.property(\"model.posts.[]\")\n})\n\n\n\nIn this example, render will:\n\n\nGet an instance of author view if that class exists, otherwise uses a default generated view\nUse the corresponding template (in this case the default of \"author\")\nGet (or generate) the singleton instance of AuthorController\nSet the AuthorController's model to the 2nd argument passed to render, here the author field on the post\nRender the template in place, with the context created in the previous steps.\n\n\n{{render}} does not require the presence of a matching route.\n\n{{render}} is similar to {{outlet}}. Both tell Ember.js to devote this portion of the page to something.\n\n{{outlet}}: The router determines the route and sets up the appropriate controllers/views/models.\n{{render}}: You specify (directly and indirectly) the appropriate controllers/views/models.\n\nNote: {{render}} cannot be called multiple times for the same route when not specifying a model.\nComparison TableGeneral\n\n  \n  \n    Helper\n    Template\n    Model\n    View\n    Controller\n  \n  \n  \n  \n    {{partial}}\n    Specified Template\n    Current Model\n    Current View\n    Current Controller\n  \n  \n    {{view}}\n    View's Template\n    Current Model\n    Specified View\n    Current Controller\n  \n  \n    {{render}}\n    View's Template\n    Specified Model\n    Specified View\n    Specified Controller\n  \n  \n\nSpecific\n\n  \n  \n    Helper\n    Template\n    Model\n    View\n    Controller\n  \n  \n  \n  \n    {{partial \"author\"}}\n    templates/author.hbs\n    models/post.js\n    views/post.js\n    controllers/post.js\n  \n  \n    {{view \"author\"}}\n    templates/author.hbs\n    models/post.js\n    views/author.js\n    controllers/post.js\n  \n  \n    {{render \"author\" author}}\n    templates/author.hbs\n    models/author.js\n    views/author.js\n    controllers/author.js\n  \n  \n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b691fc4bca513d0a74056434e4d51519","fields":[{"name":"title","value":"The Application Template","type":"string"},{"name":"url","value":"/templates/the-application-template/","type":"enum"},{"name":"body","value":"The application template is the default template that is rendered when\nyour application starts.\n\nYou should put your header, footer, and any other decorative content\nhere. Additionally, you should have at least one {{outlet}}:\na placeholder that the router will fill in with the appropriate template,\nbased on the current URL.\n\nHere's an example template:\n\n  \n    \n      app/templates/application.hbs\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  \u003cheader\u003e\n  \u003ch1\u003eIgor's Blog\u003c/h1\u003e\n\u003c/header\u003e\n\n\u003cdiv\u003e\n  {{outlet}}\n\u003c/div\u003e\n\n\u003cfooter\u003e\n  \u0026copy;2013 Igor's Publishing, Inc.\n\u003c/footer\u003e\n\n\n\nThe header and footer will always be displayed on screen, but the\ncontents of the \u003cdiv\u003e will change depending on if the user is\ncurrently at /posts or /posts/15, for example.\n\nFor more information about how outlets are filled in by the router, see\nRouting.\n\nEmber CLI will create application.hbs for you by default in app/templates/application.hbs.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4d51ca61c042a6e0f4dfd8e0cdb116ed","fields":[{"name":"title","value":"Writing Helpers","type":"string"},{"name":"url","value":"/templates/writing-helpers/","type":"enum"},{"name":"body","value":"Sometimes, you may use the same HTML in your application multiple times. In those cases, you can register a custom helper that can be invoked from any Handlebars template.\n\nFor example, imagine you are frequently wrapping certain values in a \u003cspan\u003e tag with a custom class. You can register a helper from your JavaScript like this:\n\n  \n    \n      app/helpers/highlight.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Handlebars.makeBoundHelper( function(value, options) {\n  var escaped = Ember.Handlebars.Utils.escapeExpression(value);\n  return new Ember.Handlebars.SafeString('\u003cspan class=\"highlight\"\u003e' + escaped + '\u003c/span\u003e');\n});\n\n\n\nIf you return HTML from a helper, and you don't want it to be escaped,\nmake sure to return a new SafeString. Make sure you first escape any\nuser data!\n\nAnywhere in your Handlebars templates, you can now invoke this helper:\n\n  1\n\n  {{highlight name}}\n\n\n\nand it will output the following:\n\n  1\n\n  \u003cspan class=\"highlight\"\u003ePeter\u003c/span\u003e\n\n\n\nIf the name property on the current context changes, Ember.js will\nautomatically execute the helper again and update the DOM with the new\nvalue.\nDependencies\nImagine you want to render the full name of a Person. In this\ncase, you will want to update the output if the person itself changes,\nor if the firstName or lastName properties change.\n\n  \n    \n      app/helpers/full-name.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Handlebars.makeBoundHelper( function(person) {\n  return person.get('firstName') + ' ' + person.get('lastName');\n}, 'firstName', 'lastName');\n\n\n\nYou would use the helper like this:\n\n  1\n\n  {{fullName person}}\n\n\n\nNow, whenever the context's person changes, or when any of the\ndependent keys change, the output will automatically update.\n\nBoth the path passed to the fullName helper and its dependent keys may\nbe full property paths (e.g. person.address.country).\nCustom View Helpers\nYou may also find yourself rendering your view classes in multiple\nplaces using the {{view}} helper. In this case, you can save yourself\nsome typing by registering a custom view helper.\n\nFor example, letâs say you have a view called Calendar.\nYou can register a helper like this:\n\n  1\n2\n3\n\n  import Calendar from 'my-app/views/calendar';\n\nEmber.Handlebars.makeBoundHelper('calendar', Calendar);\n\n\n\nUsing Calendar in a template then becomes as simple as:\n\n  1\n\n  {{calendar}}\n\n\n\nWhich is functionally equivalent to, and accepts all the same\narguments as:\n\n  1\n\n  {{view \"calendar\"}}\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6b92476d3f19a3ac5f6ea85e474595d8","fields":[{"name":"title","value":"Acceptance Tests","type":"string"},{"name":"url","value":"/testing/acceptance/","type":"enum"},{"name":"body","value":"Acceptance tests are generally used to test important workflows within your application. They emulate user interaction and confirm expected results.\nIntroduction\nember-cli comes with acceptance test support out of the box. For creating your\nfirst test, you just need to run ember generate acceptance-test \u003cname\u003e. In\nour case, ember generate acceptance-test user-can-login-via-form. ember-cli will\ncreate a new test file under tests/acceptance/.\n\nAfter a few imports, ember-cli adds two hooks to the module definition. In the \nbeforeEach, a new Ember application is created and put in testing mode. This way, \nthe readiness of the application is deferred until your tests are ready to run. \nThe helper also sets the router's location to 'none' so that the window's location \nwill not be modified. After each test run, the application is destroyed to assure your \ntests are run in isolation.\n\n  \n    \n      tests/acceptance/user-can-login-via-form-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  var application;\n\nmodule('Acceptance: UserCanLoginViaForm', {\n  beforeEach: function() {\n    application = startApp();\n  },\n\n  afterEach: function() {\n    Ember.run(application, 'destroy');\n  }\n});\n\n\n\nember-cli also generates a sample test. In this case, we visit \n'/user-can-login-via-form' and assert we got there without any problem.\n\n  \n    \n      tests/acceptance/user-can-login-via-form-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  test('visiting /user-can-login-via-form', function(assert) {\n  visit('/user-can-login-via-form');\n\n  andThen(function() {\n    assert.equal(currentPath(), 'user-can-login-via-form');\n  });\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"d111ada688dff43a36c7d27aea287dc5","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/testing/","type":"enum"},{"name":"body","value":"Testing is a core part of the Ember framework and its development cycle.\n\nLet's assume you are writing an Ember application which will serve as a blog. \nThis application would likely include models such as user and post. It would \nalso include interactions such as login and create post. Let's finally \nassume that you would like to have automated tests in place for your application. \n\nThere are two different classifications of tests that you will need: \nAcceptance and Unit.\nAcceptance Tests\nAcceptance tests are used to test user interaction and application flow. With \nthe example scenario above, some acceptance tests you might write are:\n\n\nA user is able to log in via the login form.\nA user is able to create a blog post.\nA visitor does not have access to the admin panel.\n\nUnit Tests\nUnit tests are used to test isolated chunks of functionality, or \"units\", without \nworrying about their dependencies. Some examples of unit tests for the scenario \nabove might be:\n\n\nA user has a role\nA user has a username\nA user has a fullname attribute which is the aggregate of its first and last \nnames with a space between\nA post has a title\nA post's title must be no longer than 50 characters\n\nTesting Frameworks\nQUnit is the default testing framework for this guide, but others are \nsupported through third-party addons.\nHow to Run Your Tests\nRun your tests with ember test on the command-line. You can re-run your tests on every file-change with ember test --server. For more details and options, see Ember CLI â Testing and ember help test.\nContributing\nThe Ember testing guide provides best practices and examples on how to test your\nEmber applications. If you find any errors or believe the documentation can be\nimproved, please feel free to contribute.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8339b4dfcf839b8409d37b5417877c11","fields":[{"name":"title","value":"Test Helpers","type":"string"},{"name":"url","value":"/testing/test-helpers/","type":"enum"},{"name":"body","value":"One of the major issues in testing web applications is that all code is\nevent-driven, therefore has the potential to be asynchronous (i.e. output can\nhappen out of sequence from input). This has the ramification that code can be\nexecuted in any order.\n\nAn example may help here: Let's say a user clicks two buttons, one after another\nand both load data from different servers. They take different times to respond.\n\nWhen writing your tests, you need to be keenly aware of the fact that you cannot\nbe sure that the response will return immediately after you make your requests,\ntherefore your assertion code (the \"tester\") needs to wait for the thing being\ntested (the \"testee\") to be in a synchronized state. In the example above, that\nwould be when both servers have responded and the test code can go about its\nbusiness checking the data (whether it is mock data, or real data).\n\nThis is why all Ember's test helpers are wrapped in code that ensures Ember is\nback in a synchronized state when it makes its assertions. It saves you from\nhaving to wrap everything in code that does that, and it makes it easier to read\nyour tests because there's less boilerplate in them.\n\nEmber includes several helpers to facilitate acceptance testing. There are two\ntypes of helpers: asynchronous and synchronous.\nAsynchronous Helpers\nAsynchronous helpers are \"aware\" of (and wait for) asynchronous behavior within\nyour application, making it much easier to write deterministic tests.\n\nAlso, these helpers register themselves in the order that you call them and will\nbe run in a chain; each one is only called after the previous one finishes. You can rest assured, therefore, that the order you call them in will also\nbe their execution order, and that the previous helper has finished before the\nnext one starts.\n\n\nclick(selector)\n\n\nClicks an element and triggers any actions triggered by the element's click\nevent and returns a promise that fulfills when all resulting async behavior\nis complete.\n\nfillIn(selector, text)\n\n\nFills in the selected input with the given text and returns a promise that\nfulfills when all resulting async behavior is complete.\n\nkeyEvent(selector, type, keyCode)\n\n\nSimulates a key event type, e.g. keypress, keydown, keyup with the\ndesired keyCode on element found by the selector.\n\ntriggerEvent(selector, type, options)\n\n\nTriggers the given event, e.g. blur, dblclick on the element identified\nby the provided selector.\n\nvisit(url)\n\n\nVisits the given route and returns a promise that fulfills when all resulting\nasync behavior is complete.\n\n\nSynchronous Helpers\nSynchronous helpers are performed immediately when triggered.\n\n\ncurrentPath()\n\n\nReturns the current path.\n\ncurrentRouteName()\n\n\nReturns the currently active route name.\n\ncurrentURL()\n\n\nReturns the current URL.\n\nfind(selector, context)\n\n\nFinds an element within the app's root element and within the context\n(optional). Scoping to the root element is especially useful to avoid\nconflicts with the test framework's reporter, and this is done by default\nif the context is not specified.\n\n\nWait Helpers\nThe andThen helper will wait for all preceding asynchronous helpers to\ncomplete prior to progressing forward. Let's take a look at the following\nexample.\n\n  \n    \n      tests/acceptance/new-post-appears-first-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  test('simple test', function(assert) {\n  assert.expect(1); // Ensure that we will perform one assertion\n\n  visit('/posts/new');\n  fillIn('input.title', 'My new post');\n  click('button.submit');\n\n  // Wait for asynchronous helpers above to complete\n  andThen(function() {\n    assert.equal(find('ul.posts li:first').text(), 'My new post');\n  });\n});\n\n\n\nFirst we tell QUnit that this test should have one assertion made by the end\nof the test by calling assert.expect with an argument of 1. We then visit the new\nposts URL \"/posts/new\", enter the text \"My new post\" into an input control\nwith the CSS class \"title\", and click on a button whose class is \"submit\".\n\nWe then make a call to the andThen helper which will wait for the preceding\nasynchronous test helpers to complete (specifically, andThen will only be\ncalled after the new posts URL was visited, the text filled in and the\nsubmit button was clicked, and the browser has returned from doing whatever\nthose actions required). Note andThen has a single argument of the function\nthat contains the code to execute after the other test helpers have finished.\n\nIn the andThen helper, we finally make our call to assert.equal which makes an\nassertion that the text found in the first li of the ul whose class is \"posts\"\nis equal to \"My new post\".\nCustom Test Helpers\nFor creating your own test helper, just run ember generate test-helper\n\u003chelper-name\u003e. Here is the result of running ember g test-helper\nshouldHaveElementWithCount:\n\n  \n    \n      tests/helpers/should-have-element-with-count.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Test.registerAsyncHelper(\n    'shouldHaveElementWithCount', function(app) {\n\n});\n\n\n\nEmber.Test.registerAsyncHelper and Ember.Test.registerHelper are used to\nregister test helpers that will be injected when startApp is\ncalled. The difference between Ember.Test.registerHelper and\nEmber.Test.registerAsyncHelper is that the latter will not run until any\nprevious async helper has completed and any subsequent async helper will wait\nfor it to finish before running.\n\nThe helper method will always be called with the current Application as the\nfirst parameter. Other parameters need to be provided when calling the helper. Helpers need to be registered prior to calling\nstartApp, but ember-cli will take care of it for you.\n\nHere is an example of a non-async helper:\n\n  \n    \n      tests/helpers/should-have-element-with-count.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Test.registerHelper(\n    'shouldHaveElementWithCount',\n    function(app, assert, selector, n, context) {\n\n    var el = findWithAssert(selector, context);\n    var count = el.length;\n    assert.equal(n, count, 'found ' + count + ' times');\n  }\n);\n\n// shouldHaveElementWithCount(assert, \"ul li\", 3);\n\n\n\nHere is an example of an async helper:\n\n  \n    \n      tests/helpers/dblclick.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default Ember.Test.registerAsyncHelper('dblclick',\n  function(app, assert, selector, context) {\n    var $el = findWithAssert(selector, context);\n    Ember.run(function() {\n      $el.dblclick();\n    });\n  }\n);\n\n// dblclick(\"#person-1\")\n\n\n\nAsync helpers also come in handy when you want to group interaction\ninto one helper. For example:\n\n  \n    \n      tests/helpers/add-contact.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  export default Ember.Test.registerAsyncHelper('addContact',\n  function(app, assert, name, context) {\n    fillIn('#name', name);\n    click('button.create');\n  }\n);\n\n// addContact(\"Bob\");\n// addContact(\"Dan\");\n\n\n\nFinally, don't forget to add your helpers in tests/.jshintrc and in\ntests/helpers/start-app.js. In tests/.jshintrc you need to add it in the\npredef section, otherwise you will get failing jshint tests:\n\n  \n    \n      tests/.jshintc\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  {\n  \"predef\": [\n    \"document\",\n    \"window\",\n    \"location\",\n    ...\n    \"shouldHaveElementWithCount\",\n    \"dblclick\",\n    \"addContact\"\n  ],\n  ...\n}\n\n\n\nIn tests/helpers/start-app.js you just need to import the helper file: it\nwill be registered then.\n\n  \n    \n      tests/helpers/start-app.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  import Ember from 'ember';\nimport Application from '../../app';\nimport Router from '../../router';\nimport config from '../../config/environment';\nimport shouldHaveElementWithCount from \"./should-have-element-with-count\";\nimport dblclick from \"./dblclick\";\nimport addContact from \"./add-contact\";\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"6a0e26dbd7878af23525081f7441c1b0","fields":[{"name":"title","value":"Testing Components","type":"string"},{"name":"url","value":"/testing/testing-components/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown\nin Unit Testing Basics because Ember.Component extends Ember.Object.\nSetup\nCreate the component to test using ember generate component pretty-color:\nThis Ember component:\n\n  \n    \n      app/components/pretty-color.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  import layout from '../templates/components/pretty-color';\n\nexport default Ember.Component.extend({\n  layout: layout,\n  classNames: ['pretty-color'],\n  attributeBindings: ['style'],\n  style: function() {\n    return 'color: ' + this.get('name') + ';';\n  }.property('name')\n});\n\n\n\n... with its accompanying Handlebars template:\n\n  \n    \n      app/templates/components/pretty-color.hbs\n    \n  \n\n  1\n\n  Pretty Color: {{name}}\n\n\n\n... can be unit tested using the moduleForComponent helper.\nThis helper will find the component by name (pretty-color) and its template (if\navailable).\n\n  \n    \n      tests/unit/components/pretty-color-test.js\n    \n  \n\n  1\n2\n3\n4\n\n  moduleForComponent('pretty-color', {\n  // specify the other units that are required for this test\n  // needs: ['component:foo', 'helper:bar']\n});\n\n\n\nNow each test following the moduleForComponent call has a subject() function,\nwhich aliases the create method on the component factory.\n\nWe can test to make sure that changing the component's color property updates\nthe rendered HTML:\n\n  \n    \n      tests/unit/components/pretty-color-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n  test('changing colors', function(assert) {\n\n  // this.subject() is available because we used moduleForComponent\n  var component = this.subject();\n\n  // we wrap this with Ember.run because it is an async function\n  Ember.run(function() {\n    component.set('name','red');\n  });\n\n  // first call to $() renders the component.\n  assert.equal(this.$().attr('style'), 'color: red;');\n\n  // another async function, so we need to wrap it with Ember.run\n  Ember.run(function() {\n    component.set('name', 'green');\n  });\n\n  assert.equal(this.$().attr('style'), 'color: green;');\n});\n\n\n\nWe might also test this component to ensure the template is being\nrendered properly.\n\n  \n    \n      tests/unit/components/pretty-color-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  test('template is rendered with the color name', function(assert) {\n\n  // this.subject() is available because we used moduleForComponent\n  var component = this.subject();\n\n  // first call to $() renders the component.\n  assert.equal($.trim(this.$().text()), 'Pretty Color:');\n\n  // we wrap this with Ember.run because it is an async function\n  Ember.run(function() {\n    component.set('name', 'green');\n  });\n\n  assert.equal($.trim(this.$().text()), 'Pretty Color: green');\n});\n\n\nInteracting with Components in the DOM\nEmber Components are a great way to create powerful, interactive, self-contained\ncustom HTML elements. Because of this, it is important to test the\ncomponent's methods and the user's interaction with the component.\n\nLet's create a very simple component that simply sets its own\ntitle when clicked. Run ember generate component my-foo and open the\ncomponent file:\n\n  \n    \n      app/components/my-foo.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  import layout from '../templates/components/my-foo';\n\nexport default Ember.Component.extend({\n  layout: layout,\n  title:'Hello World',\n\n  actions: {\n    updateTitle: function() {\n      this.set('title', 'Hello Ember World');\n    }\n  }\n});\n\n\n\nWhose template is:\n\n  \n    \n      app/templates/components/my-foo.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  \u003ch2\u003e{{title}}\u003c/h2\u003e\n\u003cbutton {{action \"updateTitle\"}}\u003e\n    Update Title\n\u003c/button\u003e\n\n\n\nWe would use jQuery triggers to interact with the rendered component\nand test its behavior:\n\n  \n    \n      tests/unit/components/my-foo-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  moduleForComponent('my-foo', 'MyFooComponent');\n\ntest('clicking link updates the title', function(assert) {\n  var component = this.subject();\n\n  // assert default state\n  assert.equal(this.$().find('h2').text(), 'Hello World');\n\n  // perform click action\n  this.$().find('button').click();\n\n  assert.equal(this.$().find('h2').text(), 'Hello Ember World');\n});\n\n\nsendAction validation in components\nComponents often utilize sendAction, which is a way to interact with the Ember\napplication. Here's a simple component that sends the action internalAction\nwhen a button is clicked:\n\n  \n    \n      app/components/my-other-foo.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import layout from '../templates/components/my-other-foo';\n\nexport default Ember.Component.extend({\n  layout: layout,\n\n  actions: {\n    doSomething: function() {\n      this.sendAction('internalAction');\n    }\n  }\n});\n\n\n\nThe button can be found in the template:\n\n  \n    \n      app/templates/components/my-other-foo.hbs\n    \n  \n\n  1\n2\n3\n\n  \u003cbutton {{action \"doSomething\"}}\u003e\n    Do Something\n\u003c/button\u003e\n\n\n\nIn our test, we will create a test double (dummy object) that receives\nthe action being sent by the component.\n\n  \n    \n      tests/unit/components/my-other-foo.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n  test('trigger external action when button is clicked', function(assert) {\n  assert.expect(1);\n\n  // component instance\n  var component = this.subject();\n\n  // render it\n  this.$();\n\n  var targetObject = {\n    externalAction: function() {\n      // we have the assertion here which will be\n      // called when the action is triggered\n      assert.ok(true, 'external Action was called!');\n    }\n  };\n\n  // setup a fake external action to be called when\n  // button is clicked\n  component.set('internalAction', 'externalAction');\n\n  // set the targetObject to our dummy object (this\n  // is where sendAction will send its action to)\n  component.set('targetObject', targetObject);\n\n  // click the button\n  this.$().find('button').click();\n});\n\n\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b52674636f495b78ec905a98c63e1233","fields":[{"name":"title","value":"Testing Controllers","type":"string"},{"name":"url","value":"/testing/testing-controllers/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown\nin Unit Testing Basics because Ember.Controller extends Ember.Object.\n\nUnit testing controllers is very simple using the unit test helper which is part\nof the ember-qunit framework.\nTesting Controller Actions\nHere we have a controller PostsController with some computed properties and an\naction setProps.\n\n  \n    \n      app/controllers/posts.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n  export default Ember.Controller.extend({\n\n  propA: 'You need to write tests',\n  propB: 'And write one for me too',\n\n  setPropB: function(str) {\n    this.set('propB', str);\n  },\n\n  actions: {\n    setProps: function(str) {\n      this.set('propA', 'Testing is cool');\n      this.setPropB(str);\n    }\n  }\n});\n\n\n\nsetProps sets a property on the controller and also calls a method. In our \ngenerated test, ember-cli already uses the moduleFor helper to setup a test \ncontainer:\n\n  \n    \n      tests/unit/controllers/posts-test.js\n    \n  \n\n  1\n2\n3\n4\n\n  moduleFor('controller:posts', {\n  // Specify the other units that are required for this test.\n  // needs: ['controller:foo']\n});\n\n\n\nNext we use this.subject() to get an instance of the PostsController and\nwrite a test to check the action. this.subject() is a helper method from the\nember-qunit library that returns a singleton instance of the module set up\nusing moduleFor.\n\n  \n    \n      tests/unit/controllers/posts-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  test('calling the action setProps updates props A and B', function(assert) {\n  assert.expect(4);\n\n  // get the controller instance\n  var ctrl = this.subject();\n\n  // check the properties before the action is triggered\n  assert.equal(ctrl.get('propA'), 'You need to write tests');\n  assert.equal(ctrl.get('propB'), 'And write one for me too');\n\n  // trigger the action on the controller by using the `send` method,\n  // passing in any params that our action may be expecting\n  ctrl.send('setProps', 'Testing Rocks!');\n\n  // finally we assert that our values have been updated\n  // by triggering our action.\n  assert.equal(ctrl.get('propA'), 'Testing is cool');\n  assert.equal(ctrl.get('propB'), 'Testing Rocks!');\n});\n\n\nTesting Controller Needs\nSometimes controllers have dependencies on other controllers. This is\naccomplished by using needs. For example, here are two simple controllers. The\nPostController is a dependency of the CommentsController:\n\n  \n    \n      app/controllers/post.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Controller.extend({\n  title: Ember.computed.alias('model.title')\n});\n\n\n\n  \n    \n      app/controllers/comments.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.Controller.extend({\n  needs: 'post',\n  title: Ember.computed.alias('controllers.post.title'),\n});\n\n\n\nThis time when we setup our moduleFor we need to pass an options object as\nour third argument that has the controller's needs.\n\n  \n    \n      tests/unit/controllers/comments-test.js\n    \n  \n\n  1\n2\n3\n\n  moduleFor('controller:comments', 'Comments Controller', {\n  needs: ['controller:post']\n});\n\n\n\nNow let's write a test that sets a property on our post model in the\nPostController that would be available on the CommentsController.\n\n  \n    \n      tests/unit/controllers/comments-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n  test('modify the post', function(assert) {\n  assert.expect(2);\n\n  // grab an instance of `CommentsController` and `PostController`\n  var ctrl = this.subject();\n  var postCtrl = ctrl.get('controllers.post');\n\n  // wrap the test in the run loop because we are dealing with async functions\n  Ember.run(function() {\n\n    // set a generic model on the post controller\n    postCtrl.set('model', Ember.Object.create({ title: 'foo' }));\n\n    // check the values before we modify the post\n    assert.equal(ctrl.get('title'), 'foo');\n\n    // modify the title of the post\n    postCtrl.get('model').set('title', 'bar');\n\n    // assert that the controllers title has changed\n    assert.equal(ctrl.get('title'), 'bar');\n  });\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9e4b1c3650cd96bd8485e0b98d722871","fields":[{"name":"title","value":"Testing Models","type":"string"},{"name":"url","value":"/testing/testing-models/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown \nin Unit Testing Basics because DS.Model extends Ember.Object.\n\nEmber Data Models can be tested using the moduleForModel helper.\n\nLet's assume we have a Player model that has level and levelName \nattributes. We want to call levelUp() to increment the level and assign a \nnew levelName when the player reaches level 5.\n\n  \n    \n      app/models/player.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default DS.Model.extend({\n  level:     DS.attr('number', { defaultValue: 0 }),\n  levelName: DS.attr('string', { defaultValue: 'Noob' }),\n\n  levelUp: function() {\n    var newLevel = this.incrementProperty('level');\n    if (newLevel === 5) {\n      this.set('levelName', 'Professional');\n    }\n  }\n});\n\n\n\nNow let's create a test which will call levelUp on the player when they are\nlevel 4 to assert that the levelName changes. We will use moduleForModel:\n\n  \n    \n      tests/unit/models/player-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n  moduleForModel('player');\n\ntest('levelUp', function(assert) {\n  // this.subject aliases the createRecord method on the model\n  var player = this.subject({ level: 4 });\n\n  // wrap asynchronous call in run loop\n  Ember.run(function() {\n    player.levelUp();\n  });\n\n  assert.equal(player.get('level'), 5);\n  assert.equal(player.get('levelName'), 'Professional');\n});\n\n\nTesting Relationships\nFor relationships you probably only want to test that the relationship\ndeclarations are setup properly.\n\nAssume that a User can own a Profile.\n\n  \n    \n      app/models/profile.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n\n});\n\n\n\n  \n    \n      app/models/user.js\n    \n  \n\n  1\n2\n3\n\n  export default DS.Model.extend({\n  profile: DS.belongsTo('profile')\n});\n\n\n\nThen you could test that the relationship is wired up correctly\nwith this test.\n\n  \n    \n      tests/unit/models/user-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  moduleForModel('user', {\n  // Specify the other units that are required for this test.\n  needs: ['model:profile']\n});\n\ntest('profile relationship', function(assert) {\n  var User = this.store().modelFor('user');\n  var relationship = Ember.get(User, 'relationshipsByName').get('profile');\n\n  assert.equal(relationship.key, 'profile');\n  assert.equal(relationship.kind, 'belongsTo');\n});\n\n\n\nEmber Data contains extensive tests around the functionality of\nrelationships, so you probably don't need to duplicate those tests.  You could\nlook at the Ember Data tests for examples of deeper relationship testing if you\nfeel the need to do it.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"50d7d9948190dd788cabc6f1e832ec60","fields":[{"name":"title","value":"Testing Routes","type":"string"},{"name":"url","value":"/testing/testing-routes/","type":"enum"},{"name":"body","value":"Unit testing methods and computed properties follows previous patterns shown \nin Unit Testing Basics because Ember.Route extends Ember.Object.\n\nTesting routes can be done both via acceptance or unit tests. Acceptance tests \nwill likely provide better coverage for routes because routes are typically used \nto perform transitions and load data, both of which are tested more easily in \nfull context rather than isolation.\n\nThat being said, sometimes it is important to unit test your routes. For example, \nlet's say we'd like to have an alert that can be triggered from anywhere within \nour application. The alert function displayAlert should be put into the \nApplicationRoute because all actions and events bubble up to it from \nsub-routes, controllers and views.\n\n  \n    \n      app/routes/application.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Route.extend({\n  actions: {\n    displayAlert: function(text) {\n      this._displayAlert(text);\n    }\n  },\n\n  _displayAlert: function(text) {\n    alert(text);\n  }\n});\n\n\n\nThis is made possible by using moduleFor.\n\nIn this route we've separated our concerns:\nThe action displayAlert contains the code that is called when the action is \nreceived, and the private function _displayAlert performs the work. While not \nnecessarily obvious here because of the small size of the functions, separating \ncode into smaller chunks (or \"concerns\"), allows it to be more readily isolated \nfor testing, which in turn allows you to catch bugs more easily.\n\nHere is an example of how to unit test this route:\n\n  \n    \n      tests/unit/routes/application-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n  let originalAlert;\n\nmoduleFor('route:application', {\n  beforeEach: function() {\n    originalAlert = window.alert; // store a reference to window.alert\n  },\n\n  afterEach: function() {\n    window.alert = originalAlert; // restore window.alert\n  }\n});\n\ntest('Alert is called on displayAlert', function(assert) {\n  assert.expect(1);\n\n  // with moduleFor, the subject returns an instance of the route\n  var route = this.subject();\n  var expectedText = 'foo';\n\n  // stub window.alert to perform a qunit test\n  window.alert = function(text) {\n    assert.equal(text, expectedText, 'expected ' + text + ' to be ' + expectedText);\n  };\n\n  // call the _displayAlert function which triggers the qunit test above\n  route._displayAlert(expectedText);\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8cbbc37817038e7af55d7494378a4c9f","fields":[{"name":"title","value":"Testing User Interaction","type":"string"},{"name":"url","value":"/testing/testing-user-interaction/","type":"enum"},{"name":"body","value":"Almost every test has a pattern of visiting a route, interacting with the page\n(using the helpers), and checking for expected changes in the DOM.\n\nExample:\n\n  \n    \n      tests/acceptance/root-lists-first-page-of-posts-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  test('root lists first page of posts', function(assert){\n  visit('/posts');\n  andThen(function() {\n    assert.equal(find('ul.posts li').length, 3, 'The first page should have 3 posts');\n  });\n});\n\n\n\nThe helpers that perform actions use a global promise object and automatically\nchain onto that promise object if it exists. This allows you to write your tests\nwithout worrying about async behaviour your helper might trigger.\n\n  \n    \n      tests/acceptance/new-post-appears-first-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n  var application;\nmodule('Acceptance: New Post Appears First', {\n  beforeEach: function() {\n    application = startApp();\n  },\n  afterEach: function() {\n    Ember.run(application, 'destroy');\n  }\n});\n\ntest('add new post', function(assert) {\n  visit('/posts/new');\n  fillIn('input.title', 'My new post');\n  click('button.submit');\n\n  andThen(function() {\n    assert.equal(find('ul.posts li:first').text(), 'My new post');\n  });\n});\n\n\nTesting Transitions\nSuppose we have an application which requires authentication. When a visitor\nvisits a certain URL as an unauthenticated user, we expect them to be transitioned\nto a login page.\n\n  \n    \n      app/routes/profile.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  beforeModel: function() {\n    var user = this.modelFor('application');\n    if (Ember.isEmpty(user)) {\n      this.transitionTo('login');\n    }\n  }\n});\n\n\n\nWe could use the route helpers to ensure that the user would be redirected to the login page\nwhen the restricted URL is visited.\n\n  \n    \n      tests/acceptance/transitions-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n  var application;\n\nmodule('Acceptance: Transitions', {\n  beforeEach: function() {\n    application = startApp();\n  },\n\n  afterEach: function() {\n    Ember.run(application, 'destroy');\n  }\n});\n\ntest('visiting /profile', function(assert) {\n  visit('/profile');\n\n  andThen(function() {\n    assert.equal(currentRouteName(), 'login');\n    assert.equal(currentPath(), 'login');\n    assert.equal(currentURL(), '/login');\n  });\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"1ce450bb46bb44d1336b990817414fae","fields":[{"name":"title","value":"Unit Test Helpers","type":"string"},{"name":"url","value":"/testing/unit-test-helpers/","type":"enum"},{"name":"body","value":"Globals vs Modules\nIn the past, it has been difficult to test portions of your Ember application\nwithout loading the entire app as a global. By having your application written\nusing modules (CommonJS, AMD, etc), you are able to require just code that\nis to be tested without having to pluck the pieces out of your global\napplication.\nUnit Testing Helpers\nEmber-QUnit is the default unit testing helper suite for Ember. It can and\nshould be used as a template for other test framework helpers. It uses your\napplication's resolver to find and automatically create test subjects for you\nusing the moduleFor and test helpers.\n\nA test subject is simply an instance of the object that a particular test is\nmaking assertions about. Usually test subjects are manually created by the\nwriter of the test.\n\n\n\nThe unit testing section of this guide will use the Ember-QUnit library, but\nthe concepts and examples should translate easily to other frameworks.\nAvailable Helpers\nBy including Ember-QUnit, you will have access to a number of test helpers.\n\n\nmoduleFor(fullName [, description [, callbacks]])\n\n\nfullName: The full name of the unit, (ie. controller:application,\nroute:index, etc.)\ndescription: the description of the module\ncallbacks: normal QUnit callbacks (setup and teardown), with addition to\nneeds, which allows you specify the other units the tests will need.\n\nmoduleForComponent(name [, description [, callbacks]])\n\n\nname: the short name of the component that you'd use in a template, (ie.\nx-foo, ic-tabs, etc.)\ndescription: the description of the module\ncallbacks: normal QUnit callbacks (setup and teardown), with addition to\nneeds, which allows you specify the other units the tests will need.\n\nmoduleForModel(name [, description [, callbacks]])\n\n\nname: the short name of the model you'd use in store\noperations (ie. user, assignmentGroup, etc.)\ndescription: the description of the module\ncallbacks: normal QUnit callbacks (setup and teardown), with addition to\nneeds, which allows you specify the other units the tests will need.\n\ntest\n\n\nSame as QUnit test except it includes the subject function which is used\nto create the test subject.\n\nsetResolver\n\n\nSets the resolver which will be used to lookup objects from the application\ncontainer.\n\n\nUnit Testing Setup\nIn order to unit test your Ember application, you need to let Ember know it is in\ntest mode. To do so, you must call Ember.setupForTesting().\n\n  1\n\n  Ember.setupForTesting();\n\n\n\nThe setupForTesting() function call makes ember turn off its automatic run\nloop execution. This gives us an ability to control the flow of the run loop\nourselves, to a degree. Its default behaviour of resolving all promises and\ncompleting all async behaviour are suspended to give you a chance to set up\nstate and make assertions in a known state. In other words, you know that if you\nrun \"visit\" to get to a particular URL, you can be sure the URL has been visited\nand that's the only behaviour that has transpired. If we didn't use this mode,\nour assertions would most likely be executed before the async behaviour had taken place, so our assertion results would be unpredictable.\nThe Resolver\nThe Ember resolver plays a huge role when unit testing your application. It\nprovides the lookup functionality based on name, such as route:index or\nmodel:post.\n\nIf you do not have a custom resolver or are testing a global Ember application,\nthe resolver should be set like this:\n\nMake sure to replace \"App\" with your application's namespace in the following line\n\n  1\n\n  setResolver(Ember.DefaultResolver.create({ namespace: App }))\n\n\n\nOtherwise, you would require the custom resolver and pass it to setResolver\nlike this (ES6 example):\n\n  1\n2\n3\n\n  import Resolver from './path/to/resolver';\nimport { setResolver } from 'ember-qunit';\nsetResolver(Resolver.create());\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"8da16330e9a3a38299664dcc2f2233af","fields":[{"name":"title","value":"Unit Testing Basics","type":"string"},{"name":"url","value":"/testing/unit-testing-basics/","type":"enum"},{"name":"body","value":"Unit tests are generally used to test a small piece of code and ensure that it\nis doing what was intended. Unlike acceptance tests, they are narrow in scope\nand do not require the Ember application to be running.\n\nAs it is the basic object type in Ember, being able to test a simple\nEmber.Object sets the foundation for testing more specific parts of your\nEmber application such as controllers, components, etc. Testing an Ember.Object\nis as simple as creating an instance of the object, setting its state, and\nrunning assertions against the object. By way of example lets look at a few\ncommon cases.\nTesting Computed Properties\nLet's start by looking at an object that has a computedFoo computed property\nbased on a foo property.\n\n  \n    \n      app/models/some-thing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Object.extend({\n  foo: 'bar',\n\n  computedFoo: function() {\n    return 'computed ' + this.get('foo');\n  }.property('foo')\n});\n\n\n\nWithin the test we'll create an instance, update the foo property (which\nshould trigger the computed property), and assert that the logic in our\ncomputed property is working correctly.\n\n  \n    \n      tests/unit/models/some-thing-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import SomeThing from '\u003cyour-app-name\u003e/models/some-thing';\n\nmoduleFor('model:some-thing', 'Unit: some-thing');\n\ntest('computedFoo correctly concats foo', function(assert) {\n  var someThing = SomeThing.create({});\n\n  someThing.set('foo', 'baz');\n\n  assert.equal(someThing.get('computedFoo'), 'computed baz');\n});\n\n\n\nSee that we have used moduleFor one of the several unit-test helpers provided\nby Ember-Qunit.\nTesting Object Methods\nNext let's look at testing logic found within an object's method. In this case\nthe testMethod method alters some internal state of the object (by updating\nthe foo property).\n\n  \n    \n      app/models/some-thing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Object.extend({\n  foo: 'bar',\n  testMethod: function() {\n    this.set('foo', 'baz');\n  }\n});\n\n\n\nTo test it, we create an instance of our class SomeThing as defined above, \ncall the testMethod method and assert that the internal state is correct as a \nresult of the method call.\n\n  \n    \n      tests/unit/models/some-thing-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  import SomeThing from '\u003cyour-app-name\u003e/models/some-thing';\n\nmoduleFor('model:some-thing', 'Unit: some-thing');\n\ntest('calling testMethod updated foo', function(assert) {\n  var someThing = SomeThing.create({});\n\n  someThing.testMethod();\n\n  assert.equal(someThing.get('foo'), 'baz');\n});\n\n\n\nIn the event the object's method returns a value you can simply assert that the\nreturn value is calculated correctly. Suppose our object has a calc method\nthat returns a value based on some internal state.\n\n  \n    \n      app/models/some-thing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Object.extend({\n  count: 0,\n  calc: function() {\n    this.incrementProperty('count');\n    return 'count: ' + this.get('count');\n  }\n});\n\n\n\nThe test would call the calc method and assert it gets back the correct value.\n\n  \n    \n      tests/unit/models/some-thing-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  import SomeThing from '\u003cyour-app-name\u003e/models/some-thing';\n\nmoduleFor('model:some-thing', 'Unit: some-thing');\n\ntest('calc returns incremented count', function(assert) {\n  var someThing = SomeThing.create({});\n  assert.equal(someThing.calc(), 'count: 1');\n  assert.equal(someThing.calc(), 'count: 2');\n});\n\n\nTesting Observers\nSuppose we have an object that has a property and a method observing that property.\n\n  \n    \n      app/models/some-thing.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Object.extend({\n  foo: 'bar',\n  other: 'no',\n  doSomething: function(){\n    this.set('other', 'yes');\n  }.observes('foo')\n});\n\n\n\nIn order to test the doSomething method we create an instance of SomeThing,\nupdate the observed property (foo), and assert that the expected effects are present.\n\n  \n    \n      tests/unit/models/some-thing-test.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  import SomeThing from '\u003cyour-app-name\u003e/models/some-thing';\n\nmoduleFor('model:some-thing', 'Unit: some-thing');\n\ntest('doSomething observer sets other prop', function() {\n  var someThing = App.SomeThing.create();\n  someThing.set('foo', 'baz');\n  equal(someThing.get('other'), 'yes');\n});\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ee5ea607aecd946ab8c953297847e0b8","fields":[{"name":"title","value":"Debugging","type":"string"},{"name":"url","value":"/understanding-ember/debugging/","type":"enum"},{"name":"body","value":"Debugging Ember\nAll Ember developers should install the\nEmber Inspector\nwhich provides debugging and development tools for the browser.\n\nYou should also become comfortable with the browser debugging\ntooling for Chrome, Firefox, Safari, and Internet Explorer.\nRoutingLog router transitions\n  \n    \n      app/app.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  export default Ember.Application.extend({\n  // Basic logging, e.g. \"Transitioned into 'post'\"\n  LOG_TRANSITIONS: true,\n\n  // Extremely detailed logging, highlighting every internal\n  // step made while transitioning into a route, including\n  // `beforeModel`, `model`, and `afterModel` hooks, and\n  // information about redirects and aborted transitions\n  LOG_TRANSITIONS_INTERNAL: true\n});\n\n\nViews / TemplatesLog view lookups\n  \n    \n      config/environment.js\n    \n  \n\n  1\n\n  ENV.APP.LOG_VIEW_LOOKUPS = true;\n\n\n\n  1\n\n  Ember.keys(Ember.TEMPLATES)\n\n\nHandlebars Debugging Helpers\n  1\n2\n\n  {{debugger}}\n{{log model}}\n\n\nControllersLog generated controller\n  \n    \n      config/environment.js\n    \n  \n\n  1\n\n  ENV.APP.LOG_ACTIVE_GENERATION = true;\n\n\nObservers / BindingSee all observers for a object, key\n  1\n\n  Ember.observersFor(comments, keyName);\n\n\nLog object bindings\n  \n    \n      config/environments.js\n    \n  \n\n  1\n\n  ENV.APP.LOG_BINDINGS = true\n\n\nMiscellaneousTurn on resolver resolution logging\nThis option logs all the lookups that are done to the console. Custom objects\nyou've created yourself have a tick, and Ember generated ones don't.\n\nIt's useful for understanding which objects Ember is finding when it does a lookup\nand which it is generating automatically for you.\n\n  \n    \n      app/app.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Application.extend({\n  LOG_RESOLVER: true\n});\n\n\nDealing with deprecations\n  1\n2\n\n  Ember.ENV.RAISE_ON_DEPRECATION = true\nEmber.ENV.LOG_STACKTRACE_ON_DEPRECATION = true\n\n\nImplement an Ember.onerror hook to log all errors in production\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  Ember.onerror = function(error) {\n  Ember.$.ajax('/error-notification', {\n    type: 'POST',\n    data: {\n      stack: error.stack,\n      otherInformation: 'exception message'\n    }\n  });\n}\n\n\nImport the console\nIf you are using imports with Ember, be sure to import the console:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  Ember = {\n  imports: {\n    Handlebars: Handlebars,\n    jQuery: $,\n    console: window.console\n  }\n};\n\n\nErrors within an RSVP.Promise\nThere are times when dealing with promises that it seems like any errors\nare being 'swallowed', and not properly raised. This makes it extremely\ndifficult to track down where a given issue is coming from. Thankfully,\nRSVP has a solution for this problem built in.\n\nYou can provide an onerror function that will be called with the error\ndetails if any errors occur within your promise. This function can be anything\nbut a common practice is to call console.assert to dump the error to the\nconsole.\n\n  \n    \n      app/app.js\n    \n  \n\n  1\n2\n3\n\n  Ember.RSVP.on('error', function(error) {\n  Ember.Logger.assert(false, error);\n});\n\n\nErrors within Ember.run.later (Backburner.js)\nBackburner has support for stitching the stacktraces together so that you can\ntrack down where an erroring Ember.run.later is being initiated from. Unfortunately,\nthis is quite slow and is not appropriate for production or even normal development.\n\nTo enable this mode you can set:\n\n  1\n\n  Ember.run.backburner.DEBUG = true;\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ba55166358a3df3672dfc989bc7eee52","fields":[{"name":"title","value":"Dependency Injection \u0026 Service Lookup","type":"string"},{"name":"url","value":"/understanding-ember/dependency-injection-and-service-lookup/","type":"enum"},{"name":"body","value":"Dependency injection and service lookup are two important framework concepts. The first, dependency injection, refers to a dependent object being injected onto another object during instantiation. For example, all route objects have the property router set on them during instantiation. We say that the dependency of the router has been injected onto the route object.\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Route.extend({\n  actions: {\n    showPath: function(){\n      // Dependency injection provides the router object to the route instance.\n      alert(this.router.get('currentPath'));\n    }\n  }\n});\n\n\n\nSometimes an Ember.js library will use dependency injection to expose its API to developers. An example of this is Ember-Data, which injects its store into all routes and controllers.\n\n  \n    \n      app/controllers/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Controller.extend({\n  actions: {\n    findItems: function(){\n      var controller = this;\n      // Dependency injection provides the store object to the controller instance.\n      this.store.find('item').then(function(items){\n        controller.set('items', items);\n      });\n    }\n  }\n});\n\n\n\nThese are just two examples of how dependency injection, or DI, is used in Ember applications.\n\nThe second tool, service lookup, describes when a dependency is created or fetched on demand. Service lookup is the simpler pattern, and will be discussed first. Fundamentally, these two patterns share the same goals:\n\n\nIsolate responsibilities in an application\nAvoid the use of global variables and instances (important for testing)\nAllow a single object instance to represent state, but share that state with other objects.\n\nLightweight Services with needs\nA common use-case for service lookup is that of a singleton service. Often, these services will live near application state, and thus Ember provides an API that makes controller services easy to write.\n\nFor example, a session service can easily be made available to this index controller:\n\n  \n    \n      app/controllers/session.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Controller.extend({\n  isAuthenticated: false\n});\n\n\n\n  \n    \n      app/controllers/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Controller.extend({\n  needs: ['session'],\n  // The index controller may need access to that state:\n  // Using needs, the controller instance will be available on `controllers`\n  isLoggedIn: Ember.computed.alias('controllers.session.isAuthenticated')\n});\n\n\n\nThe controllers computed property returns a hash of the controllers listed in needs. Controllers in Ember.js are singletons, meaning the same instance is always returned when they are requested.\n\nA second controller can take advantage of this singleton nature to access the same session object:\n\n  \n    \n      app/controllers/sign-in.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Controller.extend({\n  needs: ['session'],\n  isLoggedIn: Ember.computed.alias('controllers.session.isAuthenticated'),\n  actions: {\n    signIn: function(){\n      // There is an alias to the session property, so this change propagates\n      // to the session object then the IndexController.\n      this.set('isLoggedIn', true);\n    }\n  }\n});\n\n\n\nThe session object returned in both classes is the same. needs provides us an easy way to share state across controllers.\nServices with DOM via needs\nThe needs array can fetch any singleton controller in an Ember application. This can be combined with the render helper to create services that also have access to the DOM.\n\nLet's build a controller that manages audio playback and makes it available to other controllers.\n\nFirst, we create controller:audio and attach it to the DOM by using the render helper. This helper renders a template, and backs that template with a controller of the same name.\n\n  1\n2\n3\n\n  {{! application.hbs }}\n{{render \"audio\"}}\n{{outlet}}\n\n\n\nAnd we must create an app/templates/audio.hbs template to render:\n\n  \n    \n      app/templates/audio.hbs\n    \n  \n\n  1\n2\n3\n4\n\n  \u003caudio id=\"audio\" controls loop\u003e\n  \u003csource src={{currentSrc}} type=\"audio/mpeg\"\u003e\u003c/source\u003e\n\u003c/audio\u003e\n\u003cdiv\u003e{{currentSrc}}\u003c/div\u003e\n\n\n\nThe render helper will back this template with a controller of the same name. We create that controller, and have it maintain the currentSrc property:\n\n  \n    \n      app/controllers/audio.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Controller.extend({\n  currentSrc: null,\n  play: function(src){\n    this.set('currentSrc', src);\n  }\n});\n\n\n\nTo allow other controllers to play audio, we use the needs array to look up our new service:\n\n  \n    \n      app/controllers/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  export default Ember.Controller.extend({\n  needs: ['audio'],\n  actions: {\n    selectSrc: function(src){\n      this.get('controllers.audio').play(src);\n    }\n  }\n});\n\n\n\nWhen the index controller calls this.get('controllers.audio'), the audio service is returned. Other controllers can also use needs to access the audio service.\n\n\n\nServices are a simple way to share behavior between controllers and isolate responsibilities in an application. needs is an easy and quick way to create services and share them between an application's controllers.\n\nFor a more powerful way to connect Ember.js components, let's look at dependency injection.\nDependency Management in Ember.js\nWhen an Ember application starts running, it will create and use a single instance of the\nEmber.Container object. This container object is responsible for managing factories and the dependencies between them. At the level of the container, a factory can be any framework component. The index template is a factory with the name template:index, and the application route is a factory with the name route:application. The container understands how to use these factories (are they singleton? Should they be instantiated?) and manages their dependencies.\n\nFactory names have two parts segmented by a :. The first segment is the framework component type, and the second is the name of the component requested. Hence, an application view would be named view:application.\n\nIf the container does not already have a requested factory, it uses a resolver to discover that factory. The resolver is responsible for mapping the factory name of view:application to the global variable of App.ApplicationView. Tools like ember-cli may use alternative rules for resolving factories. After optionally adding dependencies to the requested factory, that factory is cached and returned.\n\nEmber's container should be viewed as an implementation detail, and is not part of the supported public API.\nDependency Injection with register/inject\nInstead of accessing the container directly, Ember provides an API for registering factories and managing injections on the application instance with an initializer\n\n  \n    \n      app/initializers/logger.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n  export function initialize(container, application) {\n  var logger = {\n    log: function(message) {\n      console.log(message);\n    }\n  };\n\n  application.register('logger:main', logger, { instantiate: false });\n  application.inject('route', 'logger', 'logger:main');\n}\n\nexport default {\n  name: 'logger',\n  initialize: initialize\n};\n\n\n\nInitializers can be declared at any time before an application is instantiated, making them easier to declare than directly registering factories on the application.\n\nAny dependency injection is comprised of two parts. The first is the factory registration:\n\n  \n    \n      app/initializers/logger.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  var logger = {\n  log: function(m) {\n    console.log(m);\n  }\n};\n\napplication.register('logger:main', logger, { instantiate: false });\n\n\n\nThe register function adds the factory (logger) into the container. It adds it with the full name of logger:main, and with the option not to instantiate. When the factory is injected onto another object, it will be injected \"as-is\".\n\nOften, it is preferable to register a factory that can be instantiated:\n\n  \n    \n      app/initializers/logger.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  var Logger = Ember.Object.extend({\n  log: function(m) {\n    console.log(m);\n  }\n});\n\napplication.register('logger:main', Logger);\n\n\n\nThis class will be instantiated before it is used by the container. This gives it the important benefit of being able to accept injections of its own.\n\nThe second part of dependency injection is, you guessed it, the dependency injection:\n\n  \n    \n      app/initializers/logger.js\n    \n  \n\n  1\n\n  application.inject('route', 'logger', 'logger:main');\n\n\n\nThis is an example of a type injection. Onto all factories of the type route the property, logger will be injected with the factory named logger:main. Routes in this example application can now access the logger:\n\n  \n    \n      app/routes/index.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  App.IndexRoute = Ember.Route.extend({\n  activate: function(){\n    // The logger property is injected into all routes\n    this.logger.log('Entered the index route!');\n  }\n});\n\n\n\nInjections can also be made on a specific factory by using its full name:\n\n  1\n\n  application.inject('route:index', 'logger', 'logger:main');\n\n\n\nInjections can be made onto all of Ember's major framework classes including components, controllers, routes, and the router.\n\n\n\nDependency injection and service lookup are two powerful tools in your Ember.js toolset, and every mature Ember application will require their use.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"3c7603802d3fb0216ad6bea9eb81df5b","fields":[{"name":"title","value":"Managing Asynchrony","type":"string"},{"name":"url","value":"/understanding-ember/managing-asynchrony/","type":"enum"},{"name":"body","value":"Many Ember concepts, like bindings and computed properties, are designed\nto help manage asynchronous behavior.\nWithout Ember\nWe'll start by taking a look at ways to manage asynchronous behavior\nusing jQuery or event-based MVC frameworks.\n\nLet's use the most common asynchronous behavior in a web application,\nmaking an Ajax request, as an example. The browser APIs for making Ajax\nrequests provide an asynchronous API. jQuery's wrapper does as well:\n\n  1\n2\n3\n4\n\n  jQuery.getJSON('/posts/1', function(post) {\n  $(\"#post\").html(\"\u003ch1\u003e\" + post.title + \"\u003c/h1\u003e\" +\n    \"\u003cdiv\u003e\" + post.body + \"\u003c/div\u003e\");\n});\n\n\n\nIn a selector-based jQuery application, you would use this callback to make\nwhatever changes you needed to make to the DOM.\n\nWhen using an event-based MVC framework, you move the logic out of the\ncallback and into model and view objects. This improves things, but\ndoesn't get rid of the need to explicitly deal with asynchronous\ncallbacks:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n  Post = Model.extend({\n  author: function() {\n    return [this.salutation, this.name].join(' ')\n  },\n\n  toJSON: function() {\n    var json = Model.prototype.toJSON.call(this);\n    json.author = this.author();\n    return json;\n  }\n});\n\nPostView = View.extend({\n  init: function(model) {\n    model.bind('change', this.render, this);\n  },\n\n  template: _.template(\"\u003ch1\u003e\u003c%= title %\u003e\u003c/h1\u003e\u003ch2\u003e\u003c%= author %\u003e\u003c/h2\u003e\u003cdiv\u003e\u003c%= body %\u003e\u003c/div\u003e\"),\n\n  render: function() {\n    jQuery(this.element).html(this.template(this.model.toJSON());\n    return this;\n  }\n});\n\nvar post = Post.create();\nvar postView = PostView.create({ model: post });\njQuery('#posts').append(postView.render().el);\n\njQuery.getJSON('/posts/1', function(json) {\n  // set all of the JSON properties on the model\n  post.set(json);\n});\n\n\n\nThis example doesn't use any particular JavaScript library beyond\njQuery, but its approach is typical of event-driven MVC frameworks. It\nhelps organize the asynchronous events, but asynchronous behavior is\nstill the core programming model.\nEmber's Approach\nIn general, Ember's goal is to eliminate explicit forms of asynchronous\nbehavior. As we'll see later, this gives Ember the ability to coalesce\nmultiple events that have the same result.\n\nIt also provides a higher level of abstraction, eliminating the need to\nmanually register and unregister event listeners to perform most common\ntasks.\n\nYou would normally use ember-data for this example, but let's see how\nyou would model the above example using jQuery for Ajax in Ember.\n\n  \n    \n      app/models/post.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.Object.extend({\n\n});\n\n\n\n  \n    \n      app/controllers/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  export default Ember.Controller.extend({\n\n  salutation: Ember.computed.alias('model.salutation'),\n  name: Ember.computed.alias('model.name'),\n  title: Ember.computed.alias('model.title'),\n  body: Ember.computed.alias('model.body'),\n\n  author: function() {\n    return [this.get('salutation'), this.get('name')].join(' ');\n  }.property('salutation', 'name')\n});\n\n\n\n  \n    \n      app/views/post.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.View.extend({\n  // the controller is the initial context for the template\n  controller: null\n});\n\n\n\n  \n    \n      app/templates/post.hbs\n    \n  \n\n  1\n2\n3\n\n  \u003ch1\u003e  {{title}}  \u003c/h1\u003e\n\u003ch2\u003e  {{author}} \u003c/h2\u003e\n\u003cdiv\u003e {{body}}   \u003c/div\u003e\n\n\n\n  \n    \n      app/routes/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n\n  import Post from \"app/models/post\";\n\nexport default Ember.Route.extend({\n  model: function(){\n    return Ember.$.getJSON('/posts/1', function(data) {\n      return Post.create(data);\n    });\n  }\n});\n\n\n\nIn contrast to the above examples, the Ember approach eliminates the\nneed to explicitly register an observer when the post's properties\nchange.\n\nThe {{title}}, {{author}} and {{body}} template elements are bound\nto those properties on the post controller. When the post controller's\nmodel changes, it automatically propagates those changes to the DOM.\n\nUsing a computed property for author eliminated the need to explicitly\ninvoke the computation in a callback when the underlying property\nchanged.\n\nInstead, Ember's binding system automatically follows the trail from the\nsalutation and name set in the getJSON callback to the computed\nproperty in the PostController and all the way into the DOM.\nBenefits\nBecause Ember is usually responsible for propagating changes, it can\nguarantee that a single change is only propagated one time in response\nto each user event.\n\nLet's take another look at the author computed property.\n\n  \n    \n      app/controllers/post.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.Controller.extend({\n  // ...\n  author: function() {\n    return [this.get('salutation'), this.get('name')].join(' ');\n  }.property('salutation', 'name')\n});\n\n\n\nBecause we have specified that it depends on both salutation and\nname, changes to either of those two dependencies will invalidate the\nproperty, which will trigger an update to the {{author}} property in\nthe DOM.\n\nImagine that in response to a user event, I do something like this:\n\n  1\n2\n\n  post.set('salutation', \"Mrs.\");\npost.set('name', \"Katz\");\n\n\n\nYou might imagine that these changes will cause the computed property to\nbe invalidated twice, causing two updates to the DOM. And in fact, that\nis exactly what would happen when using an event-driven framework.\n\nIn Ember, the computed property will only recompute once, and the DOM\nwill only update once.\n\nHow?\n\nWhen you make a change to a property in Ember, it does not immediately\npropagate that change. Instead, it invalidates any dependent properties\nimmediately, but queues the actual change to happen later.\n\nChanging both the salutation and name properties invalidates the\nauthor property twice, but the queue is smart enough to coalesce those\nchanges.\n\nOnce all of the event handlers for the current user event have finished,\nEmber flushes the queue, propagating the changes downward. In this case,\nthat means that the invalidated author property will invalidate the\n{{author}} in the DOM, which will make a single request to recompute\nthe information and update itself once.\n\nThis mechanism is fundamental to Ember. In Ember, you should always\nassume that the side-effects of a change you make will happen later. By\nmaking that assumption, you allow Ember to coalesce repetitions of the\nsame side-effect into a single call.\n\nIn general, the goal of evented systems is to decouple the data\nmanipulation from the side effects produced by listeners, so you\nshouldn't assume synchronous side effects even in a more event-focused\nsystem. The fact that side effects don't propagate immediately in Ember\neliminates the temptation to cheat and accidentally couple code together\nthat should be separate.\nSide-Effect Callbacks\nSince you can't rely on synchronous side-effects, you may be wondering\nhow to make sure that certain actions happen at the right time.\n\nFor example, imagine that you have a view that contains a button, and\nyou want to use jQuery UI to style the button. Since a view's append\nmethod, like everything else in Ember, defers its side-effects, how can\nyou execute the jQuery UI code at the right time?\n\nThe answer is lifecycle callbacks.\n\n  \n    \n      app/components/my-button.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Component.extend({\n  tagName: 'button',\n\n  didInsertElement: function() {\n    this.$().button();\n  }\n});\n\n\n\n  \n    \n      app/templates/example-usage.hbs\n    \n  \n\n  1\n\n  {{my-button}}\n\n\n\nIn this case, as soon as the button actually appears in the DOM, Ember\nwill trigger the didInsertElement callback, and you can do whatever\nwork you want.\n\nThe lifecycle callbacks approach has several benefits, even if we didn't\nhave to worry about deferred insertion.\n\nFirst, relying on synchronous insertion means leaving it up to the\ncaller of appendTo to trigger any behavior that needs to run\nimmediately after appending. As your application grows, you may find\nthat you create the same view in many places, and now need to worry\nabout that concern everywhere.\n\nThe lifecycle callback eliminates the coupling between the code that\ninstantiates the view and its post-append behavior. In general, we find\nthat making it impossible to rely on synchronous side-effects leads to\nbetter design in general.\n\nSecond, because everything about the lifecycle of a view is inside the\nview itself, it is very easy for Ember to re-render parts of the DOM\non-demand.\n\nFor example, if this button was inside of an {{#if}} block, and Ember\nneeded to switch from the main branch to the else section, Ember can\neasily instantiate the view and call the lifecycle callbacks.\n\nBecause Ember forces you to define a fully-defined view, it can take\ncontrol of creating and inserting views in appropriate situations.\n\nThis also means that all of the code for working with the DOM is in a\nfew sanctioned parts of your application, so Ember has more freedom in\nthe parts of the render process outside of these callbacks.\nRouting\nThere's an entire page dedicated to managing async within the Ember\nRouter: Asynchronous Routing\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"ead09a4fdf3e0a0ce7e4f5b67db647d7","fields":[{"name":"title","value":"The Run Loop","type":"string"},{"name":"url","value":"/understanding-ember/run-loop/","type":"enum"},{"name":"body","value":"Ember's internals and most of the code you will write in your applications takes place in a run loop. The run loop is used to\nbatch, and order (or reorder) work in a way that is most effective and efficient.\n\nIt does so by scheduling work on specific queues. These queues have a priority,\nand are processed to completion in priority order.\nWhy is this useful?\nVery often, batching similar work has benefits. Web browsers do something quite similar\nby batching changes to the DOM.\n\nConsider the following HTML snippet:\n\n  1\n2\n3\n\n  \u003cdiv id=\"foo\"\u003e\u003c/div\u003e\n\u003cdiv id=\"bar\"\u003e\u003c/div\u003e\n\u003cdiv id=\"baz\"\u003e\u003c/div\u003e\n\n\n\nand executing the following code:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  foo.style.height = \"500px\" // write\nfoo.offsetHeight // read (recalculate style, layout, expensive!)\n\nbar.style.height = \"400px\" // write\nbar.offsetHeight // read (recalculate style, layout, expensive!)\n\nbaz.style.height = \"200px\" // write\nbaz.offsetHeight // read (recalculate style, layout, expensive!)\n\n\n\nIn this example, the sequence of code forced the browser to recalculate style,\nand relayout after each step. However, if we were able to batch similar jobs together,\nthe browser would have only needed to recalculate the style and layout once.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  foo.style.height = \"500px\" // write\nbar.style.height = \"400px\" // write\nbaz.style.height = \"200px\" // write\n\nfoo.offsetHeight // read (recalculate style, layout, expensive!)\nbar.offsetHeight // read (fast since style and layout is already known)\nbaz.offsetHeight // read (fast since style and layout is already known)\n\n\n\nInterestingly, this pattern holds true for many other types of work. Essentially,\nbatching similar work allows for better pipelining, and further optimization.\n\nLet's look at a similar example that is optimized in Ember, starting with a User object:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  var User = Ember.Object.extend({\n  firstName: null,\n  lastName: null,\n  fullName: function() {\n    return this.get('firstName') + ' ' + this.get('lastName');\n  }.property('firstName', 'lastName')\n});\n\n\n\nand a template to display its attributes:\n\n  1\n2\n\n  {{firstName}}\n{{fullName}}\n\n\n\nIf we execute the following code without the run loop:\n\n  1\n2\n3\n4\n5\n6\n\n  var user = User.create({ firstName: 'Tom', lastName: 'Huda' });\nuser.set('firstName', 'Yehuda');\n// {{firstName}} and {{fullName}} are updated\n\nuser.set('lastName', 'Katz');\n// {{lastName}} and {{fullName}} are updated\n\n\n\nWe see that the browser will rerender the template twice.\n\n  1\n2\n3\n4\n5\n\n  var user = User.create({firstName:'Tom', lastName:'Huda'});\nuser.set('firstName', 'Yehuda');\nuser.set('lastName', 'Katz');\n\n// {{firstName}}  {{lastName}} and {{fullName}} are updated\n\n\n\nHowever, if we have the run loop in the above code, the browser will only rerender the template once the attributes have all been set.\n\n  1\n2\n3\n4\n5\n\n  var user = User.create({ firstName: 'Tom', lastName: 'Huda' });\nuser.set('firstName', 'Yehuda');\nuser.set('lastName', 'Katz');\nuser.set('firstName', 'Tom');\nuser.set('lastName', 'Huda');\n\n\n\nIn the above example with the run loop, since the user's attributes end up at the same values as before execution, the template will not even rerender!\n\nIt is of course possible to optimize these scenarios on a case-by-case basis,\nbut getting them for free is much nicer. Using the run loop, we can apply these\nclasses of optimizations not only for each scenario, but holistically app-wide.\nHow does the Run Loop work in Ember?\nAs mentioned earlier, we schedule work (in the form of function invocations) on\nqueues, and these queues are processed to completion in priority order.\n\nWhat are the queues, and what is their priority order?\n\n  1\n2\n\n  Ember.run.queues\n// =\u003e [\"sync\", \"actions\", \"routerTransitions\", \"render\", \"afterRender\", \"destroy\"]\n\n\n\nBecause the priority is first to last, the \"sync\" queue has higher priority than the \"render\" or \"destroy\" queue.\nWhat happens in these queues?\n\nThe sync queue contains binding synchronization jobs\nThe actions queue is the general work queue and will typically contain scheduled tasks e.g. promises\nThe routerTransitions queue contains transition jobs in the router\nThe render queue contains jobs meant for rendering, these will typically update the DOM\nThe afterRender contains jobs meant to be run after all previously scheduled render tasks are complete. This is often good for 3rd-party DOM manipulation libraries, that should only be run after an entire tree of DOM has been updated\nThe destroy queue contains jobs to finish the teardown of objects other jobs have scheduled to destroy\n\nIn what order are jobs executed on the queues?\nThe algorithm works this way:\n\n\nLet the highest priority queue with pending jobs be: CURRENT_QUEUE, if there are no queues with pending jobs the run loop is complete\nLet a new temporary queue be defined as WORK_QUEUE\nMove jobs from CURRENT_QUEUE into WORK_QUEUE\nProcess all the jobs sequentially in WORK_QUEUE\nReturn to Step 1\n\nAn example of the internals\nRather than writing the higher level app code that internally invokes the various\nrun loop scheduling functions, we have stripped away the covers, and shown the raw run-loop interactions.\n\nWorking with this API directly is not common in most Ember apps, but understanding this example will\nhelp you to understand the run-loops algorithm, which will make you a better Ember developer.\n\n\nFAQsWhat do I need to know to get started with Ember?\nFor basic Ember app development scenarios, nothing. All common paths are paved nicely\nfor you and don't require working with the run loop directly.\nWhat do I need to know to actually build an app?\nIt is possible to build good apps without working with the run loop directly, so if\nyou don't feel the need to do so, don't.\nWhat scenarios will require me to understand the run loop?\nThe most common case you will run into is integrating with a non-Ember API\nthat includes some sort of asynchronous callback. For example:\n\n\nAJAX callbacks\nDOM update and event callbacks\nWebsocket callbacks\nsetTimeout and setInterval callbacks\npostMessage and messageChannel event handlers\n\n\nYou should begin a run loop when the callback fires.\nHow do I tell Ember to start a run loop?\n  1\n2\n3\n4\n5\n\n  $('a').click(function(){\n  Ember.run(function(){  // begin loop\n    // Code that results in jobs being scheduled goes here\n  }); // end loop, jobs are flushed and executed\n});\n\n\nWhat happens if I forget to start a run loop in an async handler?\nAs mentioned above, you should wrap any non-Ember async callbacks in\nEmber.run. If you don't, Ember will try to approximate a beginning and end for you.\nConsider the following callback:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  $('a').click(function(){\n  console.log('Doing things...');\n\n  Ember.run.schedule('actions', this, function() {\n    // Do more things\n  });\n  Ember.run.scheduleOnce('afterRender', this, function() {\n    // Yet more things\n  });\n});\n\n\n\nThe runloop API calls that schedule work i.e. run.schedule,\nrun.scheduleOnce, run.once have the property that they will approximate a\nrunloop for you if one does not already exist. These automatically created\nrunloops we call autoruns.\n\nHere is some pseudocode to describe what happens using the example above:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n  $('a').click(function(){\n  // 1. autoruns do not change the execution of arbitrary code in a callback.\n  //    This code is still run when this callback is executed and will not be\n  //    scheduled on an autorun.\n  console.log('Doing things...');\n\n  Ember.run.schedule('actions', this, function() {\n    // 2. schedule notices that there is no currently available runloop so it\n    //    creates one. It schedules it to close and flush queues on the next\n    //    turn of the JS event loop.\n    if (! Ember.run.hasOpenRunloop()) {\n      Ember.run.start();\n      nextTick(function() {\n          Ember.run.end()\n      }, 0);\n    }\n\n    // 3. There is now a runloop available so schedule adds its item to the\n    //    given queue\n    Ember.run.schedule('actions', this, function() {\n      // Do more things\n    });\n\n  });\n\n  // 4. scheduleOnce sees the autorun created by schedule above as an available\n  //    runloop and adds its item to the given queue.\n  Ember.run.scheduleOnce('afterRender', this, function() {\n    // Yet more things\n  });\n\n});\n\n\n\nAlthough autoruns are convenient, they are suboptimal. The current JS frame is\nallowed to end before the run loop is flushed, which sometimes means the browser\nwill take the opportunity to do other things, like garbage collection. GC\nrunning in between data changing and DOM rerendering can cause visual lag and\nshould be minimized.\n\nRelying on autoruns is not a rigorous or efficient way to use the runloop.\nWrapping event handlers manually is preferred.\nHow is runloop behaviour different when testing?\nWhen your application is in testing mode then\nEmber will throw an error if you try to schedule work without an available\nrunloop.\n\nAutoruns are disabled in testing for several reasons:\n\n\nAutoruns are Embers way of not punishing you in production if you forget to\nopen a runloop before you schedule callbacks on it. While this is useful in\nproduction, these are still situations that should be revealed in testing to\nhelp you find and fix them.\nSome of Ember's test helpers are promises that wait for the run loop to empty\nbefore resolving. If your application has code that runs outside a runloop,\nthese will resolve too early and give erroneous test failures which are\ndifficult to find. Disabling autoruns help you identify these scenarios and\nhelps both your testing and your application!\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"4a4f3da3e525930a038b9a17e34a8945","fields":[{"name":"title","value":"The View Layer","type":"string"},{"name":"url","value":"/understanding-ember/the-view-layer/","type":"enum"},{"name":"body","value":"This guide goes into extreme detail about the Ember.js view layer. It is\nintended for an experienced Ember developer, and includes details that\nare unnecessary for getting started with Ember.\n\nEmber.js has a sophisticated system for creating, managing and rendering a hierarchy of views that connect to the browser's DOM. Views are responsible for responding to user events, like clicks, drags, and scrolls, as well as updating the contents of the DOM when the data underlying the view changes.\n\nView hierarchies are usually created by evaluating a Handlebars template. As the template is evaluated, child views are added. As the templates for those child views are evaluated, they may have child views added, and so on, until an entire hierarchy is created.\n\nEven if you do not explicitly create child views from your Handlebars templates, Ember.js internally uses the view system to update bound values. For example, every Handlebars expression {{value}} creates a view behind-the-scenes that knows how to update the bound value if it changes.\n\nYou can also dynamically make changes to the view hierarchy at application runtime using the Ember.ContainerView class. Rather than being template-driven, a container view exposes an array of child view instances that can be manually managed.\n\nViews and templates work in tandem to provide a robust system for creating whatever user interface you dream up. End users should be isolated from the complexities of things like timing issues while rendering and event propagation. Application developers should be able to describe their UI once, as a string of Handlebars markup, and then carry on with their application without having to worry about making sure that it remains up-to-date.\nWhat problems does it solve?Child Views\nIn a typical client-side application, views may represent elements nested inside of each other in the DOM. In the naÃ¯ve solution to this problem, separate view objects represent each DOM element, and ad-hoc references help the various view objects keep track of the views conceptually nested inside of them.\n\nHere is a simple example, representing one main app view, a collection nested inside of it, and individual items nested inside of the collection.\n\n\n  \n\n\nThis system works well at first glance, but imagine that we want to open Joe's Lamprey Shack at 8am instead of 9am. In this situation, we will want to re-render the App View. Because the developer needed to build up the references to the children on an ad-hoc basis, this re-rendering process has several problems.\n\nIn order to re-render the App View, the App View must also manually re-render the child views and re-insert them into App View's element. If implemented perfectly, this process works well, but it relies upon a perfect, ad hoc implementation of a view hierarchy. If any single view fails to implement this precisely, the entire re-render will fail.\n\nIn order to avoid these problems, Ember's view hierarchy has the concept of child views baked in.\n\n\n  \n\n\nWhen the App View re-renders, Ember is responsible for re-rendering and inserting the child views, not application code. This also means that Ember can perform any memory management for you, such as cleaning up observers and bindings.\n\nNot only does this eliminate quite a bit of boilerplate code, but it eliminates the possibility that an imperfectly implemented view hierarchy will cause unexpected failures.\nEvent Delegation\nIn the past, web developers have added event listeners to individual elements in order to know when the user interacts with them. For example, you might have a \u003cdiv\u003e element on which you register a function that gets called when the user clicks it.\n\nHowever, this approach often does not scale when dealing with large numbers of interactive elements. For example, imagine a \u003cul\u003e with 100 \u003cli\u003es in it, with a delete button next to each item. Since the behavior is the same for all of these items, it would be inefficient to create 100 event listeners, one for each delete button.\n\n\n  \n\n\nTo solve this problem, developers discovered a technique called \"event delegation\". Instead of registering a listener on each element in question, you can register a single listener for the containing element and use event.target to identify which element the user clicked on.\n\n\n  \n\n\nImplementing this is a bit tricky, because some events (like focus, blur and change) don't bubble. Fortunately, jQuery has solved this problem thoroughly; using jQuery's on method reliably works for all native browser events.\n\nOther JavaScript frameworks tackle this problem in one of two ways. In the first approach, they ask you to implement the naÃ¯ve solution yourself, creating a separate view for each element. When you create the view, it sets up an event listener on the view's element. If you had a list of 500 items, you would create 500 views and each would set up a listener on its own element.\n\nIn the second approach, the framework builds in event delegation at the view level. When creating a view, you can supply a list of events to delegate and a method to call when the event occurs. This leaves identifying the context of the click (for example, which item in the list) to the method receiving the event.\n\nYou are now faced with an uncomfortable choice: create a new view for each item and lose the benefits of event delegation, or create a single view for all of the items and have to store information about the underlying JavaScript object in the DOM.\n\nIn order to solve this problem, Ember delegates all events to the application's root element (usually the document body) using jQuery. When an event occurs, Ember identifies the nearest view that handles the event and invokes its event handler. This means that you can create views to hold a JavaScript context, but still get the benefit of event delegation.\n\nFurther, because Ember registers only one event for the entire Ember application, creating new views never requires setting up event listeners, making re-renders efficient and less error-prone. When a view has child views, this also means that there is no need to manually undelegate views that the re-render process replaces.\nThe Rendering Pipeline\nMost web applications specify their user interface using the markup of a particular templating language. For Ember.js, we've done the work to make templates written using the Handlebars templating language automatically update when the values used inside of them are changed.\n\nWhile the process of displaying a template is automatic for developers, under the hood there are a series of steps that must be taken to go from the original template to the final, live DOM representation that the user sees.\n\nThis is the approximate lifecycle of an Ember view:\n\n\n  \n\n1. Template Compilation\nThe application's templates are loaded over the network or as part of the application payload in string form. When the application loads, it sends the template string to Handlebars to be compiled into a function. Once compiled, the template function is saved, and can be used by multiple views repeatedly, each time they need to re-render.\n\nThis step may be omitted in applications where the templates are pre-compiled on the server. In those cases, the template is transferred not as the original, human-readable template string but as the compiled code.\n\nBecause Ember is responsible for template compilation, you don't have to do any additional work to ensure that compiled templates are reused.\n2. String Concatenation\nA view's rendering process is kickstarted when the application calls append or appendTo on the view. Calling append or appendTo schedules the view to be rendered and inserted later. This allows any deferred logic in your application (such as binding synchronization) to happen before rendering the element.\n\nTo begin the rendering process, Ember creates a RenderBuffer and gives it to the view to append its contents to. During this process, a view can create and render child views. When it does so, the parent view creates and assigns a RenderBuffer for the child, and links it to the parent's RenderBuffer.\n\nEmber flushes the binding synchronization queue before rendering each view. By syncing bindings before rendering each view, Ember guarantees that it will not render stale data it needs to replace right away.\n\nOnce the main view has finished rendering, the render process has created a tree of views (the \"view hierarchy\"), linked to a tree of buffers. By walking down the tree of buffers and converting them into Strings, we have a String that we can insert into the DOM.\n\nHere is a simple example:\n\n\n  \n\n\nIn addition to children (Strings and other RenderBuffers), a RenderBuffer also encapsulates the element's tag name, id, classes, style, and other attributes. This makes it possible for the render process to modify one of these properties (style, for example), even after its child Strings have rendered. Because many of these properties are controlled via bindings this makes the process robust and transparent.\n3. Element Creation and Insertion\nAt the end of the rendering process, the root view asks the RenderBuffer for its element. The RenderBuffer takes its completed string and uses jQuery to convert it into an element. The view assigns that element to its element property and places it into the correct place in the DOM (the location specified in appendTo or the application's root element if the application used append).\n\nWhile the parent view assigns its element directly, each child view looks up its element lazily. It does this by looking for an element whose id matches its elementId property. Unless explicitly provided, the rendering process generates an elementId property and assigns its value to the view's RenderBuffer, which allows the view to find its element as needed.\n4. Re-Rendering\nAfter the view inserts itself into the DOM, either Ember or the application may want to re-render the view. They can trigger a re-render by calling the rerender method on a view.\n\nRerendering will repeat steps 2 and 3 above, with two exceptions:\n\n\nInstead of inserting the element into an explicitly specified location, rerender replaces the existing element with the new element.\nIn addition to rendering a new element, it also removes the old element and destroys its children. This allows Ember to automatically handle unregistering appropriate bindings and observers when re-rendering a view. This makes observers on a path more viable, because the process of registering and unregistering all of the nested observers is automatic.\n\n\nThe most common cause of a view re-render is when the value bound to a Handlebars expression ({{foo}}) changes. Internally, Ember creates a simple view for each expression, and registers an observer on the path. When the path changes, Ember updates the area of the DOM with the new value.\n\nAnother common case is an {{#if}} or {{#with}} block. When rendering a template, Ember creates a virtual view for these block helpers. These virtual views do not appear in the publicly available view hierarchy (when getting parentView and childViews from a view), but they exist to enable consistent re-rendering.\n\nWhen the path passed to an {{#if}} or {{#with}} changes, Ember automatically re-renders the virtual view, which will replace its contents, and importantly, destroy all child views to free up their memory.\n\nIn addition to these cases, the application may sometimes want to explicitly re-render a view (usually a ContainerView, see below). In this case, the application can call rerender directly, and Ember will queue up a re-rendering job, with the same semantics.\n\nThe process looks something like:\n\n\n  \n\nThe View HierarchyParent and Child Views\nAs Ember renders a templated view, it will generate a view hierarchy. Let's assume we have a template form.\n\n  1\n2\n\n  {{view \"search\" placeholder=\"Search\"}}\n{{#view view.buttonView}}Go!{{/view}}\n\n\n\nAnd we insert it into the DOM like this:\n\n  1\n2\n3\n4\n\n  var view = Ember.View.create({\n  templateName: 'form',\n  buttonView: Ember.Button\n}).append();\n\n\n\nThis will create a small view hierarchy that looks like this:\n\n\n  \n\n\nYou can move around in the view hierarchy using the parentView and childViews properties.\n\n  1\n2\n\n  var children = view.get('childViews') // [ \u003cApp.Search\u003e, \u003cEmber.Button\u003e ]\nchildren.objectAt(0).get('parentView') // view\n\n\n\nOne common use of the parentView method is inside of an instance of a child view.\n\n  1\n2\n3\n4\n5\n\n  App.Search = Ember.View.extend({\n  didInsertElement: function() {\n    // this.get('parentView') in here references `view`\n  }\n})\n\n\nLifecycle Hooks\nIn order to make it easy to take action at different points during your view's lifecycle, there are several hooks you can implement.\n\n\nwillInsertElement: This hook is called after the view has been rendered, but before it has been inserted into the DOM. It does not provide access to the view's element.\ndidInsertElement: This hook is called immediately after the view has been inserted into the DOM. It provides access to the view's element and is most useful for integration with an external library. Any explicit DOM setup code should be limited to this hook.\nwillDestroyElement: This hook is called immediately before the element is removed from the DOM. This is your opportunity to tear down any external state associated with the DOM node. Like didInsertElement, it is most useful for integration with external libraries.\nwillClearRender: This hook is called immediately before a view is re-rendered. This is useful if you want to perform some teardown immediately before a view is re-rendered.\nbecameVisible: This hook is called after a view's isVisible property, or one of its ancestor's isVisible property, changes to true and the associated element becomes visible. Note that this hook is only reliable if all visibility is routed through the isVisible property.\nbecameHidden: This hook is called after a view's isVisible property, or one of its ancestor's isVisible property, changes to false and the associated element becomes hidden. Note that this hook is only reliable if all visibility is routed through the isVisible property.\n\n\nApps can implement these hooks by defining a method by the hook's name on the view. Alternatively, it is possible to register a listener for the hook on a view:\n\n  1\n2\n3\n\n  view.on('willClearRender', function() {\n  // do something with view\n});\n\n\nVirtual Views\nAs described above, Handlebars creates views in the view hierarchy to\nrepresent bound values. Every time you use a Handlebars expression,\nwhether it's a simple value or a block helper like {{#with}} or\n{{#if}}, Handlebars creates a new view.\n\nBecause Ember uses these views for internal bookkeeping only,\nthey are hidden from the view's public parentView and childViews\nAPI. The public view hierarchy reflects only views created using the\n{{view}} helper or through ContainerView (see below).\n\nFor example, consider the following Handlebars template:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n  \u003ch1\u003eJoe's Lamprey Shack\u003c/h1\u003e\n{{restaurantHours}}\n\n{{#view \"fdaContactForm\"}}\n  If you are experiencing discomfort from eating at Joe's Lamprey Shack,\nplease use the form below to submit a complaint to the FDA.\n\n  {{#if allowComplaints}}\n    {{input value=\"complaint\"}}\n    \u003cbutton {{action \"submitComplaint\"}}\u003eSubmit\u003c/button\u003e\n  {{/if}}\n{{/view}}\n\n\n\nRendering this template would create a hierarchy like this:\n\n\n  \n\n\nBehind the scenes, Ember tracks additional virtual views for the\nHandlebars expressions:\n\n\n  \n\n\nFrom inside of the TextArea, the parentView would point to the\nFdaContactForm and the FdaContactForm's childViews would be an\narray of the single TextArea view.\n\nYou can see the internal view hierarchy by asking for the _parentView\nor _childViews, which will include virtual views:\n\n  1\n2\n3\n\n  var _childViews = view.get('_childViews');\nconsole.log(_childViews.objectAt(0).toString());\n//\u003e \u003cEmber._HandlebarsBoundView:ember1234\u003e\n\n\n\nWarning! You may not rely on these internal APIs in application code.\nThey may change at any time and have no public contract. The return\nvalue may not be observable or bindable. It may not be an Ember object.\nIf you feel the need to use them, please contact us so we can expose a better\npublic API for your use-case.\n\nBottom line: This API is like XML. If you think you have a use for it,\nyou may not yet understand the problem enough. Reconsider!\nEvent Bubbling\nOne responsibility of views is to respond to primitive user events\nand translate them into events that have semantic meaning for your\napplication.\n\nFor example, a delete button translates the primitive click event into\nthe application-specific \"remove this item from an array.\"\n\nIn order to respond to user events, create a new view subclass that\nimplements that event as a method:\n\n  1\n2\n3\n4\n5\n6\n\n  App.DeleteButton = Ember.View.create({\n  click: function(event) {\n    var item = this.get('model');\n    this.get('controller').send('deleteItem', item);\n  }\n});\n\n\n\nWhen you create a new Ember.Application instance, it registers an event\nhandler for each native browser event using jQuery's event delegation\nAPI. When the user triggers an event, the application's event dispatcher\nwill find the view nearest to the event target that implements the\nevent.\n\nA view implements an event by defining a method corresponding to the\nevent name. When the event name is made up of multiple words (like\nmouseup) the method name should be the camelized form of the event\nname (mouseUp).\n\nEvents will bubble up the view hierarchy until the event reaches the\nroot view. An event handler can stop propagation using the same\ntechniques as normal jQuery event handlers:\n\n\nreturn false from the method\nevent.stopPropagation\n\n\nFor example, imagine you defined the following view classes:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  App.GrandparentView = Ember.View.extend({\n  click: function() {\n    console.log('Grandparent!');\n  }\n});\n\nApp.ParentView = Ember.View.extend({\n  click: function() {\n    console.log('Parent!');\n    return false;\n  }\n});\n\nApp.ChildView = Ember.View.extend({\n  click: function() {\n    console.log('Child!');\n  }\n});\n\n\n\nAnd here's the Handlebars template that uses them:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  {{#view \"grandparent\"}}\n  {{#view \"parent\"}}\n    {{#view \"child\"}}\n      \u003ch1\u003eClick me!\u003c/h1\u003e\n    {{/view}}\n  {{/view}}\n{{/view}}\n\n\n\nIf you clicked on the \u003ch1\u003e, you'd see the following output in your\nbrowser's console:\n\n  1\n2\n\n  Child!\nParent!\n\n\n\nYou can see that Ember invokes the handler on the child-most view that\nreceived the event. The event continues to bubble to the ParentView,\nbut does not reach the GrandparentView because ParentView returns\nfalse from its event handler.\n\nYou can use normal event bubbling techniques to implement familiar\npatterns. For example, you could implement a FormView that defines a\nsubmit method. Because the browser triggers the submit event when\nthe user hits enter in a text field, defining a submit method on the\nform view will \"just work\".\n\n  1\n2\n3\n4\n5\n6\n7\n8\n\n  App.FormView = Ember.View.extend({\n  tagName: \"form\",\n\n  submit: function(event) {\n    // will be invoked whenever the user triggers\n    // the browser's `submit` method\n  }\n});\n\n\n\n  1\n2\n3\n4\n5\n\n  {{#view \"form\"}}\n  {{input value=firstName}}\n  {{input value=lastName}}\n  \u003cbutton type=\"submit\"\u003eDone\u003c/button\u003e\n{{/view}}\n\n\nAdding New Events\nEmber comes with built-in support for the following native browser\nevents:\n\n\n  \n    Event NameMethod Name\n  \n  \n    touchstarttouchStart\n    touchmovetouchMove\n    touchendtouchEnd\n    touchcanceltouchCancel\n    keydownkeyDown\n    keyupkeyUp\n    keypresskeyPress\n    mousedownmouseDown\n    mouseupmouseUp\n    contextmenucontextMenu\n    clickclick\n    dblclickdoubleClick\n    mousemovemouseMove\n    focusinfocusIn\n    focusoutfocusOut\n    mouseentermouseEnter\n    mouseleavemouseLeave\n    submitsubmit\n    changechange\n    dragstartdragStart\n    dragdrag\n    dragenterdragEnter\n    dragleavedragLeave\n    dragoverdragOver\n    dropdrop\n    dragenddragEnd\n  \n\n\nYou can add additional events to the event dispatcher when you create a\nnew application:\n\n  1\n2\n3\n4\n5\n6\n7\n\n  App = Ember.Application.create({\n  customEvents: {\n    // add support for the loadedmetadata media\n    // player event\n    'loadedmetadata': \"loadedMetadata\"\n  }\n});\n\n\n\nIn order for this to work for a custom event, the HTML5 spec must define\nthe event as \"bubbling\", or jQuery must have provided an event\ndelegation shim for the event.\nTemplated Views\nAs you've seen so far in this guide, the majority of views that you will\nuse in your application are backed by a template. When using templates,\nyou do not need to programmatically create your view hierarchy because\nthe template creates it for you.\n\nWhile rendering, the view's template can append views to its child views\narray. Internally, the template's {{view}} helper calls the view's\nappendChild method.\n\nCalling appendChild does two things:\n\n\nAdds the child view to the childViews array.\nImmediately renders the child view and adds it to the parent's render\nbuffer.\n\n\n\n  \n\n\nYou may not call appendChild on a view after it has left the rendering\nstate. A template renders \"mixed content\" (both views and plain text) so\nthe parent view does not know exactly where to insert the new child view\nonce the rendering process has completed.\n\nIn the example above, imagine trying to insert a new view inside of\nthe parent view's childViews array. Should it go immediately\nafter the closing \u003c/div\u003e of App.MyView? Or should it go after the\nclosing \u003c/div\u003e of the entire view? There is no good answer that will\nalways be correct.\n\nBecause of this ambiguity, the only way to create a view hierarchy using\ntemplates is via the {{view}} helper, which always inserts views\nin the right place relative to any plain text.\n\nWhile this works for most situations, occasionally you may want to have\ndirect, programmatic control of a view's children. In that case, you can\nuse Ember.ContainerView, which explicitly exposes a public API for\ndoing so.\nContainer Views\nContainer views contain no plain text. They are composed entirely of\ntheir child views (which may themselves be template-backed).\n\nContainerView exposes two public APIs for changing its contents:\n\n\nA writable childViews array into which you can insert Ember.View\ninstances.\nA currentView property that, when set, inserts the new value into\nthe child views array. If there was a previous value of\ncurrentView, it is removed from the childViews array.\n\n\nHere is an example of using the childViews API to create a view that\nstarts with a hypothetical DescriptionView and can add a new button at\nany time by calling the addButton method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n  App.ToolbarView = Ember.ContainerView.create({\n  init: function() {\n    var childViews = this.get('childViews');\n    var descriptionView = App.DescriptionView.create();\n\n    childViews.pushObject(descriptionView);\n    this.addButton();\n\n    return this._super();\n  },\n\n  addButton: function() {\n    var childViews = this.get('childViews');\n    var button = Ember.ButtonView.create();\n\n    childViews.pushObject(button);\n  }\n});\n\n\n\nAs you can see in the example above, we initialize the ContainerView\nwith two views, and can add additional views during runtime. There is a\nconvenient shorthand for doing this view setup without having to\noverride the init method:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  App.ToolbarView = Ember.ContainerView.create({\n  childViews: ['descriptionView', 'buttonView'],\n\n  descriptionView: App.DescriptionView,\n  buttonView: Ember.ButtonView,\n\n  addButton: function() {\n    var childViews = this.get('childViews');\n    var button = Ember.ButtonView.create();\n\n    childViews.pushObject(button);\n  }\n});\n\n\n\nAs you can see above, when using this shorthand, you specify the\nchildViews as an array of strings. At initialization time, each of the\nstrings is used as a key to look up a view instance or class. That view\nis automatically instantiated, if necessary, and added to the\nchildViews array.\n\n\n  \n\nTemplate Scopes\nStandard Handlebars templates have the concept of a context--the\nobject from which expressions will be looked up.\n\nWhen a Handlebars template in an Ember app uses an expression\n({{#if foo.bar}}), Ember will automatically set up an\nobserver for that path on the current context.\n\nIf the object referenced by the path changes, Ember will automatically\nre-render the block with the appropriate context. In the case of a\ncontext-preserving helper, Ember will re-use the original context when\nre-rendering the block. Otherwise, Ember will use the new value of the\npath as the context.\n\n  1\n2\n3\n\n  {{#if controller.isAuthenticated}}\n  \u003ch1\u003eWelcome {{controller.name}}\u003c/h1\u003e\n{{/if}}\n\n\n\nIn the above template, when the isAuthenticated property changes from\nfalse to true, Ember will render the block, using the original outer\nscope as its context.\nView Scope\nIn addition to the Handlebars context, templates in Ember also have the\nnotion of the current view. No matter what the current context is, the\nview property always references the closest view.\n\nNote that the view property never references the internal views\ncreated for block expressions like {{#if}}. This allows you to\ndifferentiate between Handlebars contexts, which always work the way\nthey do in vanilla Handlebars, and the view hierarchy.\n\nBecause view points to an Ember.View instance, you can access any\nproperties on the view by using an expression like view.propertyName.\nYou can get access to a view's parent using view.parentView.\n\nFor example, imagine you had a view with the following properties:\n\n  1\n2\n3\n4\n\n  App.MenuItemView = Ember.View.create({\n  templateName: 'menu_item_view',\n  bulletText: '*'\n});\n\n\n\nâ¦and the following template:\n\n  1\n\n  {{view.bulletText}} {{name}}\n\n\n\nYou can still access the view's bulletText by referencing view.bulletText.\nTemplate Variables\nSo far in this guide, we've been handwaving around the use of the\ncontroller property in our Handlebars templates. Where does it come\nfrom?\n\nHandlebars contexts in Ember can inherit variables from their parent\ncontexts. Before Ember looks up a variable in the current context, it\nfirst checks in its template variables. As a template creates new\nHandlebars scope, they automatically inherit the variables from their\nparent scope.\n\nEmber defines these view and controller variables, so they are\nalways found first when an expression uses the view or controller\nnames.\n\nAs described above, Ember sets the view variable on the Handlebars\ncontext whenever a template uses the {{#view}} helper. Initially,\nEmber sets the view variable to the view rendering the template.\n\nEmber sets the controller variable on the Handlebars context whenever\na rendered view has a controller property. If a view has no\ncontroller property, it inherits the controller variable from the\nmost recent view with one.\nOther Variables\nHandlebars helpers in Ember may also specify variables. For example, the\n{{#with controller.person as |tom|}} form specifies a tom variable\nthat descendant scopes can access. Even if a child context has a tom\nproperty, the tom variable will supersede it.\n\nThis form has one major benefit: it allows you to shorten long paths\nwithout losing access to the parent scope.\n\nIt is especially important in the {{#each}} helper, which provides\nthe {{#each people as |person|}} form.\nIn this form, descendant context have access to the person variable,\nbut remain in the same scope as where the template invoked the each.\n\n  1\n2\n3\n4\n5\n6\n7\n\n  \u003ch1\u003eTitle\u003c/h1\u003e\n\u003cul\u003e\n{{#each controller.people as |person|}}\n  {{! prefix here is controller.preferences.prefix }}\n  \u003cli\u003e{{prefix}}: {{person.fullName}}\u003c/li\u003e\n{{/each}}\n\u003cul\u003e\n\n\n\nNote that these variables inherit through ContainerViews, even though\nthey are not part of the Handlebars context hierarchy.\nAccessing Template Variables from Views\nIn most cases, you will need to access these template variables from\ninside your templates. In some unusual cases, you may want to access the\nvariables in-scope from your view's JavaScript code.\n\nYou can do this by accessing the view's templateVariables property,\nwhich will return a JavaScript object containing the variables that were\nin scope when the view was rendered. ContainerViews also have access\nto this property, which references the template variables in the most\nrecent template-backed view.\n\nAt present, you may not observe or bind a path containing\ntemplateVariables.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"9abe4a0a224c7b4dd7e1723da4745aa3","fields":[{"name":"title","value":"Adding Layouts to Views","type":"string"},{"name":"url","value":"/views/adding-layouts-to-views/","type":"enum"},{"name":"body","value":"Views can have a secondary template that wraps their main template. Like templates,\nlayouts are Handlebars templates that will be inserted inside the\nview's tag.\n\nTo tell a view which layout template to use, set its layoutName property.\n\nTo tell the layout template where to insert the main template, use the Handlebars {{yield}} helper.\nThe HTML contents of a view's rendered template will be inserted where the {{yield}} helper is.\n\nFirst, you define the following layout template:\n\n  \n    \n      app/templates/my-layout.hbs\n    \n  \n\n  1\n2\n3\n\n  \u003cdiv class=\"content-wrapper\"\u003e\n  {{yield}}\n\u003c/div\u003e\n\n\n\nAnd then the following main template:\n\n  \n    \n      app/templates/has-a-layout.hbs\n    \n  \n\n  1\n\n    Hello, \u003cb\u003e{{view.name}}\u003c/b\u003e!\n\n\n\nFinally, you define a view, and instruct it to wrap the template with the defined layout:\n\n  \n    \n      app/views/with-a-layout.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.View.extend({\n  name: 'Teddy',\n  layoutName: 'my-layout',\n  templateName: 'has-a-layout'\n});\n\n\n\nThis will result in view instances containing the following HTML\n\n  1\n2\n3\n\n  \u003cdiv class=\"content-wrapper\"\u003e\n  Hello, \u003cb\u003eTeddy\u003c/b\u003e!\n\u003c/div\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"3e49b1636055b7f6c48acfb964ac9f48","fields":[{"name":"title","value":"Built-in Views","type":"string"},{"name":"url","value":"/views/built-in-views/","type":"enum"},{"name":"body","value":"Ember comes pre-packaged with a set of views for building basic controls like text inputs, check boxes, and select lists. Usually, these views will be used via the input helpers. However, the base views may be helpful in creating custom form behaviors.\n\n\nEmber.Checkbox\nEmber.TextField\nEmber.TextArea\n\n\nFor example, here we have created a custom text field that toggles a dirty property:\n\n  \n    \n      app/templates/some-template-using-a-view.hbs\n    \n  \n\n  1\n\n  {{view \"my-input\" value=name inputDidChange=nameDidChange}}\n\n\n\n  \n    \n      app/views/my-input.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n\n  export default Ember.TextField.extend({\n  inputDidChange: false,\n  change: function() {\n    this.set('inputDidChange', true);\n  }\n});\n\n\n\nEmber itself provides one additional view not covered by the input helpers, and this is the select box view.\n\n\nEmber.Select\n\n\nThis class can also be customized by extending it. To use the select view bundled with Ember, call it via the view helper:\n\n  1\n2\n3\n4\n5\n\n  {{view \"select\" content=people\n                optionLabelPath=\"content.fullName\"\n                optionValuePath=\"content.id\"\n                prompt=\"Pick a person:\"\n                selection=selectedPerson}}\n\n\n\nThe select view is extremely feature-rich, and may perform badly when rendering many items. Due to this, it has not yet been converted into an component or helper like other inputs.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"7b97e923f66a0d4d78a9e2a914b543da","fields":[{"name":"title","value":"Customizing a View's Element","type":"string"},{"name":"url","value":"/views/customizing-a-views-element/","type":"enum"},{"name":"body","value":"A view is represented by a single DOM element on the page. You can change what kind of element is created by\nchanging the tagName property.\n\n  \n    \n      app/views/my-view.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.View.extend({\n  tagName: 'span'\n});\n\n\n\nYou can also specify which class names are applied to the view by setting its classNames property to an array of strings:\n\n  \n    \n      app/views/my-view.js\n    \n  \n\n  1\n2\n3\n\n  export default Ember.View.extend({\n  classNames: ['my-view']\n});\n\n\n\nIf you want class names to be determined by the state of properties on the view, you can use class name bindings. If you bind to\na Boolean property, the class name will be added or removed depending on the value:\n\n  \n    \n      app/views/my-view.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.View.extend({\n  classNameBindings: ['isUrgent'],\n  isUrgent: true\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view is-urgent\"\u003e\n\n\n\nIf isUrgent is changed to false, then the is-urgent class name will be removed.\n\nBy default, the name of the Boolean property is dasherized. You can customize the class name\napplied by delimiting it with a colon:\n\n  \n    \n      app/views/my-view.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.View.extend({\n  classNameBindings: ['isUrgent:urgent'],\n  isUrgent: true\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view urgent\"\u003e\n\n\n\nBesides the custom class name for the value being true,\nyou can also specify a class name which is used when the value is false:\n\n  \n    \n      app/views/my-view.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.View.extend({\n  classNameBindings: ['isEnabled:enabled:disabled'],\n  isEnabled: false\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view disabled\"\u003e\n\n\n\nYou can also specify to only add a class when the property is false by declaring classNameBindings like this:\n\n  \n    \n      app/views/my-view.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.View.extend({\n  classNameBindings: ['isEnabled::disabled'],\n  isEnabled: false\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view disabled\"\u003e\n\n\n\nIf the isEnabled property is set to true, no class name is added:\n\n  1\n\n  \u003cdiv class=\"ember-view\"\u003e\n\n\n\nIf the bound value is a string, that value will be added as a class name without\nmodification:\n\n  \n    \n      app/views/my-view.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.View.extend({\n  classNameBindings: ['priority'],\n  priority: 'highestPriority'\n});\n\n\n\nThis would render this HTML:\n\n  1\n\n  \u003cdiv class=\"ember-view highestPriority\"\u003e\n\n\nAttribute Bindings on a View\nYou can bind attributes to the DOM element that represents a view by using attributeBindings:\n\n  \n    \n      app/views/my-view.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.View.extend({\n  tagName: 'a',\n  attributeBindings: ['href'],\n  href: \"http://emberjs.com\"\n});\n\n\n\nYou can also bind these attributes to differently named properties:\n\n  \n    \n      app/views/my-view.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.View.extend({\n  tagName: 'a',\n  attributeBindings: ['customHref:href'],\n  customHref: \"http://emberjs.com\"\n});\n\n\nCustomizing a View's Element from Handlebars\nWhen you append a view, it creates a new HTML element that holds its content.\nIf your view has any child views, they will also be displayed as child nodes\nof the parent's HTML element.\n\nBy default, new instances of Ember.View create a \u003cdiv\u003e element. You can\noverride this by passing a tagName parameter:\n\n  1\n\n  {{view \"info\" tagName=\"span\"}}\n\n\n\nYou can also assign an ID attribute to the view's HTML element by passing an id parameter:\n\n  1\n\n  {{view \"info\" id=\"info-view\"}}\n\n\n\nThis makes it easy to style using CSS ID selectors:\n\n  1\n2\n3\n4\n\n  /** Give the view a red background. **/\n#info-view {\n  background-color: red;\n}\n\n\n\nYou can assign class names similarly:\n\n  1\n\n  {{view \"info\" class=\"info urgent\"}}\n\n\n\nYou can bind class names to a property of the view by using classBinding instead of class.\n\n  \n    \n      app/views/alert.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.View.extend({\n  priority: \"p4\",\n  isUrgent: true\n});\n\n\n\n  1\n\n  {{view \"alert\" classBinding=\"isUrgent priority\"}}\n\n\n\nThis yields a view wrapper that will look something like this:\n\n  1\n\n  \u003cdiv id=\"ember420\" class=\"ember-view is-urgent p4\"\u003e\u003c/div\u003e\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"99372a2930dba75d6ceeb1e3c4db65cd","fields":[{"name":"title","value":"Defining a View","type":"string"},{"name":"url","value":"/views/defining-a-view/","type":"enum"},{"name":"body","value":"You can use Ember.View to render a Handlebars template and insert it into the DOM.\n\nTo tell the view which template to use, set its templateName property. For example\nif your project contains this template:\n\n  \n    \n      app/templates/say-hello.hbs\n    \n  \n\n  1\n\n  Hello, \u003cb\u003e{{view.name}}\u003c/b\u003e\n\n\n\nI would set the templateName property to \"say-hello\".\n\n  \n    \n      app/views/some-view.js\n    \n  \n\n  1\n2\n3\n4\n\n  var view = Ember.View.create({\n  templateName: 'say-hello',\n  name: \"Bob\"\n});\n\n\n\nNote: For the remainder of the guide, the templateName property will be omitted from most examples. You can assume that if we show a code sample that includes an Ember.View and a Handlebars template, the view has been configured to display that template via the templateName property.\n\nYou can append views to the document by calling appendTo:\n\n  1\n\n  view.appendTo('#container');\n\n\n\nAs a shorthand, you can append a view to the document body by calling append:\n\n  1\n\n  view.append();\n\n\n\nTo remove a view from the document, call remove:\n\n  1\n\n  view.remove();\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"1ad48073ebb749972afb87f99875d99a","fields":[{"name":"title","value":"Handling Events","type":"string"},{"name":"url","value":"/views/handling-events/","type":"enum"},{"name":"body","value":"Instead of having to register event listeners on elements you'd like to\nrespond to, simply implement the name of the event you want to respond to\nas a method on your view.\n\nFor example, imagine we have a template like this:\n\n  1\n2\n3\n\n  {{#view \"clickable\"}}\n  This is a clickable area!\n{{/view}}\n\n\n\nLet's implement view:clickable such that when it is\nclicked, an alert is displayed:\n\n  \n    \n      app/views/clickable.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.View.extend({\n  click: function(evt) {\n    alert(\"ClickableView was clicked!\");\n  }\n});\n\n\n\nEvents bubble up from the target view to each parent view in succession,\nuntil the root view. These values are read-only. If you want to\nmanually manage views in JavaScript (instead of creating them using\nthe {{view}} helper in Handlebars), see the Ember.ContainerView\ndocumentation below.\nSending Events\nTo have the click event from view:clickable affect the state of your application,\nsimply send an event to the view's controller:\n\n  \n    \n      app/views/clickable.js\n    \n  \n\n  1\n2\n3\n4\n5\n\n  export default Ember.View.extend({\n  click: function(evt) {\n    this.get('controller').send('turnItUp', 11);\n  }\n});\n\n\n\nIf the controller has an action handler called turnItUp, it will be called:\n\n  \n    \n      app/controllers/play-back.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Controller.extend({\n  actions: {\n    turnItUp: function(level){\n      //Do your thing\n    }\n  }\n});\n\n\n\nIf it doesn't, the message will be passed to the current route:\n\n  \n    \n      app/routes/play-back.js\n    \n  \n\n  1\n2\n3\n4\n5\n6\n7\n\n  export default Ember.Route.extend({\n  actions: {\n    turnItUp: function(level){\n      //This won't be called if it's defined on controllers:play-back\n    }\n  }\n});\n\n\n\nTo see a full listing of the Ember.View built-in events, see the\ndocumentation section on Event Names.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"62a94fb99b85945d4fc027b44f150a62","fields":[{"name":"title","value":"Introduction","type":"string"},{"name":"url","value":"/views/","type":"enum"},{"name":"body","value":"Because Handlebars templates in Ember.js are so powerful, the majority\nof your application's user interface will be described using them. If\nyou are coming from other JavaScript libraries, you may be surprised at\nhow few views you have to create.\n\nViews in Ember.js are typically only created for the following reasons:\n\n\nWhen you need sophisticated handling of user events\nWhen you want to create a re-usable component\n\n\nOften, both of these requirements will be present at the same time.\nEvent Handling\nThe role of the view in an Ember.js application is to translate\nprimitive browser events into events that have meaning to your\napplication.\n\nFor example, imagine you have a list of todo items. Next to each todo is\na button to delete that item:\n\n\n\nThe view is responsible for turning a primitive event (a click) into a\nsemantic event: delete this todo! These semantic events are first sent\nup to the controller, or if no method is defined there, your application's\nrouter, which is responsible for reacting to the event based on the\ncurrent state of the application.\n\n\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"b16f3beecbf81e69c258e6d7f209cb19","fields":[{"name":"title","value":"Inserting Views in Templates","type":"string"},{"name":"url","value":"/views/inserting-views-in-templates/","type":"enum"},{"name":"body","value":"So far, we've discussed writing templates for a single view. However, as your application grows, you will often want to create a hierarchy of views to encapsulate different areas on the page. Each view is responsible for handling events and maintaining the properties needed to display it.\n{{view}}\nTo add a child view to a parent, use the {{view}} helper.\nThe {{view}} helper takes a string used to look up the view class.\n\n  \n    \n      app/views/user.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.View.extend({\n  firstName: \"Albert\",\n  lastName: \"Hofmann\"\n});\n\n\n\n  \n    \n      app/views/info.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.View.extend({\n  posts: 25,\n  hobbies: \"Riding bicycles\"\n});\n\n\n\n  \n    \n      app/templates/user.hbs\n    \n  \n\n  1\n2\n\n  User: {{view.firstName}} {{view.lastName}}\n{{view \"info\"}}\n\n\n\n  \n    \n      app/templates/info.hbs\n    \n  \n\n  1\n2\n3\n\n  \u003cb\u003ePosts:\u003c/b\u003e {{view.posts}}\n\u003cbr\u003e\n\u003cb\u003eHobbies:\u003c/b\u003e {{view.hobbies}}\n\n\n\nIf we were to create an instance of view:user and render it, we would get\na DOM representation like this:\n\n  1\n2\n3\n4\n5\n6\n\n  User: Albert Hofmann\n\u003cdiv\u003e\n  \u003cb\u003ePosts:\u003c/b\u003e 25\n  \u003cbr\u003e\n  \u003cb\u003eHobbies:\u003c/b\u003e Riding bicycles\n\u003c/div\u003e\n\n\nSetting Child View Templates\nIf you'd like to specify the template your child views use inline in\nthe main template, you can use the block form of the {{view}} helper.\nWe might rewrite the above example like this:\n\n  \n    \n      app/views/user.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.View.extend({\n  firstName: \"Albert\",\n  lastName: \"Hofmann\"\n});\n\n\n\n  \n    \n      app/views/info.js\n    \n  \n\n  1\n2\n3\n4\n\n  export default Ember.View.extend({\n  posts: 25,\n  hobbies: \"Riding bicycles\"\n});\n\n\n\n  1\n2\n3\n4\n5\n6\n\n  User: {{view.firstName}} {{view.lastName}}\n{{#view \"info\"}}\n  \u003cb\u003ePosts:\u003c/b\u003e {{view.posts}}\n  \u003cbr\u003e\n  \u003cb\u003eHobbies:\u003c/b\u003e {{view.hobbies}}\n{{/view}}\n\n\n\nWhen you do this, it may be helpful to think of it as assigning views to\nportions of the page. This allows you to encapsulate event handling for just\nthat part of the page.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]},{"external_id":"7bdc4108734011d72e1ca19d88932dbb","fields":[{"name":"title","value":"Manually Managing View Hierarchy","type":"string"},{"name":"url","value":"/views/manually-managing-view-hierarchy/","type":"enum"},{"name":"body","value":"Ember.ContainerView\nAs you probably know by now, views usually create their child views\nby using the {{view}} helper. However, it is sometimes useful to\nmanually manage a view's child views.\nEmber.ContainerView\nis the way to do just that.\n\nAs you programmatically add or remove views to a ContainerView,\nthose views' rendered HTML are added or removed from the DOM to\nmatch.\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n  var container = Ember.ContainerView.create();\ncontainer.append();\n\nvar firstView = App.FirstView.create(),\n    secondView = App.SecondView.create();\n\ncontainer.pushObject(firstView);\ncontainer.pushObject(secondView);\n\n// When the rendering completes, the DOM\n// will contain a `div` for the ContainerView\n// and nested inside of it, a `div` for each of\n// firstView and secondView.\n\n\nDefining the Initial Views of a Container View\nThere are a few ways to specify which initial child views a\nContainerView should render. The most straight-forward way is to add\nthem in init:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n  var container = Ember.ContainerView.create({\n  init: function() {\n    this._super();\n    this.pushObject(App.FirstView.create());\n    this.pushObject(App.SecondView.create());\n  }\n});\n\ncontainer.objectAt(0).toString(); //=\u003e '\u003cApp.FirstView:ember123\u003e'\ncontainer.objectAt(1).toString(); //=\u003e '\u003cApp.SecondView:ember124\u003e'\n\n\n\nAs a shorthand, you can specify a childViews property that will be\nconsulted on instantiation of the ContainerView also. This example is\nequivalent to the one above:\n\n  1\n2\n3\n4\n5\n6\n\n  var container = Ember.ContainerView.extend({\n  childViews: [App.FirstView, App.SecondView]\n});\n\ncontainer.objectAt(0).toString(); //=\u003e '\u003cApp.FirstView:ember123\u003e'\ncontainer.objectAt(1).toString(); //=\u003e '\u003cApp.SecondView:ember124\u003e'\n\n\n\nAnother bit of syntactic sugar is available as an option as well:\nspecifying string names in the childViews property that correspond\nto properties on the ContainerView. This style is less intuitive\nat first but has the added bonus that each named property will\nbe updated to reference its instantiated child view:\n\n  1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n  var container = Ember.ContainerView.create({\n  childViews: ['firstView', 'secondView'],\n  firstView: App.FirstView,\n  secondView: App.SecondView\n});\n\ncontainer.objectAt(0).toString(); //=\u003e '\u003cApp.FirstView:ember123\u003e'\ncontainer.objectAt(1).toString(); //=\u003e '\u003cApp.SecondView:ember124\u003e'\n\ncontainer.get('firstView').toString(); //=\u003e '\u003cApp.FirstView:ember123\u003e'\ncontainer.get('secondView').toString(); //=\u003e '\u003cApp.SecondView:ember124\u003e'\n\n\nIt Feels Like an Array Because it is an Array\nYou may have noticed that some of these examples use pushObject to add\na child view, just like you would interact with an Ember array.\nEmber.ContainerView\ngains its collection-like behavior by mixing in\nEmber.MutableArray. That means\nthat you can manipulate the collection of views very expressively, using\nmethods like pushObject, popObject, shiftObject, unshiftObject, insertAt,\nremoveAt, or any other method you would use to interact with an Ember array.\n","type":"string"},{"name":"info","value":"","type":"string"},{"name":"image","value":"","type":"enum"}]}]}